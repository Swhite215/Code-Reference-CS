Data Structures and Algorithm Analysis

Pre Test Review
    1. Matrices
        - Square Matrix - n rows = n columns
        - Transpose - switches rows and columns
        - Representation - Two Dimensional Arrays
        - Important Example
            - Matrices A, B, and C
            - Cᵢⱼ = Summation from k = 1 to n of Aik*Bkj
                - k indexes the columns of A and the rows of B
            - Matrix Multiplication
            - Psuedo Code for Matrix Multiplication
                - Pre - A and B are square matrices of size nxn
                - matrixMultiplication(A,B):
                    C <- create new matrix of size n rows and n columns
                    for i <- 0 to n do:
                        for j <- 0 to n do:
                            C[i][j] <- 0
                            for k = 0 to n do:
                                C[i][j] <- C[i][j] + (A[i][k] * B[k][j])
                    return C
    2. Recursion Pseudocode
        - factorial(n)
            if n = 0
                return 1
            return n * factorial(n - 1)
        - fibonnaci(n)
            if n = 0
                return 1
            if n = 1
                return 1
            return fibonnaci(n - 1) + fibonnaci(n - 2)
        - Node* find(Node* L, int t)
            if (L = nullptr)
                return L
            if (L->data = t)
                return L
            find(L->next)
        - linearSum(A, n)
            if n = 1
                return A[0]
            return LinearSum(A, n - 1) + A[n-1]
        - reverseArray(A, i, j)
            if i < j
                Swap A[i] and A[j]
                ReverseArray(A, i + 1, j - 1)
            return
    3. Sorting Algorithms Pseudocode
        - linearSearch(arr, t)
        - binarySearch(l, r, t)
    4. Extra Algorithms Pseudocode
        - fibonnaci(n)
            if n = 0
                return 0
            if n = 1
                return 1
            first <- 0
            second <- 1
            sum <- 0
            for i <- 2 to n do:
                sum <- first + second
                first <- second
                second <- sum
            return sum
        - Node* find(Node* L, int t)
            while (L != null)
                if (L->data = t)
                    return L
                L <- L->next
            return nullptr
        - reverseArray(A, i, j)
            while i < j do
                Swap A[i] and A[j]
                i <- i + 1
                j <- j - 1
            return
    5. Graphs and Trees
        - Vertex - Nodes
        - Edges - Lines
        - Tree vs. Graph
            - Tree - graph with no circuits or loops, single path between every node
            - Path - sequences of edges that you follow, from node to node
        - Rooted Tree - Tree with a determined root from which the remainder of the tree grows
        - Height/Depth - Longest Possible Path from Root to Leaf
        - Spanning Tree - subgraph of original graph that form a tree
    6. Abstract Data Type
        - ADT - concept of data, and functions that operate on the data
        - Structuree - implementation of an ADT


                
