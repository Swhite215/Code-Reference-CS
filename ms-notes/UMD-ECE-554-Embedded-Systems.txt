Embedded Systems ECE 554

1. Lecture 1
    - System Concepts
        - Define - mapping of a set of inputs into a set of ouptuts
        - Stimulus - input
        - Behavior - response
        - Response Time - time between stimulus and behavior
        - Embedded System - hardware/software computer system embedded within and controlling a product
        - Real Time System - system that must satisfy explicit bounded response time constrains or risk servere consequences including failure
            - Airplane Surface Flight Controller, Reservation System, Computer Game
        - Failed System - A system that cannot satisfy one or more of the requirements stipulated in the system specification
        - Real Time System - one whose logical correctness is based on both the correctness of the outputs and their timeliness
        - Soft Real Time System - one in which performance is degraded but not destroyed by failure to meet constraints on response time
        - Firm Real Time System - missing more than a few deadlines may lead to complete and catastrophic system failure
        - Hard Real Time System - missing a single deadling may lead to complete and catastrophic system failure
        - Event - causes the proigram counter to change nonsequentially
            - Synchronous - occur at predictable times
            - Asynchronous - occur at unpredictable times
            - Aperiodic - do not occur at regular intervals
            - Sporadic - aperiodic that occur infrequently
            - Periodic - occur at regular intervals
        - Release Time - time at which an instance of a scheduled task is ready to run, generally associated with an interrupt
        - Determinism - for each possible state and each set of inputs, a unique set of outputs and next state of the system can be determined
        - Time Loading - CPU utilization U is a measure of non-idle processing
            - U = Summations from 1 to N of ei/pi
            - 0-25%
            - 26-50% - Very Safe
            - 51-68% - Safe
            - 69% - Theoretical Limit
            - 70-82% - Questionable
            - 83-99% - Dangerous
            - 100+ - Overloaded

2. Lecture 2
    - Computer Hardware and Architecture Review
        - Basics
            - Primary Memory - Random Access Memory RAM
            - Secondary Memory - Hard Disk
            - CPU - Central Processing Unit
                - Interrupt Controller
                - Control Unit
                - Arithmetic Logic Unit
                - Process - Fetch, Decode, Execute
            - Bus
                - Data, Address, Command
            - Input and Output
        - Microcontrollers - computer system that is programmable via microinstructions
            - Microinsstruction Register, Microcontrol Unit, Decoder, Microinstructions, Micromemory
        - Instruction Sets
            - Addressing Modes
                - Implied - location of data implicit in instruction
                - Immediate - data specified in instructions
                - Direct - address of data in instruction
                - Indirect - address of address in instruction
                - Register Direct - operands in regsiter
                - Register Indirect - address of operand in register
                - Indexed - context of index register added to offset in instruction to get address
            - Types
                - 0 - implied, uses stack, many instructions required for simple tasks - long program fast execution
                - 1 - implied or 1 address, accumulator in CPU
                - 2 - two register or memory references allowed
                - 3 - three register or memory references allowed
        - Reduced Instruction Set Computer - fewer instructions using 2 or 3, longer program, load/store access to memory, simple
            - Simple instructions take one clock cycle
            - LOAD/STORE architecture to reference memory
            - Highly pipelined design
            - Instructions executed direclty by hardware
            - Fixed format instructions
            - Few instructions and addressing modes
            - Large multiple register sets
            - Complexity handled by the compiler and software
        - Complex Instruction Set Computer - many instructions and addresss modes, complex, shorter programs
            - Complex instructions take many different cycles
            - Any instruction can reference memory
            - No instructions are pipelined
            - A micro-program is executed for each native instruction
            - Instructions are of variable format
            - Multiple instructions and addressing modes
            - Single set of registers
            - Complexity is in the micro-program and hardware
        - Memory Technologies
            - Read and Write RAM
            - Read Only Memory
            - Dynamic RAM - 50-60ns
            - Static RAM - 10-20ns
            - Electronically Erasable Programmable Read Only Memory - 50-100ns
            - Flash - 20-50ns
            - Hierarhcy
                - Internal CPU Memory
                - Registers
                - Cache
                - Main Memory
                - Memory on External Devices
        - I/O Devices
            - Memory-Mapped I/O - address of I/O devices are mapped into CPUs addressable memory
            - I/O Mapped I/O - separate instructions used for I/O access
            - I/O Methods
                - Polling, Interrupt-Driven, Direct Memory Access
                    - DMA Steps
                        - I/O Device Request DMA
                        - DMA Controller Requests Bus
                        - CPU Grants Bus
                        - DMA Controller Gives DMA ACK
                        - Device Transfers Data
                        - DMA Interrupts CPU at Done
            - Bit Map - view of a set of devices that are accessed by a single discrete signal and organized into a single word of memory for convenient access
        - Interrupt Pattern
            - Interrup Signal to CPU
            - CPU Completes Instruction
            - CPU Saves Program Counter (Next Instruction)
            - CPU Loads PC w/ Address of Interrupt Signal Routine
            - ISR Runs
            - CPU Retrieves Original PC and Resumes
        - External Programmable Interrupt Controller - prioritizes interrupts
            - Interrupt Register, Priroity Register, Interrupt Vector, Status Register, Mask Register
        - Pipelining and Co-Processors
            - Pipelining - FDE at every clock pulse
            - Co-Processor - processor loads co-processor to perform calculation
        - ASIC - Applicaiton Spefici Integrated Circuits
        - Programmable Array Logic or Logic Array - programmable AND array followed by a fixed number of input OR elements
        - Field Programmable Gate Array - provides the construction for a system on a chipe with an integrated processor, memory, and I/O
        - Transducers - converts energy from one form to another
        - Temperature Sensors
        - Accelerometers
        - Gyroscopes
        - Position Revolvers
        - Analog/Digital Converters
            - A/D voltage input to digital output
            - D/A digital output to voltage
        - Non-Von Neumann
            - Ring, Hypercube, Mesh
        - Flynns Taxonomy for Parallelism
            - Single Instruction Single Data
            - Single Instruction, Multiple Data
            - Multiple Instruction, Single Data
            - Multiple Instruction, Multiple Data
        
External Lecture 1
    - Choosing an Embedded Controller
        - Know the Application - power, floating point, OS, I/O, internet connection, size, algorithms
        - Choose a Processor - 4, 8, 16, 32, or 64 bit
        - Evaluate the Processor's Performance
        - Decide on the Memory Needed - RAM, ROM/Flash, EEPRON, Mask ROM
        - Choose the I/O Needs - general, serial, A/D and D/A
        - Select other Peripherals - clock, timer, watchdog, ethernet, pulse width modulation, power saving, etc.
        - Find Available Tools and Software - compilers, ICE, evaluation boards, operating systems

Lecture 3
    - Language Issues - chartacteristics of a language significantly affect the real time performance of the program
        - Languages - FORTRAN, C, Ada, Pascal, Modula-2
        - Parameter Passing
            - Global Variables, Call by Value, Call by Reference
        - Recursion - good structured programming, bad due to unknown stack size - Convert Recursive to Non-Recursive
        - Re-Entrant - program segment that can be concurrenlty executed by two or more threads
        - Non-Reentraant - program segment that is cllaed a critical section or vulnerable window, where a thread executing in the window is interrupted by a second thread
        - Dynamic Allocation - slow but important
        - Typing - Strong, Weak
        - Exception Handling - Ada is best
        - Abstract Data Types - records, structures, custom types, etc. e.g. enum
        - Object Oriented Languages - Abstract Data Types, Inheritance, Polymorphism
        - Modularity
        - C Special Variable Types
            - Register - CPU register
            - Volatile - wont optimize code affecting this variable
            - static - known only to fgunctions within the file, "private" global
        - Assembly - efficient, difficult, tedious, error prone, not portable
    - Rules
        - Avoid Recursion
        - Avoid Unbounded While Loops
        - Avoid Priority Inversion
        - Avoid Over-Engineering
        - Know the Compiler

Lecture 4
    - Software Design Lifecycle
        - Planning, Requirements, Design, Implementation, Test, Maintenance
    - Waterfall Model - Linear
        - Simple, Easy, Divides the Task, Straightforward
        - Requires a lot of up front planning, if requirements change, must start at the beginning, little sense of progress till end
        - Concepts - WHY, Requirements WHAT - Functional and Non-Functional, Design - HOW, Programming, Test, Maintenance
        - Parnas Partitioning - identify all difficult design decisions e.g. things likely to change, design modules to hide these things from the rest of the system
    - Agile - Cyclical, Focus on Code Delivery
    - Standards
        - DOD-STD-2167A
            - System Requirements Analysis and Design
            - Software Requirements Analysis
            - Preliminary Design
            - Detailed Design
            - Coding and Computer Software Unit Testing
            - Computer Software Component Integration and Testing
            - Computer Sofftware Component Integration Item Testing
            - System Integration and Testing
        - ISO 9000-3
        - IEEE 830

Lecture 5
    - Real Time Specification and Design Techniques
        - Natural Languages
            - Pro - easy
            - Con - ambiguous, tedious
        - Mathematics
            - Pro - precise/unambiguous
            - Con - cryptic and difficult to understand, hard to use, 
        - Flowcharts
            - Pro - well understaood, okay for simple/small systems
            - Con - difficult showing interaction between simultaneous tasks, encourages GOTO
        - Structure Charts
            - Pro - widely used, Top-down design, sub-processes
            - Con - no conditional bnranching or concurrent process interaction
        - Pseudocode and PDLs
            - PDL - compiler
            - Pro - close to programming language, models concurrency, formal methods apply
            - Con - Learn language, error prone
        - Finite State Automata
            - Moore - outputs are a function of the current state only
            - Mealy - outputs are  afunctiuon of the current state and the inputs
            - Pro - widely used, easy, structured, can optimize
            - Con - cant see inside of states, difficult for concurrent processes
        - Dataflow Diagrams
            - Pro - widely used, shows concurrency, partitioning
            - Cons - must be used with other methods for Rt, difficult to show signaling/sync between processes
        - Petri Nets
            - Pro - mathematical, visual, concurrency/interprocess
            - Con - overkill for simple systems, timing can be obscure
        - Warnier-Orr Notation
            - Pro - branching, model data structures
            - Cons - diagrams can get very large and complex, sync of concurrent processes using only conditionals is restrictive, not well known
        - State Charts
            - Pro - structure of FSM, depth, concurrent processes, inter-process communication
            - Con - ????

Lecture 6
    - Real Time Kernels
        - Introduction
            - Specialized OS for size and speed
            - 3 Functions - Task Scheduling, Task Dispatching, Inter-Task Communication
        - Role of Kernel
            - Human Interface, Basic I/O, Extended I/O, User Applicaitons
        - Kernel Types
            - Nano-Kernel - dispatching, thread/task control and block management
            - Micro-Kernel - Task Scheduling 
            - Kernel - interprocessor communication and synchronization
            - Executive - Kernel + I/O Services - file and disk suppport
            - OS - Exectuve plus user I/F, security, file mgmt, etc. - user interface and shell
        - Implementation
            - Polled Loop
                - Simplest, infinite loop checking flags till an event occurs
                - Handle one event or several non overlapping events
                - +Interrupt - fixed clock interrupt to occur n times and process event
            - Phase/State-Driven
                - Facilitates basic multi-tasking system
                - Each task is divided into segments
                - Each segment executes without interruption
                - When a segment finishes executing, the task changes to the next state
                - Task can be suspended
            - Coroutines
                - Implementaiton of state-driven code into a multi-tasking system
                - Any single task can be state driven
                - Two or more tasks, executing simulataneously where each task is state driven
                - Dispatcher initiates Task 0 -> Task 0 Execute -> Save Context -> Dispatcher inits Task 1
            - Interrupt Driven
                - Interrupt Service Routine ISR
                - Fixed Rate -> Fixed Rate
                - Variable Rate -> Sporadic
                - Mixed-> Hybrid
                - Scheduling done via interrupt priorities
                - Switching context is an important cost - save PC, registers, status, flags
                - Task Control Block - context of a task
                    - PC, Register Contents, Processor Status, Task IDs, LINKED LIST
                    - States - Executing, Ready, Suspended, Dormant
                - Stack Model - use stack to store context, simpler and faster
                - Patterns
                    - Round-Robin - interrupt occurs at a fixed rate, task suspended, context saved, context loaded, task executes
                    - Preemptive Priority - a higher priority task can interrupt and prempt a lower priority task
                - Rate Monotonic Systems
                    - Special case of preemptive where priority is based on frequency of execution
                    - Problem - priority inversion - lower priority task may need to be executed frequently and may ned up holding a resource a high priority one needs
                 - Problem - time wasted in the loop, no useful work done with no interrupts
            - Foreground-Background
                - Solution to interupt, call main process in background and put slow, low priority useful tasks in it
                - Interrupt now called foreground
                - How to Acquire Data
                    - Read all parameters every 1ms - bad
                    - Read parameters at 3 rates
                        - Initiate each task by an interrupt that is synchronous to the 1ms, 10ms, or 100ms update rates
                        - Preemptive priority using rate monotonic i.e. 1ms has highest priority
                - Background
                    - Initialize ISRs, service the network, modify acquisition table
            - Full Features RTOS
                - Come w/ network interfaces, device drivers, debugging tools, etc.
                - Con - commercial RTOS is larger and usually slower/more generic

Lecture 7
    - Inter-task Communication and Synchronization
        - Data Sharing
            - Issues:
                - Embedded Server - Limited resource i.e. common netwqork link amongst two server applications
                - Task Division - A main task, B,C, and D substasks. Results of C and B combined by D
            - Solutions
                - Data Buffering
                    - Sharing data using global variables
                    - Used when difference between speed of data production vs consumption
                    - Double buffering - disable interrupts, load buffer, re-enable interrupts, use buffer data
                    - Ring Buffering - circular queue - Init, Put, Get
                - Mail Boxes
                    - Mutually agreed upon memory address that two or more tasks uses to pass data
                    - OS performs operations on mailbox, OS provides protection
                    - OS tracks mailbox stats to identify filled or empty
                    - Ring buffer and queue to control pool of devices
                - Sempahores
                    - Variable used to protect critical regions of code i..e code that accesses a shared resource
                    - Operations
                        - Wait or P(s) - read s until resource is available
                        - Signal or V(s) - sets s to available
                    - Mailboxes
                        - Use pend and post rather than wait and signal
                        - Waiting task is suspended
                    - Formats
                        - Binary
                        - Counter
                    - Counting Sempahore as Binary Semaphore
                        - Global Variable R - 3 resources avaiable
                        - Semaphore S - protects shared variable R
                        - Sempahore T - true if suspended task must wait
                    - Problems
                        - Test and Set - ability to test if something is fale or true and perform in action in a single step, avoding interrupts between reading and setting
                - Event Flags and Signals
                    - Event Flags - simulated interrupts created by the programmer
                    - ASNI-C
                        - Raise() - call signal operation for event
                        - signal() - set OS to fo to hanlder routine
                        - handler routing is blocked until event is raised
            - Deadlock
                - Idea - two or more tasks are competing for two or more shared resources
                - Conditions - ALL four are needed
                    - Mutual Exclusion - device can be shared by multiple tasks
                    - Circular Wait - each tasks holds a resource another needs, can fix by requiring all task to request resources in particular order
                    - Hold and Wait - task is holding resources while waiitng for others, can fix by never allowing a task to require more than one resource at a time
                    - No Preemption - higher priority taszk can't preempt a lower priority one
                - Banker's Algorithgm
                    - Can never assign more resources than exist
                    - Can never make a "dangerous" allocation"

Lecture 8
    - Real Time Memory Management
        - Process Stack Management
            - Idea - How do we keep track of the context of each task when we switch to another one?
            - Methods
                - Run-Time Stack
                    - Hard RT Systems - each ISR may be responsible to save only the context it will alter
                    - Commerical RTOS - general save() and restore() procedures for a fixed number of registers
                    - Traditional stacks work well on preemption priority type systems
                    - Round Robin - Ring-Buffer
                    - Alternative
                        - Use multiple stacks, one main and one for each task
                        - Advantage - can execute tasks in any order, not just in order that they are pushed
                        - Main stack contains pointers to run-time stacks for each task
                        - Last stack saves context when tasks are suspended
                    - Limit - tasks are not executed in the reverse order in which they were suspended
                - Task-Control Block
                    - Fixed Size - fixed # of tasks
                    - Variable - variable # of tasks - complex
                    - Round Robin or Preemptive
                        - TCB - each task stores its own Stack Pointer, in multiple stacks centrally store Stack Pointers
        - Dynamic Alloctation
            - Idea - How do we allocate memory required by the OS or by application tasks?
            - Bottom Line - no form of dynamic memory allocation is good
            - Methods - Secondary Memory
                - Swapping
                    - OS and 1 Task reside in memory
                    - Task is suspended, swapped to memory, and new task enters
                    - Issue - access time for context switch
                - Overlays
                    - Program broken into sections called overlays, only a subset of task overlays are in memory, same access time problem
                - Multiprogramming w/ Fixed Number of Tasks
                    - Application memory divided into a number of fixed-size partitions
                    - Tasks loaded on required memory, partitions assigned
                    - Constraint - task must be in contiguous partitions
                    - Problems
                        - External Fragmentation, enough memory for a task but it is not contiguous
                        - Internal Fragmentation, fixed-size block allocated to a ask but not all of it is utilized
                        - 
                        - Disk Swapping Time
                - Multiprogramming w/ Variable Number of Tasks
                    - Memory is allocated based on requests of process requesting memory
                    - Internal Fragmentation is elinminated
                    - External Fragmentation - still a problem
                    - Disk Swapping Time is still a problem
                - Paging
                    - Each task is broken into small fixed size blocks called pages
                    - Pages are loaded as needed and do not have to be contiguous
                    - Page Fault - a needed page is not in memory - use replacement method
                    - Disk Swapping - still a problem

Lecture 9
    - System Performance Analysis and Optimization
        - Performance Measure
            - Response Time - time from the request for a task until the task completes
            - Time Loading - percentage fo time CPU is doing useful processing
            - Memory Loading - percentage of usable memory in use
        - Measuring Response Time - Polled Loop Systems
            - Tr = time to check flag(s) + time to process
                - Send Flag ns + Check Flag us + Process Flag ms
        - Measuring Response Time - Coroutines/Phase Driven Code
            - Summation from i=1 to 5 of t sub Ai + t sub Bi
        - Measuring Response Time - Interrupt Driven System
            - t = Li + Cs + Ai
                - Li = latency time - time to recognize and process interrupt
                - Cs = context switch
                - Ai = actual ISR processing time
            - Factor weight - ns -> us -> us -> ms
        - Measuring Response Time Case 1
            - High priority task interrupting a lower priority
        - Mesuring Response Time CAse 2
            - Lower priority task interrupting a higher priority
        - Ways to Measure Time Loading
            - Logic Analyzer
            - Instruction Counting - REVIEW Example
        - Response Time and Time Loading
            - Compute at lowest cycle - all tasks should be done at slowest possible rate
            - Use scaled arithmetic - convert FP operations into integer
        - Scaled Arithmetic
        - Binary Angle Measurement
        - Look Up Table
        - Advice
            - Eliminate exponentials, square roots, or other time consuming calculations
        - Post Integration Software Optimization
            - Compiler Optimization  -List Slide 34 - Lecture 8.1
            - Reduction in Strength - use the fastere macroinstruction possible e.g. multiplying by a power of two use shift
            - Intrinsic functions - macros where the actual function call is replaced by inline code during compilation
            - Constant Folding - manually folding of constant multiples
            - Loop Invariant Optimization - move computations outside loops that do not need to be performed in the loop
            - Loop Induction Elimination - if every time i changes it value it is incremented or decremented by some constant
            - Register-to-Register > Register-to-Memory
            - Remove Redundant or Unreachable Code
            - Flow of Control Optimization - remove unnecessary jump to jump
            - Constant Propogation
            - Dead Store Elimination

REVIEW FOR TEST:
1. Lecture 7.0 Example - Measuring Time to Respond - Slide 40
2. Homework #3
3. Lecture 9 Video Example - Measuring Time Loading - 1:44
3. Scaled Arithmetic