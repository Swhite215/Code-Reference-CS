Embedded Systems ECE 554

1. Lecture 1
    - System Concepts
        - Define - mapping of a set of inputs into a set of ouptuts
        - Stimulus - input
        - Behavior - response
        - Response Time - time between stimulus and behavior
        - Embedded System - hardware/software computer system embedded within and controlling a product
        - Real Time System - system that must satisfy explicit bounded response time constrains or risk servere consequences including failure
            - Airplane Surface Flight Controller, Reservation System, Computer Game
        - Failed System - A system that cannot satisfy one or more of the requirements stipulated in the system specification
        - Real Time System - one whose logical correctness is based on both the correctness of the outputs and their timeliness
        - Soft Real Time System - one in which performance is degraded but not destroyed by failure to meet constraints on response time
        - Firm Real Time System - missing more than a few deadlines may lead to complete and catastrophic system failure
        - Hard Real Time System - missing a single deadling may lead to complete and catastrophic system failure
        - Event - causes the proigram counter to change nonsequentially
            - Synchronous - occur at predictable times
            - Asynchronous - occur at unpredictable times
            - Aperiodic - do not occur at regular intervals
            - Sporadic - aperiodic that occur infrequently
            - Periodic - occur at regular intervals
        - Release Time - time at which an instance of a scheduled task is ready to run, generally associated with an interrupt
        - Determinism - for each possible state and each set of inputs, a unique set of outputs and next state of the system can be determined
        - Time Loading - CPU utilization U is a measure of non-idle processing
            - U = Summations from 1 to N of ei/pi
            - 0-25%
            - 26-50% - Very Safe
            - 51-68% - Safe
            - 69% - Theoretical Limit
            - 70-82% - Questionable
            - 83-99% - Dangerous
            - 100+ - Overloaded

2. Lecture 2
    - Computer Hardware and Architecture Review
        - Basics
            - Primary Memory - Random Access Memory RAM
            - Secondary Memory - Hard Disk
            - CPU - Central Processing Unit
                - Interrupt Controller
                - Control Unit
                - Arithmetic Logic Unit
                - Process - Fetch, Decode, Execute
            - Bus
                - Data, Address, Command
            - Input and Output
        - Microcontrollers - computer system that is programmable via microinstructions
            - Microinsstruction Register, Microcontrol Unit, Decoder, Microinstructions, Micromemory
        - Instruction Sets
            - Addressing Modes
                - Implied - location of data implicit in instruction
                - Immediate - data specified in instructions
                - Direct - address of data in instruction
                - Indirect - address of address in instruction
                - Register Direct - operands in regsiter
                - Register Indirect - address of operand in register
                - Indexed - context of index register added to offset in instruction to get address
            - Types
                - 0 - implied, uses stack, many instructions required for simple tasks - long program fast execution
                - 1 - implied or 1 address, accumulator in CPU
                - 2 - two register or memory references allowed
                - 3 - three register or memory references allowed
        - Reduced Instruction Set Computer - fewer instructions using 2 or 3, longer program, load/store access to memory, simple
            - Simple instructions take one clock cycle
            - LOAD/STORE architecture to reference memory
            - Highly pipelined design
            - Instructions executed direclty by hardware
            - Fixed format instructions
            - Few instructions and addressing modes
            - Large multiple register sets
            - Complexity handled by the compiler and software
        - Complex Instruction Set Computer - many instructions and addresss modes, complex, shorter programs
            - Complex instructions take many different cycles
            - Any instruction can reference memory
            - No instructions are pipelined
            - A micro-program is executed for each native instruction
            - Instructions are of variable format
            - Multiple instructions and addressing modes
            - Single set of registers
            - Complexity is in the micro-program and hardware
        - Memory Technologies
            - Read and Write RAM
            - Read Only Memory
            - Dynamic RAM - 50-60ns
            - Static RAM - 10-20ns
            - Electronically Erasable Programmable Read Only Memory - 50-100ns
            - Flash - 20-50ns
            - Hierarhcy
                - Internal CPU Memory
                - Registers
                - Cache
                - Main Memory
                - Memory on External Devices
        - I/O Devices
            - Memory-Mapped I/O - address of I/O devices are mapped into CPUs addressable memory
            - I/O Mapped I/O - separate instructions used for I/O access
            - I/O Methods
                - Polling, Interrupt-Driven, Direct Memory Access
                    - DMA Steps
                        - I/O Device Request DMA
                        - DMA Controller Requests Bus
                        - CPU Grants Bus
                        - DMA Controller Gives DMA ACK
                        - Device Transfers Data
                        - DMA Interrupts CPU at Done
            - Bit Map - view of a set of devices that are accessed by a single discrete signal and organized into a single word of memory for convenient access
        - Interrupt Pattern
            - Interrup Signal to CPU
            - CPU Completes Instruction
            - CPU Saves Program Counter (Next Instruction)
            - CPU Loads PC w/ Address of Interrupt Signal Routine
            - ISR Runs
            - CPU Retrieves Original PC and Resumes
        - External Programmable Interrupt Controller - prioritizes interrupts
            - Interrupt Register, Priroity Register, Interrupt Vector, Status Register, Mask Register
        - Pipelining and Co-Processors
            - Pipelining - FDE at every clock pulse
            - Co-Processor - processor loads co-processor to perform calculation
        - ASIC - Applicaiton Spefici Integrated Circuits
        - Programmable Array Logic or Logic Array - programmable AND array followed by a fixed number of input OR elements
        - Field Programmable Gate Array - provides the construction for a system on a chipe with an integrated processor, memory, and I/O
        - Transducers - converts energy from one form to another
        - Temperature Sensors
        - Accelerometers
        - Gyroscopes
        - Position Revolvers
        - Analog/Digital Converters
            - A/D voltage input to digital output
            - D/A digital output to voltage
        - Non-Von Neumann
            - Ring, Hypercube, Mesh
        - Flynns Taxonomy for Parallelism
            - Single Instruction Single Data
            - Single Instruction, Multiple Data
            - Multiple Instruction, Single Data
            - Multiple Instruction, Multiple Data
        
External Lecture 1
    - Choosing an Embedded Controller
        - Know the Application - power, floating point, OS, I/O, internet connection, size, algorithms
        - Choose a Processor - 4, 8, 16, 32, or 64 bit
        - Evaluate the Processor's Performance
        - Decide on the Memory Needed - RAM, ROM/Flash, EEPRON, Mask ROM
        - Choose the I/O Needs - general, serial, A/D and D/A
        - Select other Peripherals - clock, timer, watchdog, ethernet, pulse width modulation, power saving, etc.
        - Find Available Tools and Software - compilers, ICE, evaluation boards, operating systems

Lecture 3
    - Language Issues - chartacteristics of a language significantly affect the real time performance of the program
        - Languages - FORTRAN, C, Ada, Pascal, Modula-2
        - Parameter Passing
            - Global Variables, Call by Value, Call by Reference
        - Recursion - good structured programming, bad due to unknown stack size - Convert Recursive to Non-Recursive
        - Re-Entrant - program segment that can be concurrenlty executed by two or more threads
        - Non-Reentraant - program segment that is cllaed a critical section or vulnerable window, where a thread executing in the window is interrupted by a second thread
        - Dynamic Allocation - slow but important
        - Typing - Strong, Weak
        - Exception Handling - Ada is best
        - Abstract Data Types - records, structures, custom types, etc. e.g. enum
        - Object Oriented Languages - Abstract Data Types, Inheritance, Polymorphism
        - Modularity
        - C Special Variable Types
            - Register - CPU register
            - Volatile - wont optimize code affecting this variable
            - static - known only to fgunctions within the file, "private" global
        - Assembly - efficient, difficult, tedious, error prone, not portable
    - Rules
        - Avoid Recursion
        - Avoid Unbounded While Loops
        - Avoid Priority Inversion
        - Avoid Over-Engineering
        - Know the Compiler

Lecture 4
    - Software Design Lifecycle
        - Planning, Requirements, Design, Implementation, Test, Maintenance
    - Waterfall Model - Linear
        - Simple, Easy, Divides the Task, Straightforward
        - Requires a lot of up front planning, if requirements change, must start at the beginning, little sense of progress till end
        - Concepts - WHY, Requirements WHAT - Functional and Non-Functional, Design - HOW, Programming, Test, Maintenance
        - Parnas Partitioning - identify all difficult design decisions e.g. things likely to change, design modules to hide these things from the rest of the system
    - Agile - Cyclical, Focus on Code Delivery
    - Standards
        - DOD-STD-2167A
            - System Requirements Analysis and Design
            - Software Requirements Analysis
            - Preliminary Design
            - Detailed Design
            - Coding and Computer Software Unit Testing
            - Computer Software Component Integration and Testing
            - Computer Sofftware Component Integration Item Testing
            - System Integration and Testing
        - ISO 9000-3
        - IEEE 830

Lecture 5
    - Real Time Specification and Design Techniques
        - Natural Languages
            - Pro - easy
            - Con - ambiguous, tedious
        - Mathematics
            - Pro - precise/unambiguous
            - Con - cryptic and difficult to understand, hard to use, 
        - Flowcharts
            - Pro - well understaood, okay for simple/small systems
            - Con - difficult showing interaction between simultaneous tasks, encourages GOTO
        - Structure Charts
            - Pro - widely used, Top-down design, sub-processes
            - Con - no conditional bnranching or concurrent process interaction
        - Pseudocode and PDLs
            - PDL - compiler
            - Pro - close to programming language, models concurrency, formal methods apply
            - Con - Learn language, error prone
        - Finite State Automata
            - Moore - outputs are a function of the current state only
            - Mealy - outputs are  afunctiuon of the current state and the inputs
            - Pro - widely used, easy, structured, can optimize
            - Con - cant see inside of states, difficult for concurrent processes
        - Dataflow Diagrams
            - Pro - widely used, shows concurrency, partitioning
            - Cons - must be used with other methods for Rt, difficult to show signaling/sync between processes
        - Petri Nets
            - Pro - mathematical, visual, concurrency/interprocess
            - Con - overkill for simple systems, timing can be obscure
        - Warnier-Orr Notation
            - Pro - branching, model data structures
            - Cons - diagrams can get very large and complex, sync of concurrent processes using only conditionals is restrictive, not well known
        - State Charts
            - Pro - structure of FSM, depth, concurrent processes, inter-process communication
            - Con - ????

Lecture 6
    - Real Time Kernels
        - Introduction
            - Specialized OS for size and speed
            - 3 Functions - Task Scheduling, Task Dispatching, Inter-Task Communication
        - Role of Kernel
            - Human Interface, Basic I/O, Extended I/O, User Applicaitons
        - Kernel Types
            - Nano-Kernel - dispatching, thread/task control and block management
            - Micro-Kernel - Task Scheduling 
            - Kernel - interprocessor communication and synchronization
            - Executive - Kernel + I/O Services - file and disk suppport
            - OS - Exectuve plus user I/F, security, file mgmt, etc. - user interface and shell
        - Implementation
            - Polled Loop
                - Simplest, infinite loop checking flags till an event occurs
                - Handle one event or several non overlapping events
                - +Interrupt - fixed clock interrupt to occur n times and process event
            - Phase/State-Driven
                - Facilitates basic multi-tasking system
                - Each task is divided into segments
                - Each segment executes without interruption
                - When a segment finishes executing, the task changes to the next state
                - Task can be suspended
            - Coroutines
                - Implementaiton of state-driven code into a multi-tasking system
                - Any single task can be state driven
                - Two or more tasks, executing simulataneously where each task is state driven
                - Dispatcher initiates Task 0 -> Task 0 Execute -> Save Context -> Dispatcher inits Task 1
            - Interrupt Driven
                - Interrupt Service Routine ISR
                - Fixed Rate -> Fixed Rate
                - Variable Rate -> Sporadic
                - Mixed-> Hybrid
                - Scheduling done via interrupt priorities
                - Switching context is an important cost - save PC, registers, status, flags
                - Task Control Block - context of a task
                    - PC, Register Contents, Processor Status, Task IDs, LINKED LIST
                    - States - Executing, Ready, Suspended, Dormant
                - Stack Model - use stack to store context, simpler and faster
                - Patterns
                    - Round-Robin - interrupt occurs at a fixed rate, task suspended, context saved, context loaded, task executes
                    - Preemptive Priority - a higher priority task can interrupt and prempt a lower priority task
                - Rate Monotonic Systems
                    - Special case of preemptive where priority is based on frequency of execution
                    - Problem - priority inversion - lower priority task may need to be executed frequently and may ned up holding a resource a high priority one needs
                 - Problem - time wasted in the loop, no useful work done with no interrupts
            - Foreground-Background
                - Solution to interupt, call main process in background and put slow, low priority useful tasks in it
                - Interrupt now called foreground
                - How to Acquire Data
                    - Read all parameters every 1ms - bad
                    - Read parameters at 3 rates
                        - Initiate each task by an interrupt that is synchronous to the 1ms, 10ms, or 100ms update rates
                        - Preemptive priority using rate monotonic i.e. 1ms has highest priority
                - Background
                    - Initialize ISRs, service the network, modify acquisition table
            - Full Features RTOS
                - Come w/ network interfaces, device drivers, debugging tools, etc.
                - Con - commercial RTOS is larger and usually slower/more generic