Operating Systems CIS 450

1. 08/31/2022 - Introduction
    - System Basics
        - Hardware - CPU attached to main memory
            - Buses connect components e.g. CPU, memory, graphics, peripheral devices
            - Questions
              - How close should each component be?
              - How do we deal with limited space?
        - Software
            - Questions
                - What happens when a program runs?
                    - It executes instructions, many millions/billions of times every second. The CPU
                        - fetches an instruction from memory
                        - decodes it i.e. figures out which instruction
                        - executes it i.e. does the thing
                        - moves to next instruction F-D-E
                - What else happens in the background when a user program runs?
                    - Body of software, OS Kernel, runs all the time to
                        - make it easy to run programs
                        - allow programs to share memory
                        - enabling programs to interact with devices
        - Basics of Von Nuemann Model of Computing
    - What is an OS?
        - Language, Command Interpreter, Library of Commands, Set of Utilities - NO
        - Definitions
            - Bottom-Up Perspective - Resource Manager
                - Resources - CPU, Memory, Disks, I/O, Timer, Battery, Touch Screens
                - Layers - User -> Application -> Operating System -> Hardware
                - Collection of software that manages computer hardware, intermediary
                - Benefits
                    - Sharing/multiplxing - more that 1 app/user to use resource
                    - Protection of apps from each other
                    - Performance - efficient/fair access to resources
                - Challenges
                    - Managing all kinds of resources
            - Top-Down Perspective - Hardware Abstraction Layer
                - OS as a virtual machine providing a standard library
                - Applications issue system calls to use OS abstractions
                - Benefits
                    - Ease of use
                    - Reusability - provide common functionality
                    - Portablity
                - Challenges
                    - What are the right abstractions?
        - Example - Android
            - Upward Compatability - app developers can write a single app that works across over a billion devices

2. 08/31/2022 - Three Important Pieces
    - Review of OS C Programming Examples from OSTEP
    - Illusion
        - The system has a very large number of virtual CPUs
        - Each running program has allocated memory at the same address, each program acts as it has its own private memory
    - Virtualization
        - Idea - take a physical resource and transform it into a more general, powerful, and easy to use virtual form of itself
        - Virtualization of the CPU - Central Processing Unit
            ./cpu A & ./cpu B &
        - Virtualization of the Memory
            - ./mem 100 & ./mem 1000 & - the memory address location is the same, this is the illusion demonstrated
    - Concurrency
        - Threads
            - ./thread 100 - produces expected value
            - ./thread 100000 - doesn't produce expected value... why?
            - Issue
                - This relates to how instructions are executed
                - A key part of the porogram, where the shared counter is incremented, takes three instructions
                    - Load the value
                    - Increment the value
                    - Store back to memeory
                - These DO NOT execute atomically all at once, and the results become indeterminate
        - Idea - How to manage multiple things at once
    - Persistence
        - Goal - store data for a long period of time
        - Hardware and Software Support
            - Hardware I/O Device
            - Software - File System
        - Unique - OS does not create a private, virtualized disk, instead we create a virtual to physical mapping

3. 09/07/2022
    - Virtualization
        - OS - takes a physical resource (CPU or memory) and transforms it into a more general, powereful,m and easy to use resource
        - Abstraction - Process
            - One of the most fundamental abstractions - basic unit of resource virtualization from the perspective of an application
        - Process - CPU acitivities and memory usage
            - What is a process?
                - Informal - a running program, exeuction stream: stream of instructions
            - Examples
                - Web browser, execute compiled program, shell
            - Process vs. Program
                - Program - lifeless thing, code, instructions
                - OS takes program and runs them
                - Program - passive
                - Process - active
                - Different processes may be associated with the same program
            -  Linux/Unix Commands
                - ps - list running processes - excluding some background
                - top - tabular view of running processes
        - Abstraction - A Process
            - What constitutes a process?
                - Machine state of a process
                    - What a program can read or update when it is running
                    - Take inventory of the different pieces of the system it accesses or affects during the coures of its exeuction
            - Machine State
                - Memory - address space
                - Program Code - instructions
                - Stack - local variables
                - Heap - dynamically alocated memory
                - Data - global variables
                - Design - stack can grow, heap can grow, split to increase the size of each, naturally boundary has to exist for a process
                - Registers
                    - Program Counter - indicating the instruction of the program that is currently being executed
                    - Stack Pointer and Frame Pointer - managing the stack for function parameters, local variables, and return addresses
                - I/O Information - a list of open files the process currently has open
            - Process States
                - Initial
                - Ready - ready to run
                - Running - executing instructions
                - Blocked/Waiting/Sleeping - not ready to run until some other events takes place
                - Zombie
                - Running depends on number of CPUs
            - CPU Bound and I/O Bound
                - CPU Bound - Majority time on CPU
                - I/O Bound - Majority time on I/O
            - Data Structures
                - Process List - list of processes
                - Process Control Block - struct object representing each process
                    - Identifier, state, cpu registers
                    - Scheduling, memory management, accounting, and I/O information
            - Xv6 Proc Data Structure
                - proc.h and proc.ch
                    - UNUSED - initial state
                - ptable is the process list inside of proc.c

4. 09/08/2022
    - Process APIs
        - Pattern
            - Code -> Store on Disk -> Load into Memory -> 
        - Important Process APIS - man fork, wait, exec
            - fork() - child begins execution of code immediately at line after fork(), entire parent code is duplicated and givne to child
                    - if rc negative, something went wrong
                    - if rc = 0, child process was created and has control
                    - else, parent logic
                - Each process has its own memory allocation
                - Processes become concurrent running processes, non-deterministic who runs first
                - QUIZ - if fork() n times, how many processes? 2^n
                - Practical
                    - Parent makes a duplicate copy of its memory, including code segment, into antoher memory location for the child process
                    - Child has same code, but in a different location
                    - Child wont change code until exec() is called
                - fork() in xv6
                    - When the shell sh forks a new spin process, the new process name remains as sh until exec() is called
            - wait() - instruction to parent to wait until child process execution has finished
                - delays parent exeuction until ONE of its children finishes executing
                - waitpid(pid_t pid) - wait for specific child
                - Zombie state in xv6
                    - When child process is completed, state is changed to zombie state
                    - When the parent process sees the child process change to zombie state, it stops waiting
            - exec()
                - variants - execl(), execle(), execlp(), execv(), execvp(), execvP()
                - int execvp(const char *path, char *const argv[])
                    - path identifies the location of the new process image within the hierarchical file system
                    - argv is a pointer to an array of pointers to null-terminated character strings
            - Separation of fork() and exec()
                - Why? without separation, we dont have flexibility in the shell
                - Shell Pattern
                    - figures out where executable is
                    - calls fork() to create a new child processs
                    - calls some variant of exec() to run the command
                    - waits for the command to completed by calling wait()
                    - returns from wait() and prints out a prompt again, ready for your next command
                - The Trick - right after fork() and before exec(), the shell can run code that can alter the environment of the about to be run program, and enables a variety of interesting features
            - Unix Shell - list, redirection, and pipes
        - Create
        - Destroy
        - Wait
        - Status
    
5. 09/09/2022 - Session One
    - Virtualization - CPU Mechanisms
        - Time Sharing - share a resource in different time
        - Space Sharing - share a resource in different parts
        - Challenges
            - Performance - how can we implement virtualization without adding execssiv overhead
            - Control - how can we run processes while retaining control over the CPU
        - Separation of Mechanism/Policy in System Design
            - Mechanism - low level machinery - part that controls the authorization of operations and the allocation of resources
            - Policy - high level intelligence - where decisions are made about which operations to authorize and which resources to allocate
            - Separation Achieves
                - modularity - allows one easily to change policies without having to rethink the mechanism
        - Low Level Machinery - Mechanism
            - How does a program run on CPU?
            - How does the OS stop running progam and start running another?
        - Simple Mechanism
            - Direct Execution - just run program on CPU
                - OS 
                    - Create entry for process list
                    - Allocate memory for program
                    - Load program into memory
                    - Set up stack with argc/argv
                    - Clear registers
                    - Execute call main()
                - Program
                    - Run main()
                    - Return 
                - OS
                    - Free memory of process
                    - Remove from process list
            - Direct Execution Benefits
                - Process runs natively on hardware
            - DE Problems
                - How can the OS make sure the process doesn't do anything that we don't want it to do?
                - How does the OS Stop it from running and switch to another process for time sharing?
            - Problem #1 - direct execution prevenets the construction of many kinds of desirable systems
            - Problem #1 Solution - Restricting Operations
                - Dual Processor Modes - User and Kernel
                    - User Mode - application runs with restrictions, no I/O, exceptions are raised
                    - Kernel Mode - kernel runs with privilege
                - System Call - user application makes call to get access to protected reources or privileged operations
                    - Limited direct execution with restriction
                    - Most modern OSes exposes a few hundred such operations
                    - Examples - See Slide 
                - How does a system call work?
                    - A process executes a special trap instruction, jumps into the kernel, and raises kernel mode
                    - Kernel performs privileged operations
                    - Kernel calls a special return from trap instruction, returns into the calling user program, and reduces to user mode
                - Three Potential Sources for Interrupt
                    - Hardware
                    - Processor
                    - Software
                - Harware Support
                    - Special instructions
                        - to trap into the kernel
                        - return from trap
                    - Assist the OS to provide user and kernel mode
                    - Careful when executing a trap, save enough of caller's register state to return correctly
                    - x86
                - Trap Hanlder
                    - How does the trap know which code to run?
                        - OS must carefully control what code executes upoon trap
                    - OS sets up a trap table or interrupt descriptor table at boot time
                    - OS informs the hardware of the locations of different trap handlers
                - System Call Number - number assigned to each system call
                    - User code is responsible for placing the desired system call number in a register or at a specified location
                    - OS examines number, ensures it is valid, and if it is, executes the corresponding code
                    - Indirection serves as a form of protestion, user code cannot specifiy an exact address to jump to
                - xv6 - see slides for example
        
5. 09/09/2022 - Session Two
    - Virtualization - CPU Mechanisms
        - Switching Between Processes
            - Problem
                - If a process is running the CPU, it means the OS is not running
                - How can the OS regain control of the CPU so that it can switch between processes
            - Cooperative Approach - wait for system calls
                - OS trusts the process of the system to behave reasonably
                - OS regains control of the CPU by waiting for a system call or an illegal operation
            - Non-Cooperative - OS takes control
                - Timer Interrupt - a timer device can be programmed to raise an interrupt every so many milliseconds
                - When the interrupt is raised, the running process is halted, and a preconfigured interrupt handler in the OS runs
            - Saving and Restoring the CPU Context
                - Decision - continue process or switch to a new one, made by high level policy the scheduler
                - Save general purpose registers, PC, and kernel stack pointer
                - Restore regsiter, PC, and switch to kernel stack
            - xv6 Context Switch
                - Save P1's user mode context and switch to kernel mode
                - Handle system call or interrupt
                - Save P1s kernel context and switch to scheduler context
                - Select another process P2
                - Switch to P2's address space
                - Save Scheduler CPU context and switch to P2's kernel context
                - Switch from kernel to user mode and load P2's user mode context
            - xv6 - Timer Interrupt Workflow
                - Scheduler - two infinite loops
        
                
6. 09/15/2022 - Policies #1
    - Focus - which process should the OS run?
    - CPU Scheduling - motivation for multiprogramming
        - Typical Execution Profile
            - Start -> CPU Burst -> I/O -> REPEAT
        - CPU scheduler is managing the execution of CPU bursts
        - Histogram of CPU Burst Times
            - Most CPU bursts is quite small < 2ms
        - Scheduling Structure
            - Ready queue of running processes
            - Scheduler chooses which to pick
    - Workload Assumptions
        - Job - processes
        - Each job has - arrival time, cpu burst time or running time, completion time
    - Scheduling Metrics
        - User
            - Turnaround time - time between submission and completion
            - Waiting time - sum of periods waiting in ready queue
            - REsponse time - time from submission and first response, first waiting time
        - System
            - CPU Utilization - percentage of time CPU is executing
            - Throughput - number of jobs completed per time unit
        - Good Scheduler
            - maximize COU utilization anbd throughpout
            - minimze turnaround time, response time, and waiting time
    - First Come First Served - First In First Out (FCFS or FIFO)
        - Order of arrival in queue determines execution order
        - Waiting Time
            - P1 = 0 runs for 7
            - P2 = 2-7 so 5, runs for 4
            - P3 = 4 - 11 so 7, runs for 1
            - P4 = 5 - 12 so 7, runs for 4
            - 0 + 5 + 7 + 7 / 4 = 19 / 4 = 4.75
        - Features
            - Pros - simple and fair
            - Cons - long waiting times, poor dynamic behavior e.g. convoy effect
            - Convoy Effect
                - Happens when a set of processes need to use a resource for a short time, and one process holds the resource for a long time, blocking the other proceses
                - Cases long waiting times and poor utilization of other resources in the system

7. 09/15/2022 - Policies #1 - Shortest Job First (SJF)
    - Shortest Job First
        - Focus - reducing turnaround time
        - Action - whenever CPU is idle, pick process with shortest next CPU burst, non-preemptive, must wait for jobs to complete
        - Issue - how do we know how long a job will run?
        - Example
            - Break Tie - FCFS - P1, P3, P2, P4
            - Review example on slides!
        - Features
            - Pro - minimize average waiting time, optimal
            - Cons - starvation for long jobs and it is hard to determine length of next CPU burst
        - How to prove SJF is the best for minimizing average waiting time?
            - Induction
                - Moving a short proecss before a long one decreases the waiting time of the short process more than it increases the waiting time of the long process
            - Proof
                - Plong -> PShort
                - Swap Jobs, Delta W < 0, subtracting P1 length minus P short length to determine delta
                - Review Slides!, Swapping technique to reduce waiting time
        - SJF in Practice
            - How do you determine execution time of next CPU burst?
                - Guess? Inspection?
            - Forecasting Exponential Average
    - Shortest Remaining Time First (SRTF)
        - Optimal among all preemptive scheduling policies in terms of minimizing waiting time, overlook overhead
        - Can lead to starvation, and is not practically
        - Review slides!
    - Quiz - FCFS, SJF, SRTF
        - REVIEW
    - Priority Scheduling - Non-Preemptive, Preemptive
        - Pick the process with the highest priority
            - Priority - class, urgency
            - Preemptive or Non-Preemptive
        - SJF and SRTF is special priority scheduling
        - Problem - starvation of low priority
        - Aging - gradually increase the priority over time
        - Example - smallest number is highest priority
    - Round Robin
        - Circular Queue - with pointer to next job
        - During each turn, run for time quantum
        - After turn, move pointer to next job in a circular manner
        - Work Conserving - relinquish quantum of time if larger than remaining time on process
        - Pros - time sharing and response time
        - Cons - long average waiting time, large context switch overhead
        - Choice of Quantum
            - Large
            - Small - processor sharing illusion
            - Larger quantum, more cpu utilization
            - Rule of thumb - 80% of cpu bursts should be shorter than the time quantum
    - Quiz
        
        