Title: Game Engine Architecture
Authors: Jason Gregory

Summarization of Content

Chapter 1 - Introduction
    a. Structure of a Typical Game Team
        - Engineers - design and implement the software that makes the game and tools work
        - Artists - produce the artistic content
            - Concept, 3D Modelers, Texture, Lighting, Animations, Motion Capture Actors, Sound Designers, Voice Actors
        - Game Designers - design interactive portion of the player's experience i.e. gameplay
        - Producers - manage schedules, serve in design capacity, liasion between development and business teams
        - Marketing, IT, Leadership, Administrative, and Janitorial
    b. What is A Game?
        - Soft Real-Time Interactive Agent-Based Computer Simulations
    c. What is A Game Engine?
        - Software system made up of various components that enable the development of games
    d. Game Genres
        - FPS, MMO, RPG, Racing, Fighting, Platformers, Strategy, Player Authored Content, Virtual, Augmented, and Mixed Reality, Sports, Puzzles
    e. Examples of Game Engines
        - Quake Family for FPS
        - Unreal Engine
        - Half-Life Source Engine
        - Dice's Frostbite
        - Rockstar Advanced Game Engine
        - CRYENGINE
        - Microsoft's XNA Game Studio
        - Unity
        - Open Source: Panda3D, Yake, Torque, Crystal Space
    f. Runtime Engine Architecture
        - Target Hardware - Microsoft Windows, Linux, PS4, Xbox One X
        - Device Drivers - manage hardware resources and shield the operating system and upper engine layers from hardware device details
        - Operating System - orchestrates the executions of programs on a computer
        - Third Party SDKs and Middleware
            - Data Structures and Algorithms: Boost, Folly, Loki
            - C++ Standard Library and STL
            - Graphics - Glide, OpenGL, DirectX, Edge, Vulkan
            - Collision and Physics - Havok, PhysX, Open Dynamics Engine
            - Character Animation - Granny, Havok Animation, OrbisAnim
            - Biomechanical Character Models - Endorphin and Euphoria
        - Platform Independence Layer - shields the engine from knowledge of the underling platform
        - Core Systems - Assertions, Memory Management, Unit Testing, Math Library, Debugging, Movie Player, Engine Config, Curves and Surface Library
        - Resource Manager - interface for accessing any and all types of game assets and other engine input data
        - Rendering Engine
            - Low Level Renderer - render geometric primtives as quickly as possible
            - Graphics Device Interface - initalize graphic devices and set up render surfaces
            - Others - Materials and Shaders, Statis and Dynamic Lighting, Cameras, Text and Fonts, Primitive Submission, Viewports and Virtual Screen, Textures and Surface Mgmt.
            - Scene Graph/Culling Optimizations - limit the number of primitives subimtted for rendering
                - Options: Frustrum Cull, Spatial Subdivision/Scene Graph
            - Visual Effects - particles, decals, light and environment mapping, dynaimc shadows, full screen post effects (high dynamic range, full screen anti-aliasing, bloom)
            - Front-End - heads up display, menus, console, and other development tools, graphical user interface, full motion video, in-game cinematics
        - Profiling and Debugging Tools - profiling the performance of your game (timing, statistics, memory usage, debugging logs)
        - Collision and Physics - dynamics simulation
        - Animation
            - Sprite, Rigid Body Hierarchy, Skeletal Animation, Vertex Animation, Morph Targets
        - Human Interface Devices - devices through with which users interact with or control the game
            - Keyboard, joybad, mouse, controllers
        - Audio
        - Online Multiplayer/Networking
        - Aritificial Intelligence
        - Gameplay Foundation Systems
            - Game Objects and Object Models
            - Event System
            - Scripting System
            - Game Specific Subsystems
    g. Tools and the Asset Pipeline
        - Digital Content Creation Tools
            - Maya, Autodesk, Blender, Adobe Photoshop
        - Asset Conditioning Pipeline - converting from DCC format to optimized format for game
            - 3D Model/Mesh Data - complex shapes composed of triangles and vertices
            - Brush Geometry - collection of convex hulls defined by multiple planes
            - Skeletal Animation Data - mesh, skeletal hierarchy, and animatiomn clips
            - Audio Data
            - Particle Systems Data
        - World Editor
        - Resource Database
        - Web Based User Interfaces

Chapter 2 - Tools of the Trade
    a. Version Control - permits multiple users to work on a group of files collectively
        - Benefits
            - Central repository to share code
            - Keeps history of changes to all files
            - Mechanism to tag and retrieve versions of files
            - Enables branching for feature development and testing
        - Common Version Control Systems
            - Source Code Control System and Revision Control System, Concurrent Version System, Subversion, Git, Perforce, NxN Alienbrain, ClearCase
        - Important Features
            - Updating And Committing, Check-Out, Branching, and Merging
    b. Compilers, Linkers, and IDEs
        - Source Files/Translation Units - source code
        - Header File - share information such as type declarations and function prototypes between translation units
        - Libraries, Executables, and Dynamic Link Libraries
            - Libraries - groups of object files
            - Executable - linked libraries and object files
            - Dynamic Link Library - acts like a hybrid between a regular static library and an exceutable
        - Projects and Solutions
            - Project - collection of source files which, when compiled, produce a lirbary, an executable, or a DLL
            - Solution File - manages collections of projects
        - Build Configuration
            - Build Options - preprocessor, compiler and linker settings
        - Local and Global Optimizers
            - Algebraic simplification, code inlining, constant folding, constant propogation, loop unrolling, dead code elimination, and instruction reordering
        - Typical Build Configurations - Debug, Development, and Ship
        - Techniques - Setting breakpoints, stepping through, using watch windows
        - Important Skills
            - Reading and stepping through disassembly in the debugger
            - Use registers to deduce variables' values and addresses
            - Inspect variables and objects content by address
            - Leverage static and global variables
            - Modify the code
    c. Profiling Tools - measures execution time of code
        - Types - statistical profilers and instrumenting profiles
    d. Memory Leak and Corruption Detection
        - Memory Leak - memory is allocated but never freed
        - Memory Corruption - program inadvertently writes data to the wrong memory location, overwriting important data while failing to update where data should have been
    e. Other Tools - Diff Tool, Three-Way Merge, Hex Editors

Chapter 3 - Fundamentals of Software Engineering for Games
Chapter 4 - Parallelism and Concurrent Programming
Chapter 5 - 3D Math for Games
Chapter 6 - Engine Support Systems
Chapter 7 - Resources and the File System
Chapter 8 - The Game Loop and Real-Time Simulation
Chapter 9 - Human Interface Devices
Chapter 10 - Tools for Debugging and Development
Chapter 11 - The Rendering Engine
Chapter 12 - Animation Systems
Chapter 13 - Collision and Rigid Body Dynamics
Chapter 14 - Audio
Chapter 15 - Introduction to Gameplay Systems
Chapter 16 - Runtime Gameplay Foundation Systems