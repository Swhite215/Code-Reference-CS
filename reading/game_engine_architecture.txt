Title: Game Engine Architecture
Authors: Jason Gregory

Summarization of Content

Chapter 1 - Introduction
    a. Structure of a Typical Game Team
        - Engineers - design and implement the software that makes the game and tools work
        - Artists - produce the artistic content
            - Concept, 3D Modelers, Texture, Lighting, Animations, Motion Capture Actors, Sound Designers, Voice Actors
        - Game Designers - design interactive portion of the player's experience i.e. gameplay
        - Producers - manage schedules, serve in design capacity, liasion between development and business teams
        - Marketing, IT, Leadership, Administrative, and Janitorial
    b. What is A Game?
        - Soft Real-Time Interactive Agent-Based Computer Simulations
    c. What is A Game Engine?
        - Software system made up of various components that enable the development of games
    d. Game Genres
        - FPS, MMO, RPG, Racing, Fighting, Platformers, Strategy, Player Authored Content, Virtual, Augmented, and Mixed Reality, Sports, Puzzles
    e. Examples of Game Engines
        - Quake Family for FPS
        - Unreal Engine
        - Half-Life Source Engine
        - Dice's Frostbite
        - Rockstar Advanced Game Engine
        - CRYENGINE
        - Microsoft's XNA Game Studio
        - Unity
        - Open Source: Panda3D, Yake, Torque, Crystal Space
    f. Runtime Engine Architecture
        - Target Hardware - Microsoft Windows, Linux, PS4, Xbox One X
        - Device Drivers - manage hardware resources and shield the operating system and upper engine layers from hardware device details
        - Operating System - orchestrates the executions of programs on a computer
        - Third Party SDKs and Middleware
            - Data Structures and Algorithms: Boost, Folly, Loki
            - C++ Standard Library and STL
            - Graphics - Glide, OpenGL, DirectX, Edge, Vulkan
            - Collision and Physics - Havok, PhysX, Open Dynamics Engine
            - Character Animation - Granny, Havok Animation, OrbisAnim
            - Biomechanical Character Models - Endorphin and Euphoria
        - Platform Independence Layer - shields the engine from knowledge of the underling platform
        - Core Systems - Assertions, Memory Management, Unit Testing, Math Library, Debugging, Movie Player, Engine Config, Curves and Surface Library
        - Resource Manager - interface for accessing any and all types of game assets and other engine input data
        - Rendering Engine
            - Low Level Renderer - render geometric primtives as quickly as possible
            - Graphics Device Interface - initalize graphic devices and set up render surfaces
            - Others - Materials and Shaders, Statis and Dynamic Lighting, Cameras, Text and Fonts, Primitive Submission, Viewports and Virtual Screen, Textures and Surface Mgmt.
            - Scene Graph/Culling Optimizations - limit the number of primitives subimtted for rendering
                - Options: Frustrum Cull, Spatial Subdivision/Scene Graph
            - Visual Effects - particles, decals, light and environment mapping, dynaimc shadows, full screen post effects (high dynamic range, full screen anti-aliasing, bloom)
            - Front-End - heads up display, menus, console, and other development tools, graphical user interface, full motion video, in-game cinematics
        - Profiling and Debugging Tools - profiling the performance of your game (timing, statistics, memory usage, debugging logs)
        - Collision and Physics - dynamics simulation
        - Animation
            - Sprite, Rigid Body Hierarchy, Skeletal Animation, Vertex Animation, Morph Targets
        - Human Interface Devices - devices through with which users interact with or control the game
            - Keyboard, joybad, mouse, controllers
        - Audio
        - Online Multiplayer/Networking
        - Aritificial Intelligence
        - Gameplay Foundation Systems
            - Game Objects and Object Models
            - Event System
            - Scripting System
            - Game Specific Subsystems
    g. Tools and the Asset Pipeline
        - Digital Content Creation Tools
            - Maya, Autodesk, Blender, Adobe Photoshop
        - Asset Conditioning Pipeline - converting from DCC format to optimized format for game
            - 3D Model/Mesh Data - complex shapes composed of triangles and vertices
            - Brush Geometry - collection of convex hulls defined by multiple planes
            - Skeletal Animation Data - mesh, skeletal hierarchy, and animatiomn clips
            - Audio Data
            - Particle Systems Data
        - World Editor
        - Resource Database
        - Web Based User Interfaces

Chapter 2 - Tools of the Trade
    a. Version Control - permits multiple users to work on a group of files collectively
        - Benefits
            - Central repository to share code
            - Keeps history of changes to all files
            - Mechanism to tag and retrieve versions of files
            - Enables branching for feature development and testing
        - Common Version Control Systems
            - Source Code Control System and Revision Control System, Concurrent Version System, Subversion, Git, Perforce, NxN Alienbrain, ClearCase
        - Important Features
            - Updating And Committing, Check-Out, Branching, and Merging
    b. Compilers, Linkers, and IDEs
        - Source Files/Translation Units - source code
        - Header File - share information such as type declarations and function prototypes between translation units
        - Libraries, Executables, and Dynamic Link Libraries
            - Libraries - groups of object files
            - Executable - linked libraries and object files
            - Dynamic Link Library - acts like a hybrid between a regular static library and an exceutable
        - Projects and Solutions
            - Project - collection of source files which, when compiled, produce a lirbary, an executable, or a DLL
            - Solution File - manages collections of projects
        - Build Configuration
            - Build Options - preprocessor, compiler and linker settings
        - Local and Global Optimizers
            - Algebraic simplification, code inlining, constant folding, constant propogation, loop unrolling, dead code elimination, and instruction reordering
        - Typical Build Configurations - Debug, Development, and Ship
        - Techniques - Setting breakpoints, stepping through, using watch windows
        - Important Skills
            - Reading and stepping through disassembly in the debugger
            - Use registers to deduce variables' values and addresses
            - Inspect variables and objects content by address
            - Leverage static and global variables
            - Modify the code
    c. Profiling Tools - measures execution time of code
        - Types - statistical profilers and instrumenting profiles
    d. Memory Leak and Corruption Detection
        - Memory Leak - memory is allocated but never freed
        - Memory Corruption - program inadvertently writes data to the wrong memory location, overwriting important data while failing to update where data should have been
    e. Other Tools - Diff Tool, Three-Way Merge, Hex Editors

Chapter 3 - Fundamentals of Software Engineering for Games
    a. C++ Review and Best Practices
        - Object Oriented Programming
            - Classes and Objects
                - Class - collection of attributes (data) and behaviors (code)
                - Object - instance of a class
            - Inheritance - new classes defined as extensions to preexisting classes
            - Multiple Inheritance - class can have more than one parent class
            - Polymorphism - allows a collection of objects of different types to be manipulated through a single common interface
            - Composition and Aggregation
                - Composition - practice of using a group of interfacing objects to accomplish a high-level task (has-a)
                - Aggregation - (uses-a)
            - Design Patterns
                - Creational, Structural, and Behavioral
            - Janitors and RAII
                - Janitor - construct a local instance ofthe class to acquire the resource, and let it fall out of scope to release it automatically
                - RAII - resource acquisition is initialization pattern
        - C++ Language Standardization
            - C++98, C++03, C++11, C++14, C++17
            - Coding Standards
                - Interface are king
                - Good namds encourage understanding and avoid confusion
                - Don't clutter the global namespace
                - Follow C++ Best Practices
                - Make errors stick out
    b. Catching and Handling Errors
        - Types of Errors:  User and Programmer
        - Handling Errors
            - Handling Player Errors - cue, provide information, gentle redirection
            - Handling Developer Errors
                - Make the error obvious
            - Handling Programmer Errors
                - Assertion system - erro-checking code and arragned for failed error checks to halt the program
            - Implementation fo Error Detection and Handling
                - Error Return Codes
                - Exception Handling
                - Assertions - line of code that checks an expression
                 Compile-Time Assertions
    c. Data, Code, and Memory Layout
        - Numeric Representation
        - Numeric Bases 
            - Base Ten - 7803 = 7*1000 + 8*100 + 0*10 + 3*1
            - Hexadecimal - 0-9 and A-F (10-15)
            - Signed and Unsigned Integers
                - 32-bit unsigned 0x00000000 to 0xFFFFFFFF
                - 32-bit signed - positive = 0x00000000 to 0x7FFFFFFF and negative = 0x80000000 to 0xFFFFFFFF
            - Fixed Point Notation
            - Floating Point Notation
            - Precision and Magnitude - precision increases as magnitude decreases e.g. 10.0000000000 vs 100000000.12
            - Subnormal Values - Gap between 0 vs. 1.175x10^-38
        - Primitive Data Types
            - char ,int, short, long, float, double, bool
            - Custom - F32, U8, U16, I16, U32, U64, I64 and Signed Set
        - Endianess
            - Little-endian - stores least significant byte of a multibyte value at a lower memory address than the most significant byte
            - Big-endian - stores the most significant byte of a multibyte value at a lower memory address thatn the least significant byte
        - Kilobytes vs. Kibibyte
            - Kilobyte - 1000, Kibibyte - 1024
            - Mebibyte - Kibibyte Squared
            - Gibibyte - Kibibyte Cubed
            - Tebibyte - Kibibyte Quadrupled
            - Pebibyte - Kibibyte Quintupled
            - Exbibyte - Kibibyte Sextupled
            - Zebibyte - Kibibyte Septupled
            - Yobibyte - Kibibyte Octupled
        - Declaration, Definitions, and Linkage
            - Declaration vs. Defintion
                - Declaration - decsription og data object or function
                - Definition - describes a unique region of memory in the program
            - Linkage
                - External Linkage - definition is visible to and can be referenced by translation units other than the one in which it appears
                - Internal Linkage - definition can only be seen inside the translationu unit in which it appears
        - Mmeory Layout of a C/C++ Program
            - Executable Image (Executable and Linking Format) e.g. elf or .exe
                - Divided into contiguous blocks called segments or sections
                    - Text, Data, BSS (Block Started by Symbol),  Read-only Data Segment
            - Program Stack
                - Contiguos areas of memory are psuhed and popped off the program stack
                - Stack Frame - return address, CPU registers, local variables
            - Dynamic Allocation Heap - block of memory for each running process from which memory can be allocated and freed
            - Member Variables
                - Class-Static Members - restrict visibility of variable or function to only visibble within this .cpp file
            - Object Layout in Memory
                - Box for Class, Horizontal Lines Separating Data Members
                - Alignment and Packing
                    - Every data type has a natural alignment, which must be respected in order to permit the CPU to read and write more effectively
                    - Packing - aligning properly to ensure best memory usage and reduce holes
   d. Computer Hardware Fundamentals
        - Anatomy of a Computer
            - CPU - Central Processing Unit
                -  ALU, FLU, VPU, MC, Registers, Control Unit
            - ALU - Arithmetic Logical Unit, performs unary and binary arithmetic operations
            - FPU - Floating Point Unit, performs floating-point calculation
            - VPU - Vector Processing Unit, integer and floating-point arithmetic
            - MMU - Memory Management Unit
            - Registers - high-speed memory cells, typically located on chipa and in-close proximity to the components that access them
                - Instruction Pointer - contains address of the currently executing instruction in a amchine language program
                - Stack Pointer - address of the top of the program's call stack
                - Base Pointer - based address of the current function's stack frame on the call stack
                - Status Register/Condition Code Register/Flags Register - contains bits that reflect the result of the most-recent ALU operation
            - Register Formats
                - 32-bits, 64-bits, 80-bits
            - Control Unit - manages the flow of data within a cpu
            - Clock - periodic square wave signal, rising and falling edge of this signal is known as a clock cycle
            - Processing Power - MIPS (Milliosn of Instructions Per Second) or FLOPS (Floating Operations Per Second)
            - Memory - Read-Only Memory (ROM, PROM, EEPROM) and Random Access Memory (RAM, DRAM, SRAM)
            - Buses - data is transferred between the CPU and memory over connections called buses
            - Bus Widths - bits size that controls the range of possible addresses that can be accessed by the CPU
            - Words - frequently a multibyte value, e.g. 16bits or two bytes, two word is 32 bits, four word is 64 bits
            - Machine and Assembly Langauge
                - Instruction Set Architecture - set of instructions supported by a given CPU
                    - Categories - move, arithmetic operations, bitwise operations, shift/rotate operators, comparison, jump and branch, push and pop, functional call and return, interrupts, other
                - Machine Language - instructions encoded numerically
                    - Opcode - which operation to perform e.g. add, subtract, move, jump, etc
                    - Operands - inputs and/or outputs of instruction
                    - Options - addressing mode and other flags
                - Assembly Language - text based verison of machine language
                - Addressing Modes
                    - Register Addressing - values can be transferred from one register to another
                    - Immediate Addressing - operands are target register and the immediate value to be loaded
                    - Direct Addressing - allows data to be moved to or from memory
                    - Register Indirect Addressing - targeted memory address is taken from a register, rather than being encoded as a literal value in the operands
                    - Relative Addressing  - target memory address is specified as an operand, and the value stored in a specific register is used as an offset from that target memory address
    e. Memory Architectures
        - Memory Mapping
            - Memory Mapped I/O  - CPU can perform I/O operations on a peripheral device by reading or writing addresses as if they were just ordinary RAM
            - Video RAM - range of memory addresses assigned for use by a video controller is known as video RAM
        - Virtual Memory
            - Virtual Memory System - memory addresses used by a program don't map direcvtly to the memory modules installed in the computer
            - Virtual Memory Pages - entire addressable memory is organized into equally-sized contiguous chunks known as pages
            - Virtual to Physical Address Translation - page index is looked up by CPUs MMU in  page table that maps virtual page indices to physical ones
            - Handling Page Faults -  access to pages that have been swapped out involves reading page from swap into RAM page and then translating virtual addresses to physical addresses 
            - Translation Lookaside Buffer TLB - caching mechanism for commonly used page table entries
        - Memory Architectures for Latency Reduction
            - Memory Access Latency - length of time between the moment the CPU requests data from the memory system and the moment the data is actually received by the CPU
            - Memory Gap - difference between CPU performance and the performance of memory
                - Techniques for reducing latency
                    - Place smaller, faster memory banks closer to the CPU core
                    - Hiding latency by arranging CPU to do other work while waiting for memory operation to complete
                    - Minimizing access to memory by arranging a program's data as efficiently as possible
            - Memory Cahce Hierachies - primary mechanicm for mitigating impacts of high memory access latencies (L1, L2, L3 Caches)
            - Cache Lines - contiguous blocks of data in caches to take advantage of spatial and temporal locality
            - Set Associativity and Replacement Policy
                - Direct-Mapped - map of one cache line to one main RAM address
                - Associative - two or more distinct cache lines mapped to one main RAM address (ways)
                - Replacement Policy - when a cache miss occurs, which way should be removed e.g. NMRU, LRU, FIFO, LFU
            - Multi-Level Caches - level 1 to level n caches to avoid cache misses
            - Instruction Cache - used to preload excutable machine code before it runs
            - Data Cache - used to speed up read and write operations performed by the machine code
            - Write Policy - how cache controller handles writes
                - Write-Through - all writes to the cache are mirroed to main RAM immediately
                - Write-Back - data is first written into the cache and the cache line is only flushed out to main RAM under certain circumstances
            - Cache Coherency - data in the caches belonging to multiple cores match one another and the contenst of main RAM
                - MESI - Modified, Exclusive, Shared, Invalid
                - MOESI - Modified, Owned, Exclusive, Shared, Invalid
                - MESIF - Modified, Exclusive, Shared, Invalid, Forward
            - Avoiding Cache Misses - organize data in contiguous blocks that are small as possible and access them sequentially
            - Nonuniform Memory Access NUMA and Uniform Memory Access UMA
                - UMA - computer contains a single large bank of main RAM which is visible to all CPU cores in the system
                - NUMA - each core is provided with a relatively small bank of high-speed dedicated RAM called a local store

Chapter 4 - Parallelism and Concurrent Programming
    a. Defining Concurrency and Parallelism
        - Concurrency - utilziing multiple flows of control to solve a problem
        - Parallelism - any situation in which two or more distinct hardware components are operating simulataneously
            - Implicit vs. Explicit Parallelism
                - Implicit (Instruction Level Parallelism) - use of parallel hardware components within a CPU for the purpose of improving the performance of a single instruction stream
                    - Examples: pipelining, superscalar architecture, very long instruction word
                - Explicit Parallelism - use of duplicated hardware components within a CPU, computer, or computer system, for the purpose of running more than one instruction stream simultaneously
                    - Examples: Hyperthreaded CPUs, mutlicore CPUs, multiprocessor computers, computer clusters, grid computing, cloud computing
        - Task vs Data Parallelism
            - Task Parallelism - multiple heterogenous operations are performed in parallel (animation calculations)
            - Data Parallelism - single operation is performed on multiple data items in parallel
        - Flynn's Taxonomy
            - Single Instruction Single Data - single instruction stream operating on a single data stream
            - Multiple Instruction Multiple Data - multiple instruction streams on multiple independent data streams
            - Single Instruction Multiple Data - a single instruction stream operating on multiple data streams
            - Multiple Instruction Single Data - multiple instructions streams all operating on a single data strea
            - Single vs. Multiple Data
                - Single data refers to a single pair of inputs
                - SISD - single ALU performs the multiple first, followed by the divide
                - MIMD - two ALUs perform operations in parallel, operating on two independent data streams
                - SIMD - wide ALU performs the multiple first, followed by the divide, but each instruction operates on a pair of four element input vectors
                - MISD - two ALUs process the same instruction stream, multiple first followed by divide, and ideally produce identical results
        - GPU Paralleism: SIMT
            - Single Instruction Multiple Thread - single instruction operating on multiple data streams simultaneously with multi-threading
        - Orthogonality of Concurrency and Parallelism
    b. Implciit Parallelism
        - Pipelining
            - Stages - Fetch, Decode, Execute, Memory Access, Register Write-Back
            - Goal - begin a new instruction on each clock cycle, keeping the CPU busy
        - Latency vs. Throughput
            - Latency - amount of time required to completely process a single instruction (sum of the latencies of all stages of pipeline)
            - Throughput - measure of how many instructions a pipeline can process per unit of time
        - Pipeline Depths - balance throughput with overall latency
        - Stalls - a CPU is unable to issue a new instruction on a particular clock cycle
        - Data Dependencies - later stages of the pipeline are dependent on results of earlier stages
             - Data Dependencies, Control Dependencies, Structural Depedencies
        - Instruction Reordering - reodering instructions, without changing the behavior of the program, to make the most of the pipeline
        - Out-Of-Order Execution - CPUs support out of order execution to dynamically detect data dependencies between instructions and automatically resolve them
        - Branch Dependencies - example where jump cannot occur until results of cmp 
        - Speculative Execution/Branch Prediction - running code along branch in the hopes the CPU chose correctly
            - Branch Penalty - choosing the wrong branch
        - Predication - Execute both branches and then use a mask to produce the final answer
        - Superscalar CPUs - duplicate components on chip so that two instructions can be launched each clock cycle
            - Design can lead to resource dependencies, two or more consecutive instructions all requrie the same CPU functional unit
        - Superscalar and RISC - using reduced instruction set to free up transistors
        - Very Long Instruction Word VLIW - allowing programmers to dispatch instructions to multiple compute elements which requires a longer instruction word
    c. Explicit Parallelism
        - Hyperthreading - selecting instructions from two separate instruction streams
            - HT core consists of two register files and two instruction decode units but with a single back end for executing instructions
        - Multicode CPUs - multiple cores oon a PC
        - Symetric vs. Asymmetric Multiprocessing
            - Symmetric Multiprocessing - available CPU cores in the machine are homogenous in deisgn and ISA and are treated equally by the operating system
            - Asymmetric Multiprocessing - CPU cores are not homogenous and the operating system does not treat them equally
        - Distributed Computing - making use of multiple stand along computers working in concert
            - Examples - computer clusters, grid computing, and cloud computing
    d. Operating System Fundamentals
        - Kernel - layer of operating system that operates at the lowest level and nearest to hardware
            - Kernel Mode vs. User Mode
                - Kernel mode is privileged, allowing the greatest access and power
                - User mode is limited, accessing low level services require a kernel call
                - Protection Rings - inner circle is most trusted, with reduced trust as you become further away
                - Kernel Mode Privileges - access to all of the instructions defined in the ISA, including privileged instruction
            - Interrupts - signal sent to CPU in order to notify it of an important low level event e.g. keypress
            - Kernel Calls - request to kernel to perform a privileged operation, normally through a kernel API
            - Preemptive Multitaksing - programs share the CPU by time-slicing, however the scheduling of programs is controlled by the operating system
        - Processes - operating systems way of managing a running instance of a program
            - Anatomy of a Process
                - Process ID (PID) - unique identifies the process within the operating system
                - Permissions - which user owns each process and which group the user belongs to
                - Parent Process ID
                - Virtual Memory Space - containing the processe's view of physical memory
                - Environemt Variables
                - File Handles
                - Working Directory
                - Synchronization and Communication Resource - sempahores, queues, pipes
                - Threads - encapsualtes a running instance of a single stream of machine language instructions
            - Virtual Memory Map of Process
                - Virtual Table/Memory Map:
                    - Text, Data, BSS - executable files read in so program code and global data is visible within process
                    - Call Stack
                    - Shared libraries - program dependencies
                    - Heap - for dynamic memory allocation
                    - Kernel Pages - separate virtual page table that is shared between all processes
            - Threads - encapsulates a running instance of a single strean of machine language instructions
                - Thread ID - unique identifier within the process
                - Call Stack - contiguous block of memory containing the stack frames of all currently executing functions
                - Special and General Registers
                - Thread Local Storage
                - Thread Libraries - collection of system calls for creating and manipulating threads
                    - Create, Terminate, Request to Exit, Sleep, Yield, Join
                - Thread Creation and Termination
                    - Process executed by the OS automatically contains a single thread, and additional threads can be created using system calls
                    - Threads can end:
                        - Naturally, system call, killed by another thread, and killed by process ending
                - Joining Threads - wait for other threads to finish
                - Polling, Blocking, and Yielding
                    - Polling - single thread sitting in a tight loop, waiting for a condition to become true
                    - Blocking - put thread to sleep and rely on the kernel to wake it up based on some condition
                        - Examples - opening a file, explcit sleeping, joining with another thread, waiting for a mutex lock
                    - Yielding - thread polls the condition in a loop, but on each iteration it relinquishes the remaining of its time slice by yielding
                - Context Switching - switching between thread states
                    - Thread States - running, runnable, blocked
                - Thread Local Storage - private memory block for data that is private to this process, shared with other threads


Chapter 5 - 3D Math for Games
Chapter 6 - Engine Support Systems
Chapter 7 - Resources and the File System
Chapter 8 - The Game Loop and Real-Time Simulation
Chapter 9 - Human Interface Devices
Chapter 10 - Tools for Debugging and Development
Chapter 11 - The Rendering Engine
Chapter 12 - Animation Systems
Chapter 13 - Collision and Rigid Body Dynamics
Chapter 14 - Audio
Chapter 15 - Introduction to Gameplay Systems
Chapter 16 - Runtime Gameplay Foundation Systems