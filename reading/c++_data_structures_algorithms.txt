Title: C++ Data Structures and Algorithms
Authors: Michael T. Goodrich, Roberto Tamassia, David Mount

Summarization of Content

Chapter 3 - Arrays, Linked Lists, Recursion
    a. Using Arrays
        - Storing Game Entries in an Array
            - Classes
                - Game Entry
                - Scores
                    - GameEntry* entries
            - Insertion
                - When inserting, shift elements right/back, and then insert element at target index
            - Object Removal
                - When removing, start at target index, and shift elements left/forward
        - Sorting an Array
            - Insertion Sort
                - Moving through the array, for each element, sort it into sorted section i.e. start of the array
        - Two Dimensional Arrays and Positional Games
            - C++ - int M[8][10] or int schedule[DAYS][HOURS]
            - Dynamic Allocation of Matrices
                - Pointer to a pointer of integers
                    - int **M = new int*[n]
                    - for int i = 0; i < n; i++
                        - M[i] = new int[m]
        - Using STL Vectors to Implement Matrices
            - vector<vector<int> M(n, vector<int>(m))
    b. Singly Linked Lists
        - Linked List - collection of nodes that together form a linear ordering
        - Node
            - T data, Node* next
        - Implementing a Singly Linked List - CIS 200 - Midterm 2
        - Insertion to the Front of a Singly Linked List - CIS 200 - Midterm 2
        - Removal from the Front of a Singly Linked List - CIS 200 - Midterm 2
        - Implementing a Generic Singly Linked List - CIS 200 - Midterm 2
    c. Doubly Linked Lists
        - Header and Trailer Sentinels - do not store values, header points to first node of the list, trailer points to last node of the list
        - Insertion into a Doubly Linked List - CIS 200 - Lab 07
        - Removal from a Doubly Linked List - CIS 200 - Lab 07
        - A C++ Implementation - CIS 200 - Lab 07
    d. Circularly Linked Lists and List Reversal
        - Circularly Linkied List - nodes of circularly linked list are linked into a circle
            - Cursor - allows use to have a place to start from if we ever need to traverse a circularly linked list
            - Back - element referenced by the cursor
            - Front - Element immediately following the back
            - Methods - front(), back(), advance(), add(), remove()
                - add() - insert node immediately after the cursor
                - remove() - remove the node immediately after the cursor
            - Example - maintaining a playlist for digital audio player
        - Reversing a Linked List
            - Copy the content of the list L in reverse order into a temporary list T (push into front of T)
            - Copy the contents of T back into L (take from front of T and add to back of L)
    e. Recursion
        - The Factorial Function
        - Ruler Drawing
        - Examples
            - Modern operating system file system directories
            - Argument lists in modern programming languages
            - Russian matryoshka dolls
        - Linear Recursion - function is defined so that it makes at most one recursive call each time it is invoked
            - Linear Sum for Array
        - Key Concepts
            - Base case and recursion step
        - Reversing an Array by Recursion
        - Tail Recursion - uses linear recursion and the algorithm make a recursive call as its very last operation
            - Algorithms that lend themselves more easily and efficicently to conversion to nonrecursive solution
            - Example - revereseArray
        - Binary Recursion - when an algorithm makes two recursive calls e.g. fibonnaci
        - Computing Fibbonaci Numbers via Linear Recursion - MUST REVIEW
        - Multiple Recursion - when a function may make multiple recursive calls, with that number potentially being more than two

Chapter 4 - Analysis Tools
    a. The Seven Functions Used in This Book
        - The Constant Function - f(n) = c
            - Use - characterizes the number of steps needed to do a basic operation on a computer
        - The Logarithmic Function - f(n) = logn
            - Use - characterizes common operations in many algorithms where you repeatedly divide an input in half (divide and conquer)
        - The Linear Function - f(n) = n
            - Use - characterizes situations where we have to do a single base operation for each of n elements
        - The N-Log-N Function - f(n) = nlogn
            - Use - target growth rate to make improvements to programs that run at quadratic or exponential time
        - The Quadratic Function - f(n) = n²
            - Use - characterizes situations with nested loops
        - The Cubic Function and Other Polynomials - f(n) = n³ and f(n) = anᵈ
            - Use - Cubic not as frequent, polynomial very common, but leading degree determines growth rate
        - The Exponential Function - f(n) = bⁿ
            - Use - characterizes situations where the number of operations performed each iteration doubles
        - Comparing Growth Rates (Best to Worst Growth Rate)
            - Constant -> Logarithm -> Linear -> N Log N -> Quadratic -> Cubic -> Exponential
    b. Analysis of Algorithms
        - Primitive Operations
            - Assigning a value to a variable
            - Calling a function
            - Performing an arithmetic operation
            - Comparing two numbers
            - Indexing into an array
            - Following an object reference
            - Returning from a function
        - Focus - The Worst Case
        - Asymptotic Notation
            - The Big-Oh Notation - f(n) <= cg(n)
                - Describes that a function's growth rate is at worst, described by g(n)
                - IMPORTANT - can ignore lower order terms and just focus on the highest degree
            - The Big-Omega - f(n) >= cg(n)
                - Describes that a function's growth rate is at best
            - The Big-Theta - c'g(n) <= f(n) <= c''g(n)
                - Describes that a function is bounded by two functions

Chapter 5 - Stacks, Queues, and Deques
    a. Stacks - container of elements that are inserted and removed according to the last-in-first-out LIFO principle
        - Stack Abstract Data Type
            - Methods - push(), pop(), top(), size(), empty()
        - STL - provides an implementation of a stack based on STL vector class
        - A C++ Stack Interface - CIS 200 - Midterm 2
        - A Simple Array Based Stack Implementation - CIS 200
            - Analysis - each function runs in constant time
        - Imnplementing a Stack with a Generic Lnked List - CIS 200
        - Reversing a Vector Using a Stack
            - Push all the elements of the vector in order into a stack
            - Fill vector back up by popping elements off of the stack
        - Stack Usages
            - Matching Parentheses
            - Matching HTML Tags
            - Post-Fix Arithmetic
            - General idea
                - Push opening grouping symbols onto stack
                - If closing group symbol is encountered, check the top of stack and make sure closing matches opening
    b. Queues - container of elements that are inserted and removed according to the first-in-first-out FIFO principle
        - Queue Abstract Data Type
            - Methods - enqueue(), dequeue(), front(), size(), empty()
        - STL Queue - provides an implementation of a queue based on STL vector class
        - A C++ Queue Interface - CIS 200 - Midterm 2
        - A Simple Array Based Implementation - CIS 200
            - Using an Array in a Circular Way - in order to implement enqueue and dequeue in constant times
            - Using the Modulo Operator to Implement a Circular Array
        - Implementing a Queue with a Circularly Linked List
            - Insert/Enqueue - insert a node new just after the cursor (back), and set new back
            - Remove/Dequeue - remove a node just after the curor (back), and set new front
        - Double Ended Queues (Deque) - queue that supports deletion at both the front and rear of the queue
        - The STL Deque
            - methods - size(), empty(), push_front(), push_back(), pop_front(), pop_back(), front(), back()
        - Implementing a Deque with a Doubly Linked List
        - Adapters and the Adapter Design Pattern
            - Adapter - data structure, that translates one interface to another

Chapter 6 - List and Iterator ADTs
    a. Vectors
        - The Vector Abstract Data Type
            - at() - returns element of V with index i
            - set() - replaces element at index i
            - insert() - inserts a new element
            - erase() - removes element at index i
        - Array Based Implementation
            - Issue - shifting elements back and forth as elements are inserted or removed
        - Extendable Array Based Implementation
            - When the length of array is full and insertion is required, you must:
                - Allocate space for a new array in memory
                - Copy all elements from old array to new aray
                - Insert element
                - Deallocate memory associated with old array
        - Analysis - REVIEW amortization*
        - STL Vectors
            - Container is a data structure that stores a collection of objects
            - vector() - construct a vector
            - size() - return number of elements in V
            - empty() - return true if V is empty and false otherwise
            - resize() - resize V
            - reserve() - request allocated storage space
            - operator[] - access at index i
            - at() - same as access, throws an error
            - front() - return a reference to the first element of V
            - back() - return a reference to the last element of V
            - push_back() - append a copy of the element to the end of V
            - pop_back() - removes the last element of V
    b. Lists
        - Node Based Operators and Iterators
            - Goal - gaining speed over index based functions, making remove and insert constant time
            - Iterator - access individual elements and move around in order to enumerate all the elements of a list
            - Containers and Positions
                - Container - data structure that stores any collection of elements
                - Position - abstract data type that is assocataed with a particular container
            - Iterators - navigate through a container by advancing to the next position
                - ADT of Iterator
                    - begin(), end(), ++p, --p
        - The List Abstract Data Type
            - begin() - return iterator referring to the first element
            - end() - return iterator referring to the last element
            - insertFront() - insert a new element in front
            - insertBack() - insert a new element in the back
            - insert() - insert element before position
            - eraseFront() - remove the first element
            - eraseBack() - remove the last element
            - erase() - remove element at position p
        - Double Linked List Implementation
            - Implement list as Doubly Linked List, to enable easy access to front and back
        - STL Lists
            - list() - construct a list with n elements
            - size() - return number of elements
            - empty() - return true if empty and false otherwise
            - front() - return a reference to first element of L
            - back() - return a reference to the last element of L
            - push_front() - insert a copy of e at beginning
            - push_back() - insert a copy of e at end
            - pop_front() - remove first element
            - pop_back() - remove last element
        - STL Containers and Iterators
            - STL Containers - vector, deque, list, stack, queue, priority_queue, set, multiset, map, multimap
            - STL Iterators
                - Methods
                    - ++p, move forward
                    - --p, move backwards
                    - begin - returns iterator at beginning
                    - end - returns iterator at end
                - Bidirectional Iterator - moving forward and backward
                - Random Access Iterator - addition and substraction of an integer, to access different positions
            - STL Iterator Based Container Functions
                - vector() - construct a vector
                - assign() - delete contents of V, assign new contents by iterating between start and end
                - insert() - insert a copy of e prior to position
                - erase() - remove and destroy an element of V at position p
                - erase () - iterate between start and end and remove and destory each element
                - clear() - delete all elements
            - STL Vectors and Algorithms
                - sort() - sort elements in a range
                - random_shuffle() - rearrange elements in range in random order
                - reverse() - reverse elements in range
                - find() - return iterator to first element in the range
                - min_element() - return iterator to minimum element in range
                - max_element() - return iterator to max element in range
                - for_each() - apply function f to the elements in range
    c. Sequences
        - The Sequence Abstract Data Type
            - atIndex() - return position of the element at index i
            - indexOf() - return index of the element at position p
        - Implementing a Sequence with an Array
            - For each index in an array, store a pointer to a new kind of position object that contains the index and the element
            
Chapter 9 - Hash Tables, Maps, and Skip Lists
    a. Maps
        - Introduction
            - Map - allows use to store elements so they can be located quickly using keys, stores key value pairs called entries
            - Entries and the Composition Pattern - defines a single object that is composed of other objects
        - The Map ADT
            - Posiiton/Iterator - pointer object which permits us to reference entries of the map
            - Methods
                - size() - returns number of entries in M
                - empty() - returns true if M is empty and false otherwise
                - find() - if M contains an entry e = (k, v), then returns an iterator p referring to this entity, otherwise return end iterator
                - put() - add entry if does not exist, replace value if key exists
                - erase() - remove entry with key k
                - erase() - remove entry referenced by iterator p
                - begin() - return an iterator to the first entry of M
                - end() - return an iterator to a position just beyond the end of M
        - A C++ Map Interface - TODO:
        - The STL Map Class
            - Methods
                - size() - returns number of entries in M
                - empty() - returns true if M is empty and false otherwise
                - find() - if M contains an entry e = (k, v), then returns an iterator p referring to this entity, otherwise return end iterator
                - operator[] - provides reference to the value of k 
                - insert(pair()) - insert pair, returning iterator to its position
                - erase() - remove entry with key k
                - erase() - remove entry referenced by iterator p
                - begin() - return an iterator to the first entry of M
                - end() - return an iterator to a position just beyond the end of M
        - A Simple List Based Map Implementation - TODO:
    b. Hash Tables
    c. Ordered Maps 
        - Ordered Map - perform usual map operations and also maintain an order relation for the keys in our map and use this order in some of the map functions
        - ADT Methods
            - firstEntry() - return an iterator to the entry with smallest key value
            - lastEntry() - return an iterator to the entry with largest key value
            - ceilingEntry() - return an iterator to the entry with the least key value greater than or equal to k
            - floorEntry() - return an iterator to the entry with the greatest key value less than or equal to k
            - lowerEntry() - return an iterator to the entry with the greatest key value less than k
            - higherEntry() - return an iterator to the entry with the least key value greater than k
        - Implementing an Ordered Map
        - Ordered Search Table and Binary Search - efficient structure and algorithm together for searching through
        - Comparing Map Implementation
            - Method
                - size,empty - List is O(1), Hash Table is O(1), Search Table is O(1)
                - find - List is O(n), Hash Table is O(n), Search Table is O(logn)
                - insert - List is O(1), Hash Table is O(1), Search Table is O(n)
                - erase - List is O(n), Hash Table is O(n), Search Table is O(n)

Chapter 10 - Search Trees
    
