Title: Linux Programming Interface
Authors: Michael Kerrisk

Summarization of Content

Chapter 1 - History
    a. A Brief History of UNIX and C
        - First Edition - November 1971 - PDP-11 w/ FORTRAN compiler
            - ar, cat, chmod, chown, cp, dc, ed, find, ln, ls, mail, mkdir, mv, rm, sh, su, who
        - Second Edition - June 1972 - Installed on 10 Machines
        - Third Edtiion - February 1973 - C Compiler and Pipes
        - Fourth Edition - November 1973 - Almost Totally C
        - Fifth Edition - June 1974 - Installed on > 50 Systems
        - Sixth Edition - May 1975 - Widely used outside of AT&T
        - Seventh Edition  - January 1979 - Improved Reliability and File System
            - awk, make, sed, tar, uucp, Bourne Shell, FORTRAN 77 Compiler
        - 3BSD - December 1979 - Berkely Software Distribution
        - System V - 1989 - Commercial Licensing
    b. A Brief History of Linux
        - GNU Project - 1984 - Richard Stallman develops free UNIX-like system without kernel
        - GNU Public License
        - Linux - March 1994
        - Linux 2.6 - December 2003
    c. Standardization
        - C Programming Language
            - American National Standards Institute ANSI C89
            - International Standard Organization ISO C99
        - POSIX - Portable Operating System Interface
            - Institute of Electrical and Electronic Engineers - POSIX.1 1988
            - POSIX.2 1992
        - FIPS 151-1 and FIPS 151-2
        - X/Open Company and The Open Group
        - SUSv3 and POSIX.1-2001
        - SUSv4 and POSIX.1-2008

Chapter 2 - Fundamental Concepts
    a. Core Operating System: The Kernel
        - Kernel - central software that manages and allocates computer resources i.e. CPU, RAM, and Devices
        - Tasks: Process Scheduling, Memory Management, Provision of File System, Processes Management, Device Access, Networking, System API
        - Modes: Kernel vs. User
    b. Shell
        - Versions: Bourne (sh), C (csh), Korn (ksh), Bourne Again (bash)
        - Capabilities: variables, loops, conditional statements, functions, I/O
    c. Users and Groups
        - Users - User ID, Home Directory, Login Shell
        - Groups - Group Name, Group ID, User List
        - Superuser - ID = 0, Name = root
    d. Single Directory
        - / -> bin,boot,etc,home,usr
        - File Types - link, directory, devices, pipes, sockets
        - Directory - special file whose contents take the form of a table of filenames coupled with references to files
        - Symbolic Links - contains name of another file
        - Filenames - 255 char portable filename character set
        - Pathnames - string of / separated directories ending in a file or directory
    e. File I/O Model
        - System Calls - open(), read(), write(), close()
        - Descriptors - 0 is standard input, 1 is standard output, and 2 is standard error
        - stdio - fopen(), fclose(), scan(), printf(), fgets(), fputs()
    f. Programs
        - Source-Code - human-readable text
        - Binary - machine-language instructions that a computer can understand
        - Filter - program reads from stdin, performs a transformation, and writes transformed data to stdout
        - CLI Arguments
            - int main(int argc, char *argv[])
            - argc is total number of arguments
            - argv is array of individual arguments
    g. Processes - instance of an executing program
        - Segments
            - Text - instruction of the program
            - Data - static variables used by the program
            - Heap - area from which programs can dynamically allocate extra memory
            - Stack - piece of memory that grows and shrinks as functions are called and returned
        - Create - parent process uses fork() to create child process that inherits parent's data, stack, and heap
        - Process Identifier PID and Parent Process Identifier PPID
        - Termination - _exit() or kill w/ signal
        - IDs
            - Process Real User ID and Real Group ID
            - Effective User ID and Effective Group ID
            - Supplementary Group IDs
        - Privilege Process - effective user id is 0 and bypasses permission restrictions
        - Init - parent of all processes, /sbin/init, creates and monitors a range of processes required by a running system
        - Daemon - special purpose process that is long-lived and runs in the background
        - Environment List - environment variables used to communicate information to processes
        - Resource Limits - setrlimit() to set soft limit and hard limit
    h. Memory Mappings
        - File Mapping - maps a region of a file into the calling process's virtual memory
        - Anonymous Mapping - initialized to 0
    i. Static and Shared Libraries
        - Static - structured bundle of compiled object modules
        - Shared - grabbed by dynamic linker and loaded into memory when needed by program
    j. Interprocess Communication
        - Mechanisms
            - Signals - indicate an event has occurred, "software interrupts"
            - Pipes - transfers data between processes
            - Sockets - transfer data from one process to another, either on same host or different hosts connected by a network
            - File Locking - allows a process to lock regions of a file in order to prevent other processes from reading or updating
            - Message Queues - used to exchange messages (packets of data) between processes
            - Semaphores - used to synchronize the actions of processes
            - Shared Memory - allows two or more processes to share a piece of memory
    k. Threads
        - Processes that share the same virtual memory as well as a range of other attributes
    l. Sessions, Controlling Terminals, and Controlling Processes
        - Session - collection of process groups
        - Controlling Terminal - established when session leader process first opens a terminal device
        - Foreground Process - may read input from terminal and send output to it
        - Background Process
    m. Pseudoterminals
        - Pair of connected virtual devices, known as master and slave with an IPC channel allowing two way data transfer
        - Slave provides an interface that behaves like a terminal, allowing another program to drive the terminal-oriented program connected to slave device
        - Examples Telnet and SSH
    n. Date and Time
        - Real Time - calendar time since Midnight on 01/01/1970
        - Process Time - total amount of CPU time that a process has used since starting
            - System CPU Time - time spent executing code in kernel mode
            - User CPU Time - time spent executing code in user mode
        - Time command - real, system CPU, and user CPU time
    o. Client-Server Architecture
        - Client - asks the server to carry out some service by sending it a request message
        - Server - examines client's request, performs appropriate actions, and then sends a response message back to client
    p. Realtime
        - Extensions - asynchronous I/O, shared memory, memory-mapped files, memory locking, realtime clocks and timers, scheduling policies, realtime signals, message queues and semaphores

Chapter 3: System Programming Concepts
    a. System Calls
        - Goal - controlled entry point into the kernel, allowing a process to request that the kernel perform some action on the process' behalf
        - System Call API
        - System Calls
            - Change the processor state from user mode to kernel mode
            - Set of system calls is fixed
            - Each system call may have a set of arguments that specify information transferred from user space to kernel space and vice-versa
        - Order
            - Application program makes a system call by invoking a wrapper function in the C Library
            - Wrapper function makes system call arguments available to the system by copying arguments into specific registers
            - Wrapper function copies system call number into CPU register %eax
            - Wrapper function executes a trap machine instruction, which causes the processor to switch from user mode to kernel mode and execute code pointed to by location 0x80
            - Kernel invokes system_call() routine
                - Saves register values onto the kernel stack
                - Checks validity of the system call number
                - Invokes appropriate system call service routine using system call number to index a table of all system calls sys_call_table
                - Service routine performs the required task and then returns a result status to system_call() routine
                - Restores register values from the kernel stack and places the system call return value on the stack
                - Returns to the wrapper function
            - Processor switches back to user mode
            - If return value of system call indicates an error, wrapper function sets errno using the value
            - Wrapper function returns to the caller, providing an integer return value indicating the success or failure of the system call
        - Overhead - system calls have a small but appreciable overhead
    b. Library Functions
        - Goal - one of the multitude of functions that constitutes the standard C library
        - Some use system calls and others do not
        - Standard C Library
            - GNU C Library - glibc
            - Version - /lib/libc.so.6
    c. Handling Errors
        - Important - always check status value from system call and library functionss for an error
        - System Call Errors
            - Error is normally indicated by -1
            - Check Example - fd = system call, if (fd == -1) {/* Code to Handle an Error */}
            - Print Error Message - perror() and strerror()
        - Library Function Errors Three Types
            - Return in same way as system calls
            - Set errno to indicate specific error condition aand returns a value other than -1 on error
            - Errno is not used at all
    d. Example Programs in this Book
        - Command-Line Options and Arguments
            - standard getopt() library
        - Common Functions and Header Files
            - Header File - tlpi_hdr.h pg. 51
            - Error Diagnostic Functions - error_functions.h
                - errMsg() - prints a message on standard error
                - errExit() - prints a message on standard error and terminates the program
                - err_exit() - similar to errExit() but does not flush standard output before print error and does not flush stdio buffers or invoke exit handlers
                - errExitEN)() - similar to errExit() but prints error number instead
                - fatal() - used to diagnose general errors, including errors that don't set errno
                - usageErr() - diagnose errors in command-line argument usage
                - cmdLineErr() - diagnose errors in command-line arguments specified to a program
                - Parsing Command Line Arguments
                    - getInt()
                    - getLong()
    e. Portability Issues
        - Feature Test Macros - have header files expose the definitions (constants, function prototypes, and so on) that follow a particular standard
        - System Data Types - pg. 65

Chapter 4: File I/O: The Universal I/O Model
    a. Overview
        - File Descriptor - a usually small, nonnegative number
        - Standard File Descriptors
            - 1 - stdin - STDIN_FILENO
            - 2 - stdout - STDOUT_FILENO
            - 3 - stderr - STDERR_FILENO
        - Key System Calls
            - fd = open(pathname, flags, mode) - opens the file identified by pathname, returning a file descriptor used to refer to the file in subsequent calls e.g. read, lseek, and write
            - numread = read(fd, buffer, count) - reads at most count bytes from the open file referred to by fd and stores them in buffer
            - numwritten = write(fd, buffer, count) - writes at most count bytes from the buffer to the open file referred to by fd
            - status = close(fd) - releases fd and its associated kernel resources
        - Key Code Example - pg. 71 and Linux Workspace tlpi-dist/fileio/copy.c
    b. Universality of I/O
        - open(), read(), write(), and close() are used to perform I/O on all types of files, including devices such as terminal
            - ./copy test test.old - copy a regular file
            - ./copy a.txt /dev/tty - copy a regular file to this terminal
            - ./copy /dev/tty b.txt - copy input from this terminal to a regular file
            - ./copy /dev/pts/16 /dev/tty - copy input from another terminal
    c. Opening a File: open()
        - fn - int open(const char *pathname, int flags, .... /* mode_t mode */);
            - pathname - file to be opened
            - flag - bit mask that specifies the access mode for the file i.e. permissions to be placed, depend on mode, process umask and optional access control list
        - Examples
           - fd = open("startup", O_RDONLY); - open existing file for reading
           - fd = open("myfile", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR); - open new or existing file for reading and writing, truncating to zero bytes, file permissions read-write for owner, nothing for all others
           - fd = open("w.log", O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR); - open new or existing file for writing, writes should always append to end of file
        - File Descriptor returned - if open() succeeds, it should return the lowest number unused file descriptor for the process
        - open() flags argument
            - File Access Mode Flags - only one of these values should be specified in flags
                - O_RDONLY - open for reading only
                - O_WRONLY - open for writing only
                - O_RDWR - open for reading and writing
            - File Creation Flags - control aspects of behavior of the open() call
                - O_CLOEXEC - set the close on-exec flag
                - O_CREAT - create file if it doesn't already exist
                - O_DIRECTORY - fail if pathname is not a directory
                - O_EXCL - with O_CREAT; create file exclusively
                - O_LARGEFILE - used on 32-bit systems to open large files
                - O_NOCTTY - dont let pathname become the controlling terminal
                - O_NOFOLLOW - dont dereference symbolic links
                - O_TRUNC - truncate existing file to zero length
            - File Status Flags
                - O_APPEND - writes are always appended to end of file
                - O_ASYNC - generate a signal when I/O is possible
                - O_DIRECT - file I/O bypasses buffer cache
                - O_DSYNC - provide synchronized I/O data integrity
                - O_NOATIME - don't update file last access time on read
                - O_NONBLOCK - open nonblocking mode
                - O_SYNC - make file write synchronous
        - Errors from open() - if an error occurs open() returns -1 and errno identifies the cause of the error
            - EACCES - file permissions don't allow the calling process to open the file in the mode specified byu the flags or because of directory permissions, the file could not be accessed or the file did not exists and could not be created
            - EISDIR - the specified file is a directory, and the caller attempted to opedn it for writing, which is not allowed
            - EMFILE - the process resource limit on the number of open file descriptors has been reached
            - ENFILE - the system wide limit on the number of open files has been reached
            - ENOENT - the specified file doesn't exists, and O_CREAT was not specified
            - EROFS - the specified file is on a read-only file system and the caller tried to open for writing
            - ETXTBSY - the specified file is an executable file that is currently executing
    d. The creat() System Call
        - fn - int creat(const char *pathname, mode_t mode);
        - Goal - creates and opens a new file with the given pathname, or if the file already exists, opens the file and truncates it to zero length
    e. Reading from a File: read()
        - fn - ssize_t read(int fd, void *buffer, size_t count);
            - count - specifies the maximum number of bytes to read
            - buffer - supplies the address of the memory buffer into which the input data is to be placed, buffer must be at least count bytes long
                - system calls dont allocate memory for buffers that are used to return information to the caller, instead we must pass a pointer to a previously allocated memory buffer of the correct size
            - successful call to read returns the number of bytes actually read, or 0 if end of file is encountered
        - Examples
            - numRead = read(STDIN_FILENO, buffer, MAX_READ);
    f. Writing to a File: write()
        - fn - ssize_t write(int fd, void *buffer, size_t count);
            - count - specifies the maximum number of bytes to write
            - buffer - supplies the address of the memory buffer from which the input data is to be written, buffer must be at least count bytes long
            - successful call to write returns the number of bytes actually written
    g. Closing a File: close()
        - fn - int close(int fd);
        - closes an open file decsriptor, freeing it for subsequent reuse by the process. When a process terminates, all of its open file descriptrs are automatically closed
        - Example
            - if (close(fd) == -1); errExit("close");
    h. Changing the File Offset: lseek()\
        - File Offset - location in the file at which the next redad or write will commence
        - fn - off_t lseek(int fd, off_t offset, int whence);
            - offset - specifies a value in bytes
            - whence - indicates the base point from which offset is to be interpreted
                - SEEK_SET - the file offset is set offset bytes from the beginning of the file
                - SEEK_CUR - the file offset is adjusted by offset bytes relative to the current file descriptor
                - SEEK_END - the file offset is set to the size of the file plus offset. In other words, offset is interpreted with respect to the next byte after the last byte of the file
        - File Holes - a program seeks past the end of a file and then performs I/O, it is possible to write bytes at an arbitrary point past the end of the file, files holes do not take up disk space
            - Advantage - a sparsely populated file consumes less disk space than woul dotherwise be required if the null bytes actually neeeded to be allocated in disk blocks
        - Key Code Example - pg. 84 or tlpi-dist/fileio/seek_io.c
    i. Operations Outside the Universal I/O Model: ioctl()
        - fn - int ioctl(int fd, int request, .... /* argp */);
            - fd - open file descriptor
            - request - control operation to be performed
            - argp - could be anything, typically a pointer to either an integer or a structure

Chapter 5: File I/O: Further Details
    a. Atomicity and Race Conditions
        - Atomicity - kernel guarantees that all of the steps in the operation are completed without being interrupted by another process or thread
        - Race Conditions - a situyation where the result produced by the two processes operating on a shared resource depends in an unexpected way on the relative order in which the processes gain access to the CPU(s)
        - Creating a File Exclusively - use open() with O_CREAT and O_EXCL to guarantee the check for a file and creation are carried out as a single atomic operation
        - Appending Data to A File - use open() with O_APPEND to esnure that the seek to the next byte past the end of the file and the write operation is carried out as a single atomic operation
    b. File Control Operations
        - fn - int fcntl(int ffd, int cmd, ...); - performs a range of control operations on an open file descriptor
    c. Open File Status Flags
        - F_GETFL - retrieves settings like access mode and status flags
    d. Relationship Between File Descriptors and Open Files
        - Per-Process File Descriptor Table - Each Entry
            - a set of flags controlling the operation of the file decsriptor
            - a reference to the open file description
        - System Wide Table of All Open File Descriptions - Each Entry
            - the current file offset (as updated by read() and write(), or by explicitly using lseek())
            - status flags specified when opening the file (i.e. the fl;ags argument to open())
            - the file access mode (read-only, write-only, or read-write)
            - settings relating to signal-driven I/O
            - a reference to the i-node object for this file
        - I-Node Table - Each Entry
            - file type e.g. regular file, socket, or FIFO, and permissions
            - a pointer to a list of locks held on this file
            - various properties of the file, including its size and timestamps relating to different types of file operations
    e. Duplicating File Descriptors
        - fn - int dup(int oldfd) - returns a new descriptor that refers to the same open file description
        - fn - int dup2(int oldfd, int newfd) - makes a duplicate of the file descriptor given in oldfd using the descriptor number supplied in newfd
        - fn - int dup3(int oldfd, int newfd, int flags) - same as dup2, but adds an additional argument, flags, that is a bit mask that modifies the behvaior of the system call
    f. File I/O at a Specified Offset: pread() and pwrite()
        - fn - ssize_t pread(int fd, void *buf, size_t count, off_t offset) - read at the location specified by offset
        - fn - ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset) - writes at the lcoation specified by offset
    g. Scatter-Gather I/O: readv() and writev()
        - fn - ssize_t readv(int fd, const struct iovec *iov, int iovcnt) - reads a contiguous sequence of bytes from the file referred to by the file descriptor fd and places those bytes into the buffers specified by iov
        - fn - ssize_t writev(int fd, const struct iovec *iov, int iovcntl) - gathers data from all buffers specified by iov and writes them as a sequence of contiguous bytes to the file referred to by the file descriptor fd
    h. Truncating a File: truncate() and ftruncate()
        - fn - int truncate(const char *pathname, off_t length) - sets the size of a file to the value specified by length
            - if file is longer than length, excess data is lost
            - if file is shrorter than length, extended by padding with a sequence of null bytes or a hole
    i. Nonblocking I/O
        - if file can't be opened immediately, then open() returns an error instead of blocking
        - after a successful open(), subsequent I/O are also nonblocking
    j. I/O on Large Files
        - _FILE_OFFSET_BITS macro
            - converts all of the relevant 32-bit functions and data types into their 64-bit counterparts e.g. open() with open64()
    k. The /dev/fd Directory - contains filenames of the form /dev/fd/n, where n corresponds to one of the open file descriptors for the process
    l. Creating Temporary Files
        - fn - int mkstemp(char *template) - generates a unique filename based on a template supplied by the caller and opens the file, returning a file decsriptor that can be used with I/O system calls
    