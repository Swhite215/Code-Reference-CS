Title: Linux Programming Interface
Authors: Michael Kerrisk

Summarization of Content

Chapter 1 - History
    a. A Brief History of UNIX and C
        - First Edition - November 1971 - PDP-11 w/ FORTRAN compiler
            - ar, cat, chmod, chown, cp, dc, ed, find, ln, ls, mail, mkdir, mv, rm, sh, su, who
        - Second Edition - June 1972 - Installed on 10 Machines
        - Third Edtiion - February 1973 - C Compiler and Pipes
        - Fourth Edition - November 1973 - Almost Totally C
        - Fifth Edition - June 1974 - Installed on > 50 Systems
        - Sixth Edition - May 1975 - Widely used outside of AT&T
        - Seventh Edition  - January 1979 - Improved Reliability and File System
            - awk, make, sed, tar, uucp, Bourne Shell, FORTRAN 77 Compiler
        - 3BSD - December 1979 - Berkely Software Distribution
        - System V - 1989 - Commercial Licensing
    b. A Brief History of Linux
        - GNU Project - 1984 - Richard Stallman develops free UNIX-like system without kernel
        - GNU Public License
        - Linux - March 1994
        - Linux 2.6 - December 2003
    c. Standardization
        - C Programming Language
            - American National Standards Institute ANSI C89
            - International Standard Organization ISO C99
        - POSIX - Portable Operating System Interface
            - Institute of Electrical and Electronic Engineers - POSIX.1 1988
            - POSIX.2 1992
        - FIPS 151-1 and FIPS 151-2
        - X/Open Company and The Open Group
        - SUSv3 and POSIX.1-2001
        - SUSv4 and POSIX.1-2008

Chapter 2 - Fundamental Concepts
    a. Core Operating System: The Kernel
        - Kernel - central software that manages and allocates computer resources i.e. CPU, RAM, and Devices
        - Tasks: Process Scheduling, Memory Management, Provision of File System, Processes Management, Device Access, Networking, System API
        - Modes: Kernel vs. User
    b. Shell
        - Versions: Bourne (sh), C (csh), Korn (ksh), Bourne Again (bash)
        - Capabilities: variables, loops, conditional statements, functions, I/O
    c. Users and Groups
        - Users - User ID, Home Directory, Login Shell
        - Groups - Group Name, Group ID, User List
        - Superuser - ID = 0, Name = root
    d. Single Directory
        - / -> bin,boot,etc,home,usr
        - File Types - link, directory, devices, pipes, sockets
        - Directory - special file whose contents take the form of a table of filenames coupled with references to files
        - Symbolic Links - contains name of another file
        - Filenames - 255 char portable filename character set
        - Pathnames - string of / separated directories ending in a file or directory
    e. File I/O Model
        - System Calls - open(), read(), write(), close()
        - Descriptors - 0 is standard input, 1 is standard output, and 2 is standard error
        - stdio - fopen(), fclose(), scan(), printf(), fgets(), fputs()
    f. Programs
        - Source-Code - human-readable text
        - Binary - machine-language instructions that a computer can understand
        - Filter - program reads from stdin, performs a transformation, and writes transformed data to stdout
        - CLI Arguments
            - int main(int argc, char *argv[])
            - argc is total number of arguments
            - argv is array of individual arguments
    g. Processes - instance of an executing program
        - Segments
            - Text - instruction of the program
            - Data - static variables used by the program
            - Heap - area from which programs can dynamically allocate extra memory
            - Stack - piece of memory that grows and shrinks as functions are called and returned
        - Create - parent process uses fork() to create child process that inherits parent's data, stack, and heap
        - Process Identifier PID and Parent Process Identifier PPID
        - Termination - _exit() or kill w/ signal
        - IDs
            - Process Real User ID and Real Group ID
            - Effective User ID and Effective Group ID
            - Supplementary Group IDs
        - Privilege Process - effective user id is 0 and bypasses permission restrictions
        - Init - parent of all processes, /sbin/init, creates and monitors a range of processes required by a running system
        - Daemon - special purpose process that is long-lived and runs in the background
        - Environment List - environment variables used to communicate information to processes
        - Resource Limits - setrlimit() to set soft limit and hard limit
    h. Memory Mappings
        - File Mapping - maps a region of a file into the calling process's virtual memory
        - Anonymous Mapping - initialized to 0
    i. Static and Shared Libraries
        - Static - structured bundle of compiled object modules
        - Shared - grabbed by dynamic linker and loaded into memory when needed by program
    j. Interprocess Communication
        - Mechanisms
            - Signals - indicate an event has occurred, "software interrupts"
            - Pipes - transfers data between processes
            - Sockets - transfer data from one process to another, either on same host or different hosts connected by a network
            - File Locking - allows a process to lock regions of a file in order to prevent other processes from reading or updating
            - Message Queues - used to exchange messages (packets of data) between processes
            - Semaphores - used to synchronize the actions of processes
            - Shared Memory - allows two or more processes to share a piece of memory
    k. Threads
        - Processes that share the same virtual memory as well as a range of other attributes
    l. Sessions, Controlling Terminals, and Controlling Processes
        - Session - collection of process groups
        - Controlling Terminal - established when session leader process first opens a terminal device
        - Foreground Process - may read input from terminal and send output to it
        - Background Process
    m. Pseudoterminals
        - Pair of connected virtual devices, known as master and slave with an IPC channel allowing two way data transfer
        - Slave provides an interface that behaves like a terminal, allowing another program to drive the terminal-oriented program connected to slave device
        - Examples Telnet and SSH
    n. Date and Time
        - Real Time - calendar time since Midnight on 01/01/1970
        - Process Time - total amount of CPU time that a process has used since starting
            - System CPU Time - time spent executing code in kernel mode
            - User CPU Time - time spent executing code in user mode
        - Time command - real, system CPU, and user CPU time
    o. Client-Server Architecture
        - Client - asks the server to carry out some service by sending it a request message
        - Server - examines client's request, performs appropriate actions, and then sends a response message back to client
    p. Realtime
        - Extensions - asynchronous I/O, shared memory, memory-mapped files, memory locking, realtime clocks and timers, scheduling policies, realtime signals, message queues and semaphores

Chapter 3: System Programming Concepts
    a. System Calls
        - Goal - controlled entry point into the kernel, allowing a process to request that the kernel perform some action on the process' behalf
        - System Call API
        - System Calls
            - Change the processor state from user mode to kernel mode
            - Set of system calls is fixed
            - Each system call may have a set of arguments that specify information transferred from user space to kernel space and vice-versa
        - Order
            - Application program makes a system call by invoking a wrapper function in the C Library
            - Wrapper function makes system call arguments available to the system by copying arguments into specific registers
            - Wrapper function copies system call number into CPU register %eax
            - Wrapper function executes a trap machine instruction, which causes the processor to switch from user mode to kernel mode and execute code pointed to by location 0x80
            - Kernel invokes system_call() routine
                - Saves register values onto the kernel stack
                - Checks validity of the system call number
                - Invokes appropriate system call service routine using system call number to index a table of all system calls sys_call_table
                - Service routine performs the required task and then returns a result status to system_call() routine
                - Restores register values from the kernel stack and places the system call return value on the stack
                - Returns to the wrapper function
            - Processor switches back to user mode
            - If return value of system call indicates an error, wrapper function sets errno using the value
            - Wrapper function returns to the caller, providing an integer return value indicating the success or failure of the system call
        - Overhead - system calls have a small but appreciable overhead
    b. Library Functions
        - Goal - one of the multitude of functions that constitutes the standard C library
        - Some use system calls and others do not
        - Standard C Library
            - GNU C Library - glibc
            - Version - /lib/libc.so.6
    c. Handling Errors
        - Important - always check status value from system call and library functionss for an error
        - System Call Errors
            - Error is normally indicated by -1
            - Check Example - fd = system call, if (fd == -1) {/* Code to Handle an Error */}
            - Print Error Message - perror() and strerror()
        - Library Function Errors Three Types
            - Return in same way as system calls
            - Set errno to indicate specific error condition aand returns a value other than -1 on error
            - Errno is not used at all
    d. Example Programs in this Book
        - Command-Line Options and Arguments
            - standard getopt() library
        - Common Functions and Header Files
            - Header File - tlpi_hdr.h pg. 51
            - Error Diagnostic Functions - error_functions.h
                - errMsg() - prints a message on standard error
                - errExit() - prints a message on standard error and terminates the program
                - err_exit() - similar to errExit() but does not flush standard output before print error and does not flush stdio buffers or invoke exit handlers
                - errExitEN)() - similar to errExit() but prints error number instead
                - fatal() - used to diagnose general errors, including errors that don't set errno
                - usageErr() - diagnose errors in command-line argument usage
                - cmdLineErr() - diagnose errors in command-line arguments specified to a program
                - Parsing Command Line Arguments
                    - getInt()
                    - getLong()
    e. Portability Issues
        - Feature Test Macros - have header files expose the definitions (constants, function prototypes, and so on) that follow a particular standard
        - System Data Types - pg. 65

Chapter 4: File I/O: The Universal I/O Model
    a. Overview
        - File Descriptor - a usually small, nonnegative number
        - Standard File Descriptors
            - 1 - stdin - STDIN_FILENO
            - 2 - stdout - STDOUT_FILENO
            - 3 - stderr - STDERR_FILENO
        - Key System Calls
            - fd = open(pathname, flags, mode) - opens the file identified by pathname, returning a file descriptor used to refer to the file in subsequent calls e.g. read, lseek, and write
            - numread = read(fd, buffer, count) - reads at most count bytes from the open file referred to by fd and stores them in buffer
            - numwritten = write(fd, buffer, count) - writes at most count bytes from the buffer to the open file referred to by fd
            - status = close(fd) - releases fd and its associated kernel resources
        - Key Code Example - pg. 71 and Linux Workspace tlpi-dist/fileio/copy.c
    b. Universality of I/O
        - open(), read(), write(), and close() are used to perform I/O on all types of files, including devices such as terminal
            - ./copy test test.old - copy a regular file
            - ./copy a.txt /dev/tty - copy a regular file to this terminal
            - ./copy /dev/tty b.txt - copy input from this terminal to a regular file
            - ./copy /dev/pts/16 /dev/tty - copy input from another terminal
    c. Opening a File: open()
        - fn - int open(const char *pathname, int flags, .... /* mode_t mode */);
            - pathname - file to be opened
            - flag - bit mask that specifies the access mode for the file i.e. permissions to be placed, depend on mode, process umask and optional access control list
        - Examples
           - fd = open("startup", O_RDONLY); - open existing file for reading
           - fd = open("myfile", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR); - open new or existing file for reading and writing, truncating to zero bytes, file permissions read-write for owner, nothing for all others
           - fd = open("w.log", O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR); - open new or existing file for writing, writes should always append to end of file
        - File Descriptor returned - if open() succeeds, it should return the lowest number unused file descriptor for the process
        - open() flags argument
            - File Access Mode Flags - only one of these values should be specified in flags
                - O_RDONLY - open for reading only
                - O_WRONLY - open for writing only
                - O_RDWR - open for reading and writing
            - File Creation Flags - control aspects of behavior of the open() call
                - O_CLOEXEC - set the close on-exec flag
                - O_CREAT - create file if it doesn't already exist
                - O_DIRECTORY - fail if pathname is not a directory
                - O_EXCL - with O_CREAT; create file exclusively
                - O_LARGEFILE - used on 32-bit systems to open large files
                - O_NOCTTY - dont let pathname become the controlling terminal
                - O_NOFOLLOW - dont dereference symbolic links
                - O_TRUNC - truncate existing file to zero length
            - File Status Flags
                - O_APPEND - writes are always appended to end of file
                - O_ASYNC - generate a signal when I/O is possible
                - O_DIRECT - file I/O bypasses buffer cache
                - O_DSYNC - provide synchronized I/O data integrity
                - O_NOATIME - don't update file last access time on read
                - O_NONBLOCK - open nonblocking mode
                - O_SYNC - make file write synchronous
        - Errors from open() - if an error occurs open() returns -1 and errno identifies the cause of the error
            - EACCES - file permissions don't allow the calling process to open the file in the mode specified byu the flags or because of directory permissions, the file could not be accessed or the file did not exists and could not be created
            - EISDIR - the specified file is a directory, and the caller attempted to opedn it for writing, which is not allowed
            - EMFILE - the process resource limit on the number of open file descriptors has been reached
            - ENFILE - the system wide limit on the number of open files has been reached
            - ENOENT - the specified file doesn't exists, and O_CREAT was not specified
            - EROFS - the specified file is on a read-only file system and the caller tried to open for writing
            - ETXTBSY - the specified file is an executable file that is currently executing
    d. The creat() System Call
        - fn - int creat(const char *pathname, mode_t mode);
        - Goal - creates and opens a new file with the given pathname, or if the file already exists, opens the file and truncates it to zero length
    e. Reading from a File: read()
        - fn - ssize_t read(int fd, void *buffer, size_t count);
            - count - specifies the maximum number of bytes to read
            - buffer - supplies the address of the memory buffer into which the input data is to be placed, buffer must be at least count bytes long
                - system calls dont allocate memory for buffers that are used to return information to the caller, instead we must pass a pointer to a previously allocated memory buffer of the correct size
            - successful call to read returns the number of bytes actually read, or 0 if end of file is encountered
        - Examples
            - numRead = read(STDIN_FILENO, buffer, MAX_READ);
    f. Writing to a File: write()
        - fn - ssize_t write(int fd, void *buffer, size_t count);
            - count - specifies the maximum number of bytes to write
            - buffer - supplies the address of the memory buffer from which the input data is to be written, buffer must be at least count bytes long
            - successful call to write returns the number of bytes actually written
    g. Closing a File: close()
        - fn - int close(int fd);
        - closes an open file decsriptor, freeing it for subsequent reuse by the process. When a process terminates, all of its open file descriptrs are automatically closed
        - Example
            - if (close(fd) == -1); errExit("close");
    h. Changing the File Offset: lseek()\
        - File Offset - location in the file at which the next redad or write will commence
        - fn - off_t lseek(int fd, off_t offset, int whence);
            - offset - specifies a value in bytes
            - whence - indicates the base point from which offset is to be interpreted
                - SEEK_SET - the file offset is set offset bytes from the beginning of the file
                - SEEK_CUR - the file offset is adjusted by offset bytes relative to the current file descriptor
                - SEEK_END - the file offset is set to the size of the file plus offset. In other words, offset is interpreted with respect to the next byte after the last byte of the file
        - File Holes - a program seeks past the end of a file and then performs I/O, it is possible to write bytes at an arbitrary point past the end of the file, files holes do not take up disk space
            - Advantage - a sparsely populated file consumes less disk space than woul dotherwise be required if the null bytes actually neeeded to be allocated in disk blocks
        - Key Code Example - pg. 84 or tlpi-dist/fileio/seek_io.c
    i. Operations Outside the Universal I/O Model: ioctl()
        - fn - int ioctl(int fd, int request, .... /* argp */);
            - fd - open file descriptor
            - request - control operation to be performed
            - argp - could be anything, typically a pointer to either an integer or a structure

Chapter 5: File I/O: Further Details
    a. Atomicity and Race Conditions
        - Atomicity - kernel guarantees that all of the steps in the operation are completed without being interrupted by another process or thread
        - Race Conditions - a situyation where the result produced by the two processes operating on a shared resource depends in an unexpected way on the relative order in which the processes gain access to the CPU(s)
        - Creating a File Exclusively - use open() with O_CREAT and O_EXCL to guarantee the check for a file and creation are carried out as a single atomic operation
        - Appending Data to A File - use open() with O_APPEND to esnure that the seek to the next byte past the end of the file and the write operation is carried out as a single atomic operation
    b. File Control Operations
        - fn - int fcntl(int ffd, int cmd, ...); - performs a range of control operations on an open file descriptor
    c. Open File Status Flags
        - F_GETFL - retrieves settings like access mode and status flags
    d. Relationship Between File Descriptors and Open Files
        - Per-Process File Descriptor Table - Each Entry
            - a set of flags controlling the operation of the file decsriptor
            - a reference to the open file description
        - System Wide Table of All Open File Descriptions - Each Entry
            - the current file offset (as updated by read() and write(), or by explicitly using lseek())
            - status flags specified when opening the file (i.e. the fl;ags argument to open())
            - the file access mode (read-only, write-only, or read-write)
            - settings relating to signal-driven I/O
            - a reference to the i-node object for this file
        - I-Node Table - Each Entry
            - file type e.g. regular file, socket, or FIFO, and permissions
            - a pointer to a list of locks held on this file
            - various properties of the file, including its size and timestamps relating to different types of file operations
    e. Duplicating File Descriptors
        - fn - int dup(int oldfd) - returns a new descriptor that refers to the same open file description
        - fn - int dup2(int oldfd, int newfd) - makes a duplicate of the file descriptor given in oldfd using the descriptor number supplied in newfd
        - fn - int dup3(int oldfd, int newfd, int flags) - same as dup2, but adds an additional argument, flags, that is a bit mask that modifies the behvaior of the system call
    f. File I/O at a Specified Offset: pread() and pwrite()
        - fn - ssize_t pread(int fd, void *buf, size_t count, off_t offset) - read at the location specified by offset
        - fn - ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset) - writes at the lcoation specified by offset
    g. Scatter-Gather I/O: readv() and writev()
        - fn - ssize_t readv(int fd, const struct iovec *iov, int iovcnt) - reads a contiguous sequence of bytes from the file referred to by the file descriptor fd and places those bytes into the buffers specified by iov
        - fn - ssize_t writev(int fd, const struct iovec *iov, int iovcntl) - gathers data from all buffers specified by iov and writes them as a sequence of contiguous bytes to the file referred to by the file descriptor fd
    h. Truncating a File: truncate() and ftruncate()
        - fn - int truncate(const char *pathname, off_t length) - sets the size of a file to the value specified by length
            - if file is longer than length, excess data is lost
            - if file is shrorter than length, extended by padding with a sequence of null bytes or a hole
    i. Nonblocking I/O
        - if file can't be opened immediately, then open() returns an error instead of blocking
        - after a successful open(), subsequent I/O are also nonblocking
    j. I/O on Large Files
        - _FILE_OFFSET_BITS macro
            - converts all of the relevant 32-bit functions and data types into their 64-bit counterparts e.g. open() with open64()
    k. The /dev/fd Directory - contains filenames of the form /dev/fd/n, where n corresponds to one of the open file descriptors for the process
    l. Creating Temporary Files
        - fn - int mkstemp(char *template) - generates a unique filename based on a template supplied by the caller and opens the file, returning a file decsriptor that can be used with I/O system calls

Chapter 6: Processes
    a. Processes and Programs
        - process - an instance of an executing program
        - program - file containing a range of information that describes how to construct a process at run time
            - binary format identification - metainformation describing the format of the executable file
            - machine language instructions - these encode the algorithm of the program
            - program entry point address - this identifies the location of the instruction at what execution of the program should commence
            - data - values used to initialize variables and also literal constants used by the program
            - symbol and relocation tables - these describe the locations and names of functions and variables within the prorgam. Used for debugging, run-time symbol resolution and more
            - shared library and dynamic linking information - includes fields listing the shared libraries that the program needs to use at run time and the pathname of the dynamic linker that should be used to load these libraries
            - other information - other information to describe how to construct a process
    b. Process ID and Parent Process ID
        - process ID - a positive integer that uniquely identifies the process on the system
            - fn - pid_t getpid(void) - returns the process ID of the calling process
        - parent process ID - a positive integer tha that uniquely identifies the parent process of the process
            - fn - pid_t getppid(void)
    c. Memory Layout of a Process
        - Segment
            - text segment - contains the machine-language instructions of the program run by the process
            - initialized data segment - contains global and static variables that are explicitly initialized
            - uninitialized data segment - contains global and static variables that are not explicity initialized
            - stack - a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function and stores the functions local variables, arguments, and return value
            - heap - an area from which memory can be dynamically allocated at run time. Top end is called program break
    d. Virtual Memory Management
        - Virtual Memory Management - make efficient use of both the CPU and physical memory by exploiting a property that is typical of programs, locality of reference
            - Spatial Locality - tendency of a program to reference memory addresses that are near those that were recently accessed because of sequential processing of instructions, and sometimes, sequential processing of data structures
            - Temporal Locality - tendency of a program to access the same memory addresses in the near future that is accessed in the recent past e.g. because of loops
            - Pages - fixed size units of memory used by programs
            - Unused pages are maintained in the swap area
            - Resident set - the pages present in physical memory page frames
        - Processes Valid Virtual Address Range
            - as the stack grows downward beyond limits previously reached
            - when memory is allocated and deallocated on the heap, by raising the progam break using brk(), sbrk(), or the malloc family of functions
            - when System V shared memory regions are attached using shmat() and detached using shmdt()
            - when memory mappings are created using mmap() and unmapped using munmap()
        - Advantages of Virtual Address Space
            - processes are isolated from one another and from the kernel, so that one process can't read or modify the memory of another process or the kernel
            - where appropriate, two or more processes can share memory
            - the implementation of memory protection schemes is facilitated, that is, page table entries can be marked to indicate that the contents of the corresponding page are readable, writable, executable, or some other combination of these protections
            - programmers, and tools such as the compiler and linker, don't need to be concerned with the physical layout of the program in RAM
            - program loads and runs faster because only a portion needs to reside in memory
    e. The Stack and Stack Frames
        - Stack - grows and shrinks linearly as functions are called and return
            - Stack Pointer - tracks the current top of the stack, each time a function is called, an additional frame is allocatd on the stack, and the frame is removed when the function returns
        - Stack Frame
            - Function Arguments and Local Variables (automatic), they are automatically created when a function is called and they automatically disappear when the function returns
            - Call Linkage Information - each function uses certain CPU registers, such as the program counter, which points to the next machine-language instruction to be executed
    f. Command Line Arguments
        - argc- number of arguments
        - argv - array of pointers to command line arguments as string, each with a null terminated character
        - Important Example: tlpi-dist/proc/necho.c and
        - Review - getopt() in Appendix B
    g. Environment List
        - Environment List/Environment - associated array of strings in the format key=value
        - Accessing the Enviroment From a Program
            - Global Variable - exztern char **environ
            - Important Example: tlpi-dist/proc/display_env.c
            - fn - char *getenv(const char *name) - returns a pointer to the corresponding value string
        - Modifying the Environment
            - fn - int putenv(char *string) - adds a new variable to the calling process's environment or modifies the values of an existing variable, string format is key=value
            - fn - int setenv(const char *name, const char *value, int overwrite) - creates a new environment variable by allocating a memeory buffer for a string of the form name=value, and copying the strings pointed to by name and value into that buffer
            - fn - int unsetenv(const char *name) - removes the variable defined by name from the environment
            - fn - int clearenv(void) - erase the entire environment
    h. Performing a Nonlocal Goto: setjmp() and longjmp()
        - Jumping
            - fn - int setjmp(jmp_buf env) - establishes a target for a later juimp performed by longjmp(), this target is exactly the point where the setjmp() call occurred
            - fn - void longjmp(jmp_buf env, int val) - jumps to location set by setjmp()
            - Important Example: tlp-dist/proc/longjmp.c
        - Abusing longjmp() - don't longjmp into a function that has already returned, SUv3 says that if longjmp is called from within a nested signal handler then the program behavior is undefined
        - Avoid setjmp() and longjmp() where possible

Chapter 7: Memory Allocation
    a. Allocating Memory on the Heap
        - A process can allocate memory by increasing the size of the heap, a variable size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows and shrinks as memeory is llocated and freed. Limit of heap is called program break
        - Adjusting the Program Break: brk() and sbrk()
            - Resizing the heap is as simple as telling the kernel to adjust its idea of where the process's program break is
            - fn - int brk(void *end_data_segment) - sets the program breeak to the location specified by end_data_segment, end_data_segment is effectively roudned up to the next page boundary
            - fn - void *sbrk(intptr_t increment) - adjusts the program break by adding increment to it
        - Allocating Memory on the Heap: malloc() and free()
            - Advantages over brk() and sbrk()
                - standardized as part of the C language
                - easier to use in threaded programs
                - provide a simple interface that allows memory to be allocated in small units
                - allow us to arbitrarily deallocate blocks of memory, which are maintained on a free list and recycled in future calls to allocate memory
            - fn - void *malloc(size_t size) - allocates size bytes from the heap and returns a pointer to the start of the newly allocated block of memory that is not initialized
            - fn - void free(void *ptr) - deallocates the block of memory pointed to by its ptr argument, which should be an address previously returned by malloc()
                - free doesn't lower the program break, instead adds the block of memory to a list of free blocks that are recycled by future calls to malloc()
        - Implementations of malloc() and free()
            - malloc() - first scans the list of memory blocks previsouly released by free() in order to find one whose size is larger or equal to its requirement
                - if no block on the free list is large enough, then malloc() calls sbrk() to allocate more memory, memory is more that bytes required
        - Tools and Libraries for malloc debugging
            - mtrace() and muntrace() allow a program to turn tracing of memory allocation calls on and off
            - mcheck() and mprobe() allow a program to perform consistency checks on blocks of allocated memory
            - MALLOC_CHECK_ environment variable serves a similar purpose to mcheck() and mprobe()
        - Controlling and Monitoring the malloc package
            - mallopt() modifies the various parameters that control the algorithm used by malloc()
            - mallinfo() returns a structure containing various statistics about the memory allcoated by malloc()
        - Other Methods of Allocating Memory on the Heap
            - fn - void *calloc(size_t numitems, size_t size) - allocates memory for an array of identical items
            - fn - void *realloc(void *ptr, size_t size) - used to resize a block of memory previously allocated by one of the functions in the malloc package
        - Allocating Aligned Memory: memalign() and posix_memalign()
            - fn - void *memalign(size_t boundary, size_t size) - allocates size bytes starting at an address aligned to a multiple of boundary, which must be a power of two
            - fn - int posix_memalign(void **memptr, size_t alignment, size_t size) - 
    b. Allocating Memory on the Stack
        - fn - *alloca(size_t size) - allocates memory dynamically, however, instead of obtaining memory from the heap, alloca() obtains memory from the stack by incressing the size of the stack frame

Chapter 8: Users and Groups
    a. The Password File: /etc/passwd
        - /etc/passwd - system password file, contains one line for each user account on the system, it is composd of seven fields separated by a colon
        -  mtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash
            - mtk - login name, unique name that the user must enter in order to log in
            - x - encrypted password, field contains a 13 character encrypted password, if shadow passwords have been enabled, it just contains the letter x
            - 1000 - user id, numeric ID for the user
            - 100 - group id, numeric id for the first of the groups the user is a member of
            - Michael Kerrisk - comment, holds text about the user
            - /home/mtk - home directory, initial directory into which the user is placed after logging in
            - /bin/bash - login shell, program to which control is transferred once the user is logged in
    b. The Shadow Password File: /etc/shadow
        - Historically, UNIX systems maintained all user information, including the encrypted password, in /etc/passwd, which presented a security problem
        - /etc/shadow - was devised as a method of preventing attacks on passwords, encrypted file
    c. The Group File: /etc/group
        - the set of groups to which a user belongs is defined by the combination of the group ID field in the user's password entry and the groups under which the user is listed in the group file
        - group file contains one line for each group in the system and each line consists of four colon-separated fields
            - users:x:100
            - jambit:x:106:claus, felli, frank, harti, markus,martin,mtk,paul
                - jambit - group name, name of the grop
                - x - encyrpted passworde
                - 106 - group id, numeric id for the group
                - claus, felli, frank, harti, markus, martin, mtk, paul - user list, comma separatedlist of names of the users who are members of this group
    d. Retrieving User and Group Information
        - Retrieving Record from the Password File
            - fn - struct passwd *getpwnam(const char *name) - given a login name in name, returns a pointer to a structure of the following type, containing the corresponding information from the password record:
            - fn - struct passwd *getpwuid(uid_t uid); - returns exactly the same information as getpwnam, but does the lookup using the numeric user id
                - struct passwd {
                    char *pw_name; // login name
                    char *pw_passwd; //encrypted password
                    uid_t pw_uid; // user id
                    gid_t pw_gid; // group id
                    char *pw_gecos; //comment
                    char *pw_dir; // initial working directory
                    char *pw_shell; // login shell
                }
        - Retrieving Records from the Group File
            - fn - struct group *getgrnam(const char *name) - looks up group information by group name, returns a pointer to a structure of the following type
            - fn - struct group *getgrgid(gid_t gid) - returns exactly the same information as getgrnam, but does the look up by numeric group id
                - struct group {
                    char *gr_name; // group name
                    char *gr_passwd; // encrypted password
                    gid_t gr_gid; // group id
                    chasr **gr_mem; // array of pointers to names of members listed in the /etc/group
                }
        - Scanning All Records in the Password and Group Files
            - fn - struct passwd *getpwent(void); - returns all records from the password file one by one, returning null when there are no more records
            - fn - void setpwent(void); - restart from the beginning of the password file
            - fn - void endpwent(void); - closes the password file
            - fn - struct passwd *getgrent(void); - returns all records from the group file one by one, returning null when there are no more records
            - fn - void setgrent(void); - restart from the beginning of the group file
            - fn - void endgrent(void); - closes the group file
        - Retrieiving Records from the Shadow Password File
            - fn - struct spwd *getspname(const char *name); - given a login name, returns a pointer to a structure of the following type
                - struct spwd {
                    char *sp_name; // login name
                    char *sp_pwdp; // encrypted password

                    long sp_lstchg; // time of last password change
                    long sp_min; // min number of days between password changes
                    long sp_max; // max number of days before change of password is required
                    long sp_warn; // number of days beforehand that a user is warned of upcoming password expiration
                    long sp_intact; // number of days after expiration that account is considered inactive and locked
                    long sp_expire; // date when account expires
                    unsigned long sp_flag; // reserved for future use
                }
            - fn - struct spwd *getspent(void); - returns all records from the shadow password file
            - fn - void setspent(void); - restart from the beginning of the shadow password file
            - fn - void endspent(void); - closes the shadow password file
    e. Password Encryption and User Authentication
        - Form #1 - application require authentication and manages its own database of usernames and passwords for this purpose
        - Form #2 - allowing users to enter their information as defined in /etc/passwd and /etc/shadow
        - For security reasons, UNIX systems encrypt passwords using a one-way encryption algorithm, which means that there is no method of recreating the original password from its encrypted form
        - The only way of validating the password is to encrypt it using the same method and see if the encrypted result matches the value stores in /etc/shadow
        - fn - char *crypt(const char *ley, const char *salt) - takes a key (i.e. a password) of up to 8 characters, and applies a variation of the Data Encryption Standard algorithm to it.
            - The salt argument is used to vary the algorithm, the 2-char salt argument can cause the encryption algorithm to vary in any of 64*64=4096 ways, causing cracker to need to check the password against 4096 encrypted versions of the dictionary

Chapter 9: Process Credentials
    a. Real User ID and Real Group ID
        - Real User and Group IDs - identify the user and group to which the process belongs
            - As part of the login process, a login shell gets its real user and group IDs from the third and fourth fields of the user's password record in /etc/passwd
    b. Effective User ID and Effective Group ID
         - Effective User and Group IDs - in conjunction with the supplementary group IDs, are used to determine the permissions granted to a process when it tries to perform various operations
    c. Set-User-ID and Set-Group-ID Programs
        - set-user-ID program allows a process to gain privileges it would not normally have by setting the process's effective user ID to the same value as the user ID of the executable
    d. Saved Set-User-ID and Saved Set-Group-ID
        - Saved Set User and Group IDs - are designed for use with set-user-ID and set-group-ID programs. When a program executes:
            - if the set-user-id or set-group-id permission bit is enabled on the executable, then the effective user (group) ID of the process is made the same as the owner of the executable
            - If the set-user-id or set-group-id permission bit is not enabled, then no change is made
            - values for saved set-user-ID and saved set-group-ID are copied from the corresponding effective IDs
    e. File-System User ID and File-System Group ID
        - On Linux, it is the file-system user and group IDs, rather than the effective user and group IDs, that are used in conjunction with supplementary group IDs to determine permissions when performing file-system operations such as opening files, changing file ownership, and modifying file permissions
    f. Supplementary Group IDs - set of additional groups to which a process belongs, a process inherits these IDs from its parent
    g. Retrieving and Modifying Process Credentials
        - Retrieving and Modifying, Real, Effective, and Saved Set IDs
            - Retrieving Real and Effetive IDs
                - fn - uid_t getuid(void) - returns the real user ID of the calling process
                - fn - uid_t getgid(void) - returns the real group ID of the calling process
                - fn - uid_t geteuid(void) - returns the effective user ID of the calling process
                - fn - uid_t getegid(void) - returns the effective group ID of the calling process
            - Modifying Effective IDs
                - fn - int setuid(uid_t uid) - changes the effective user ID, and possible the real user ID and saved set-user-ID
                    - if an unprivileged process calls setuid(), only the effective user ID of the process is changed, and can only be changed to the same value as either the real user ID or saved set-user-ID
                    - if a privileged process calls setuid(), real, effective, and saved set-user IDs are all set to the value specified in the uid argument
                - fn - int setgid(gid_t gid) - changes the effective group ID, and possible the real group ID and saved set-group-ID
                    - rule 1 applies like above
                    - privileged programs can user setgid() to freely change the group ID to any desired values
                - fn - int seteuid(uid_t euid) - changes effective user ID
                    - if an unprivilegde process calss seteuid(), only the effetive user ID of the process is changed, and can only be changed to the corresponding real or saved set ID
                    - if a privleged process calss seteuid(), can change effective ID to any value
                - fn - int setegid(gid_t egid) - changes effective group ID
            - Modifying Real and Effective IDs
                - fn - int setreuid(uid_t ruid, uid_t euid) - allow process to change real and effetive user ID
                    - unprivileged process can set the real user ID only to the current value of the real or effective user ID, and the effective user ID can only be set to the current avlue of the real user ID, effective user ID, or saved set-user-ID
                    - privileged process can make any changes to the IDS
                    - for both, the saved set-user-ID is also set to the same value as the effective user ID
                - fn - int setregid(gid_t rgid, gid_t egid) - allow process to change real and effective group ID
            - Retrieving Real, Effective, and Saved Set IDs
                - fn - int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid) - returns the current value of the calling processes real, effective, and saved set user IDs
                - fn - int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid) - returns the current value of the calling processes real, effective, and saved set group IDs
            - Modifying Real, Effective, and Saved Set IDs
                - fn - int setresuid(uid_t ruid, uid_t euid, uid_t suid) - allows process to change real, effective, and saved set user IDs
                - fn - int setresgid(gid_t rgid, gid_t egid, gid_t sgid) - allows process to change real, effective, and saved set group IDs
            - Retrieving and Modifying File-System IDs
                - fn - int setfsuid(uid_t fsuid) - changes the file-system user ID of a process to the value specified by fsuid
                    - unprivileged process can set the file-system user ID to the current value, the real user ID, effective user ID, file-system user ID, or saved set-user-ID
                    - privileged process can set the file-system user ID to any value
                - fn - int setfsgid(gid_t fsgid) - changes the file-system group ID of a process to the value specified by fsuid
        - Retrieving and Modifying Supplementary Group IDs
            - fn - int getgroups(int gidgetsize, gid_t grouplist[]) - returns the set of groups of which the calling process is currently a member, in the array pointed to by grouplist
            - fn - int setgroups(size_t gidsetsize, const gid_t *grouplist) - replaces the calling process's supplementary group IDs with the set given in the array grouplist
            - fn - int initgroups(const char *user, gid_t group - ) - initializes the process's supplmentary group IDs by scanning /etc/group and building a list of all groups of which the named user is a member

Chapter 10: Time
    a. Types of Time
        - Real Time - time as measured either from some standard point (calendar time) or form some fixed point in the life of a process
        - Process Time - amount of CPU time used by a process
    b. Calendar Time
        - fn - int gettimeofday(struct timeval *tv, struct timezone *tz) - returns the calendar time in the buffer pointed to by tv
            - tv argument is a pointer to a structure of the following form
                - struct timeval {
                    time_t tv_sec; /* Seconds since 00:00:00, 1 Jan 1970 UTC,
                    suseconds_t tv_usec; /* Additional microseconds */
                }
        - fn - time_t time(time_t *timep) - returns the number of seconds since Epoch i.e. the same value that gettimeofday() returns
    c. Time Conversion Functions
        - Converting time_t to Printable Form
            - fn - char *ctime(const time_t *timep) - returns a 26 byte string containing the date and time in a standard format e.g. Wed Jun 8 14:@2:34 2011
        - Converting Between tim_t and Broken-Down Time
            - fn - struct tm *gmtime(const time_t *timep) - converts a calendar time into a broken down time corresponding to UTC
            - fn - struct *localtime(const time_t *timep) - covnerts a calendar time into a broken down time that takes into account timezone and DST settings
                - struct tm {
                    int tm_sec; /* Seconds (0-60) */,
                    int tm_min; /* Minutes (0-59) */,
                    int tm_hour; /* Hours (0-23) */,
                    int tm_mday /* Day of the Month (1-31) */,
                    int tm_mon; /* Month (0-11) */,
                    int tm_year; /* Year Since 1900 */,
                    int tm_wday; /* Day of the Week (Sunday = 0) */,
                    int tm_yday; /* Day in the Year (0-365m; Jan 1 = 0) */,
                    int tm_isdst; /* Daylight Savings Time Flag */,
                }
        - Converting Between Broken Down Time and Printable Form
            - Converting from Broken-Down Time to Printable Form
                - fn - char *asctime(const struct tm *timeptr) - returns a pointer to a statically allocated string containing the time in the same form as ctime()
                - fn - size_t strftime(char *outstr, size_t maxsize, const char *format, const struct tm *timeptr) - gioven a broken down time pointed to by timeptr, strftime plcaes a corresponding null terminated, date-plus-time string in the buffer allocated by outstr
                - fn - char *currTime(const char *format) - returns a string containing the current time as formatted by strftime() when given the argument format
            - Converting From Printable Form to Broken-Down Time
                - fn - char *strptime(const char *str, const char *format, struct tm *timeptr) - converts a date-plus-time string to a broken down time
    d. Timezones
        - Timezone Definitions - timezone information are stored in /usr/share/zoneinfo, where each file contains information about the timezone regime in a particular country or region
        - Local Time for the system is defined by the timezone file /etc/localtime which is often linked to one of the files in /usr/share/zoneinfo
        - Specifying Timezone for a Program
            - Set the TZ environment variable to a string consisting of a colon followed by one of the timezone names defined in /user/share/zoneinfo
            - Setting TZ influences ctime(), localtime(), mktime() and strftime()
            - fn - tzset(), initializes three global variables
                - char *tzname[2]; - /* Name of timezone and alternate (DST) timezone */
                - int daylight; - /* Nonzero if there is an alternate (DST) timezone */
                - long timezone; - /* Seconds difference between UTC and local standard time */
    e. Locales
        - Locale - subset of a user's environment that depends on language and cultural conventions
        - Internationalization - programs designed to run in more than one locale should deal with locales in order to display and input information in the user's preferred langauge and format
        - Locale Definitions - information is maintained in a directory hierarchy under /usr/share/locale or /usr/lib/locale
            - language[_territory[.codeset]][@modifier]
            - Contenst of Locale Specific Subdirectories
                - LC_CTYPE - A file contianing character classiciations and rules for case conversion
                - LC_COLLATE - A file containing the collation rules for a character set
                - LC_MONETARY - A file containing formatting rules for monetary values
                - LC_NUMERIC - A file containing formatting rules for numbers other than monetary values
                - LC_TIME - A file containing formatting rules for dates and times]
                - LC_MESSAGES - A directory containing files specifying formats and values used for affirmative and negative (yes/no) responses
        - Specifying the Local for a Progam
            - fn - char *setlocale(int category, const char *locale) - used to both set and query a program's current locale
    f. Updating the System CLock
        - fn - int settimeofday(const struct timeval *t, const struct timezone *tz) - sets the system's calendar time to the number of seconds and microseconds specified in the timeval structure pointed to by tv
        - fn - int adjtime(struct timeval *delta, struct timeval *olddelta) - causes the system to gradually adjust to the desired valuer
    g. The Software Clock
        - Jiffies - size of jiffy is defined by the constant HZ within the kernel source code
            - Clock rate cna be set to 100, 250, or 1000 hertz, giving jiffy values of 10, 4, and 1 milliseconds respectively
    h. Process Time
        - User CPU Time - amout of time spent executing in user mode, sometimes referred to as virtual time
        - System CPU Time - amoutn of time spent executing in kernel mode
        - fn - clock_t time(struct tms *buf) - retrieves process time information, returning it in the structure pointed to by buf
            - struct tms {
                clock_t tms_utime; /* User CPU time used by caller */
                clock_t tms_stime; /* System CPU time used by caller */
                clock_t tms_cutime; /* User CPU time of all (waited for) children */
                clock_t tms_cstime; /* System CPU time of all (waited for) children */
            }
        - fn - clock_t clock(void) - retrieves process time, a single value that measures the total (i.e. user+system) CPU time used by the calling process

Chapter 11: System Limits and Options
    a. Quick Facts
        - Examples:
            - How many files can a process hold open at one time?
            - Does the system support realtime signals?
            - What is the largest value that can be stored in a variable of type int?
            - How big an argument list can a program have?
            - What is the maximum length of a pathname?
        - Variances
            - Across UNIX implementations
            - At run time on a particular implementation
    b. System Limits
        - Minimum Value - defines an upper limit on some resource or feature, a system must support at minimum, a max value of something for a feature
        - Maximum Value - defines a lower limit on some resource or feature, a system may support at maximum, a minimum value of something for a feature
        - Format - constant in <limits.h> with a name prefixed by a string _POSIX_XXX_MAX or _POSIX_XXX_MIN
        - Runtime Invariant Values - limit whose value, if defiend in <limits.h>, is fixed for the implementation, however the value may be indeterminate
        - Pathname Variable Values - limits that relate to pathnames (files, directories, terminals, and so on)
        - Runtime Increasable Values - limit that has a fixed minimum value for a particular implementation, and all the systems running the implementation will provide at least this minimum value, however a system may increase this limimt at run time
        - Summary of Select SUSv3 Limits
            - ARG_MAX - _SC_ARG_MAX - maximum bytes for arguments (argv) plus environment (environ) that can be supplied to exec()
            - _SC_CLK_TCK - unit of measurement for time
            - LOGIN_NAME_MAX - _SC_LOGIN_NAME_MAX - maximum size of a login name (including terminmating null byte)
            - OPEN_MAX - _SC_OPEN_MAX - maximum number of file decsriptors that a process can have open at one time, and one greater than maximum usable descriptor number
            - NGROUPS_MAX - _SC_NGROUPS_MAX - maximum number of supplementary groups of which a process can be a member
            - _SC_PAGESIZE - size of a virtual memory page
            - RTSIG_MAX - _SC_RTSIG_MAX - maximum number of distinct realtime signals
            - SIGQUEUE_MAX - _SC_SIGQUEUE_MAX - maximum number of queued realtime signals
            - STREAM_MAX - _SC_STREAM_MAX - maximum number of stdio streams that can be open at one time
            - NAME_MAX - _PC_NAME_MAX - maximum number of bytes in a filename excluding terminating null byte
            - PATH_MAX - _PC_PATH_MAX - maximum number of bytes in a pathname, including terminating null byte
            - PIPE_BUF - _PC_PIPE_BUF - maximum number of bytes that can be written atomically to a pipe or FIFO
        - Determining Limits and Options From the Shell: getconf
            - getconf variable-name [pathname] - obtain the limits implemented by a particular UNIX implementation
    c. Retrieving System Limits and Options at Run Time
        - fn - long sysconf(int name) - allows an application to obtain the values of system limits at run time, name argument is one of the _SC_* constants defined in <unistd.h>
    d. Retrieivng File-Related Limits and Options at Run Time
        - fn - long pathconf(const char *pathname, int name) - allow an application to obtain the values of file-related limits at run time
        - fn - long fpathconf(int fd, int name) - allow an application to obtain the values of file-related limits at run time
    e. Indeterminate Limits - we may find that some system limit is not defined by an implementation limit constant, and that sysconf() or pathconf() informs us that the limit is indeterminate
        - Strategies
            - we could elect to use the minimum limit value specified by SUSv3, constants with the names of the form _POSIX_XXX_MAX
            - ignore checking the limits and instead perform the relevant system or library function call
            - write our own program or function to either deduce or estimate the limit
            - employ a tool such as GNU Autoconf, an extensible tool that can determine the existence and settings of various systems features and limits
    f. System Options
        - Example - support for features such as realtime signals, POSIX shared memory, job control, and POSIX threads
        - Option Constant Values
            - -1 means that the option is not supported
            - 0 means that the option may be supported
            - >0 means that the option is supported
        - SUSv3 Options
            - _POSIX_ASYNCHRONOUS_IO or _SC_ASYNCHRONOUS_IO - Asynchonous I/O
            - _POSIX_CHOWN_RESTRICED or _PC_CHOWN _RESTRICTED - Only privileged processes can use chown() and fchown() to change the user ID and group ID of a file to arbitrary values
            - _POSIX_JOB_CONTROL or _SC_JOB_CONTROL - Job Control
            - _POSIX_MESSAGE_PASSING or _SC_MESSAGE_PASSING - POSIX Message Queues
            - _POSIX_PRIORITY_SCHEDULING  or _SC_PRIORITY_SCHEDULING - Process Scheduling
            - _POSIX_REALTIME_SIGNALS or _SC_REALTIME_SIGNALS - Realtime Signals Extension
            - _POSIX_SAVED_IDS - Processes have saved set-user-IDs and saved set-group-IDs
            - _POSIX_SEMAPHORES or _SC_SEMAPHORES - POSIX Semaphores
            - _POSIX_SHARED_MEMORY_OBJECTS or _SC_SHARED_MEMORY_OBJECTS - POSIX Shared Memory Objects
            - _POSIX_THREADS or _SC_THREADS - POSIX Threads
            - _XOPEN_UNIX or _SC_OPEN_UNIX - The XSI extension is supported
    
Chapter 12: Ssytem and Process Information
    a. The /proc File System
        - /proc virtual fiel system - resides under /proc, is dynamically written as processes are created, and contains various files that expose kernel information and change it in some cases
        - Obtaining Information About a Process: /proc/PID
            - For each process on the system, the kernel provides a corresponding directory named /proc/PID, where PID is the ID of the process - /proc/1 is data pertaining to init process
            - Example of Information Provided
                - Name: init - name of command run by the process
                - State: S - state of the process
                - Tgid: 1 - thread group ID
                - Pid: 1 - actually, thread ID
                - PPid: 0 - parent process ID
                - TracerPid: 0 - PID of tracing process
                - Uid: 0 0 0 0 - real, effective, saved-set, and FS UID
                - Gid: 0 0 0 0 - real, effective, saved-set, and FS GIDs
                - FDSize: 256 - # of file descriptor slots currently allocated
                - Groups: - supplmentary group IDs
                - VMPeak: 852kB - peak virtual memory size
                - VmSize: 724kB - current virutal memory size
                - VmLck: 0kB - locked memory
                - VmHWM: 288kB - peak resident set size
                - VmRSS: 288kb - current resident set size
                - VmData: 148kB - data segment size
                - VmStk: 88kB - stack size
                - VmExe: 484kB - text size
                - VmLib: 0kB - shared library code size
                - VmPTE: 12kB - size of page table
                - Threads: 1 - # of threads in this thread's thread group
                - SigQ: 0/3067 - current/max queued signales
                - SigPnd: 0000000000000 - signals pending for thread
                - ShdPnd: 0000000000000 - signals pending for process
                - SigBlk: 0000000000000 - blocked signals
                - SigIgn: 0000000000000 - ignored signals
                - SigCgt: 0000000000000 - caught signals
                - CapInh: 0000000000000 - inehritable capabilities
                - CapPrm: 0000000000000 - permitted capabilities
                - CapEff: 0000000000000 - effective capabilities
                - CapBns: 0000000000000 - capability bonding set
                - Cpus_allowed: 1 - CPUs allowed, mask
                - Cpus_allowed_list: 0 - Same as above, list format
                - Mems_allowed: 1 -  Memory nodes allowed, mask
                - Mems_allowed_list: 0 - Same as above, list format
                - voluntary_ctxt_switches: 6998 - voluntary context switches
                - nonvoluntary_ctxt_switchs: 107 - involuntary context switches
                - Stack usage:  8 kB
        - Selected fiels in each /proc/PIUD directory
            - cmdline - command line arguments delimted by \0
            - cwd - symbolic link to current working directory
            - environ - enviroment list NAME=value pairs, delimited by \0
            - exe - symbolic link to file being executed
            - fd - directory containing symbolic links to files opened by this process
            - maps - memory mappings
            - mem - process virtual memory
            - mounts - mount points for this process
            - root - symboli clink to root directory
            - status - various information e.g. process IDs, credentials, memory usage, signals
            - task - contains one sub directory for each thread in process
        - The /proc/PID/fd directory - /proc/1968/fd/1 - is a symboli clink to the standard output of process 1968
        - Threads: the /proc/PID/task directory - /proc/PID/task/TID - subdirectory for each thread in PID process
        - System Information Under /proc
            - /proc - various system information
            - /proc/net - status information about networking and sockets
            - /proc/sys/fs - settings related to file systems
            - /proc/sys/kernel - various general kernel settings
            - /proc/sys/net - networking and socket settings
            - /proc/sys/vm - memory management settings
            - /proc/sysvipc - information about system V IPC objects
        - Accessing /proc Files - often accessed using shel scripts
        - Accessing fiels in /proc/PID - be careful accessing, plan for possibility process has terminated
    b. System Identification: uname()
        - fn - int uname(struct utsname *utsbuf) - returns a range of identifying information about the host system on which an application is running, in the structure pointed to by utsbuf
            - struct utsname {
                char sysname[_UTSNAME_LENGTH]; - /* Implementation Name */
                char nodename[_UTSNAME_LENGTH]; - /* Node name on the network */
                char release[_UTSNAME_LENGTH]; - /* Implementation release level */
                char version[_UTSNAME_LENGTH]; - /* Release version level */
                char machine[_UTSNAME_LENGTH]; - /* Hardware on which system is running */
                char domainname[_UTSNAME_LENGTH]; - /* NIS domain of the host */
            }
        - fn - sethostname() - sets nodename above
        - fn - setdomainname() - sets domainname above

Chapter 13: File I/O Buffering
    a. Kernel Buffering of File I/O: The Buffer Cache
        - read() and write() don't directly initiate disk access, instead they simply copy data from a user-space buffer and a buffer in the kernel called the buffer cache
        - Effect of Buffer Size on I/O System Call Performance
            - > Buffer Size, up to 1024 bytes, the faster the I/O is performed
            - Elapsed, Total CPU, User CPU, and System CPU is measured
    b. Buffering in the stdio Library
        - Topic: buffering of data into large blocks to reduce system calls is exactly what is done by the C library I/O functions e.g. fprintf(), fscanf(), fgets(), fputs(), fputc(), fgetc()
        - Setting the Buffering Mode of A Stdio Stream
            - fn - int setvbuf(FILE *stream, char *buf, int mode, size_t size) - controls the form of buffering employed by the stdio library
            - buf argument
                - buf is NULL - stdio library automatically allocates a buffer for use with stream
                - buf is non-NULL - points to a block of memory of size bytes that is used as the buffer for stream
            - mode argument
                - _IONBF - don't buffer I/O, each stdio library call results in an immediate write() or read() system call
                - _IOLBF - employ line-buffered I/O
                - _IOFBF - employ fully buffered I/O
            - fn - void setbuf(FILE *stream, char *buf) - controls form of buffering employed
            - fn - void setbuffer(FILE *stream, char *buf, size_t size) - controls form of buffering employed
        - Flushing a stdio buffer
            - fn - int fflush(FILE *stream) - force the data in a stdio output stream to be written i.e. flushed to a kernel buffer via write()
    c. Controlling Kernel Buffering of a File I/O
        - Synchronized I/O Data Integrity and Synchronized I/O File Integrity
            - Synchronized I/O Completion - means an I/O operation that has either been successfully transferrred to the disk or diagnosed as unsuccessful
                - Syncrhonized I/O Data Integrity Completion - ensuring that a file data update transfers sufficient information to allow a later retrieval of that data to proceeed
                - Synchronized I/O File Integrity Completion - during a file update, all updated file metadata is transferred to disk, even if it si not necessary for the operation of a subsequent read of the file data
        - System Calls for Controlling Kernel Buffering of FIle I/O
            - fn - int fsync(int fd) - causes the buffered data and all metadata associatd with the open file descriptor fd to be flushed to disk
            - fn - int fdatasync(int fd) - only forces the file to the synchronized I/O data integrity completion state
            - fn - void sync(void) - causes all kernel buffers containing updated file information to be flushed to disk
        - Making All Writes Synchronous
            - Specifying the O_SYNC flag when calling open() makes all subsequent output synchronous
    e. Summary of I/O Buffering
        - User Data -> stdio Library Calls printf(), fputc(), etc -> stdio buffer -> I/O system calls write(), etc -> Kernel Buffer Cache -> Kernel Initiated Write -> Disk
    f. Advising the Kernel About I/O Patterns
        - fn - int posix_fadvise(int fd, off_t offset, off_t len, int advice) - allows a process to inform the kernel about its likely pattern for accessing file data
            - advice argument
                - POSIX_FADV_NORMAL - process has no special advice to give about access patterns
                - POSIX_FADV_SEQUENTIAL - process expects to read data sequentially from lower offsets to higher offsets
                - POSIX_FADV_RANDOM - process expects to access the data in random order
                - POSIX_FADV_WILLNEED - process expects to access the specified file region in the near future
                - POSIX_FADV_DONTNEED - process expects not to access the specified file region in the near future
                - POSIX_FADV_NORESUE - process expects to access data in the specified file region once, and then not to reuse it
    g. Bypassing the Buffer Cache: Direct I/O
        - Direct I/O - an application bypasses the buffer cache wehen performing disk I/O, thus transferring data directly from user space to a file or disk device
            - specify the O_DIRECT flag when opening a file or device with open()
        - Alignment Restrictions for Direct I/O
            - The data buffer being transferred must be aligned on a memory boundarythat is a multiple of the block size
            - The file or device offset at which data transfer commences must be a multiple of the block size
            - The length of the data to be transferred must be a multiple of the block size
    h. Mixing Library Functions and System Calls for File I/O
        - fn - int fileno(FILE *stream) - returns the corresponding file descriptor
        - fn - FILE *fdopen(int fd, const char *mode) - given a file descriptor, it creates a corresponding stream that uses this descriptor for its I/O

Chapter 14: File Systems
    a. Device Special Files
        - Device Special File - corresponds to a device on the system
        - Each device type has a corresponding device driver, which handles I/O requests for the device
        - API provided by device drivers is fixed and includes operations corresponding to the system calls open(), close(), reade(), write(), mmap(), and ioctl()
        - Device Types
            - Character Devices - handle data on a character by character basis. Terminals and keyboards are examples of charactber devices
            - Block Devices - handle data a block at a time
        - Device IDs
            - Major ID Number - identifies the general class of device, and is used by the kernel to look up the appropriate driver for this type of device
            - Minor ID Number - uniquely identifies a particular device within a general class
    b. Disks and Partitions
        - Disk Drives - hard disk drive is a mechanical device consisting of one or more platters that rotate at high speed
        - Dis Partitions - each disk is divided into one or more (nonoverlapping) partitions. Each partition is treated by the kernel as a separate device residing under the /dev directory
        - Disk Partition Contains
            - file system holding regular files and directories
            - a data area accessed as raw mode device
            - a swap area used by the kernel for memeory management
    c. File Systems - organized collection of regular files and directories
        - Examples - ext2, Minix, System V, and BSD, FAT, FAT32, NTFS, ISO 9660 CD-ROM, HFS, NFS, SMB, NCP, Coda, ext3, ext4, Reiserfs, JFS, XFS, and Btrfs
        - File Sytem Structure
            - Logical Block - basic unit for allocating space in a file system, some multiple of contiguous physical blocks on the disk device e.g. 1024, 2048,, or 4096
            - Boot Block - contains information used to boot the operating system
            - Superblock - single block, contains parameter information about the file system, including:
                - the size of the i-node table
                - the size of logical blcoks in this file system
                - the size of the file system in logical blocks
            - I-node Table - each file or directory has a unique entry in the i-node table, this entry records varioous informations about the file
            - Data Blocks - the great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system
    e. I-nodes
        - Data Contained
            - File type e.g. regular file, directory, symbolic link, characer device
            - Owner
            - Group
            - Access Permissions - U,G,O
            - Three Timestamps
                - time of last access to the file
                - time of last modification of the file
                - time of last status change
            - Number of hard links to the file
            - Size of the file in bytes
            - NUmber of blocks actually allocated to the file, measured in 512 bytes
            - Pointers to the data blocks of the file
        - I-nodes and Data Block Pointers\
            - Important - ext2 doesn't store the data blocks of a file contiguosly or even in sequential order, the kernel maintains a set of pointers in the i-node
            - First 12 - point to first 12 blocks of the file
            - 13th - pointer to a block of pointers that gives the location of the 13th and subsequent data blocks of the file (pointers depends on size, 4 bytes so 256 pointers for a 1024 byte block)
            - 14th - double indirect pointer - points to blocks of pointers that in turn point to blocks of pointers that in turn point to data blocks of the file
    f. The Virtual File System - kernel featrure that creates an abstraction layer for file-system operations
        - Ideas
            - The VFS defines a generic interface for file-system operations. All programs that work with files specify their operations in terms of this generic interface
            - Each file system provides an implementation for the VFS interface
            - Interface Operations for: open(), read(), write(), lseek(), close(), truncate(), stat(), mount(), umount(), mmap(), mkdir(), link(), unlink(), symlink(), and rename()
    g. Journaling File Ssystem 
        - Goal - eliminate the need for length file-system consistency checks after a system crash
        - Journaling - logs all metadata updates to a special on-disk journal file before they are actually carried out. Updates are logged in groups of related metadata updates
            - In the event of system crash, on system reboot, the log can be used to rapildy redo any incomplete updates and bring the file system bnack to a consistent state
        - Journaling File Systems - Reiserfs, ext3, JFS, XFS, ext4, Btrfs
    h. Single Directory Hierarchy and Mount Points
        - File systems are mounted under the root directory and appear as subtrees within the overall hierarchy
    i. Mounting and Unmounting File Systems
        - Files On Mounted or Mountable
            - /proc/mounts - lis the currently mounted file systems
            - /etc/mtab - contains information that is similar but slightly more detailed, including the file system-specific options given to mount()
            - /etc/fstab - maintained manually by the system administrator, contains descriptions of all of the available file systems on a system
            - File Format
                - /dev/sda9 /boot ext3 rw 0 0
                    - /dev/sda9 - name of the mounted device
                    - /boot - mount point for the device
                    - ext3 - file system type
                    - rw - moutn flags
                    - 0 - used to control the operastion of file system backups by dump()
                    - 0 - used to control the order in which fsck() checks file systems at system boot time
        - Mounting a File System: mount()
            - fn - int mount(const char *source, const char *target, const char *fstype, unsigned long mountflags, cosnt void *data) - mounts the file system contained on the device specified by source under the directory specified by target
            - mount flags
                - MS_BIND - create a bind mount
                - MS_DIRSYNC - make directory updates synchronous
                - MS_MANDLOCK - permit mandatory locking of files
                - MS_MOVE - atomically move mount point to new location
                - MS_NOATIME - don't update last access time for files
                - MS_NODEV - don't allow access to devices
                - MS_NODIRATIME - don't update last access time for directories
                - MS_NOEXEC - don't allow programs to be executed
                - MS_NOSUID - disable set-user-ID and set-group-ID programs
                - MS_RDONLY - read only mount file
                - MS_REC - recursive mount
                - MS_RELATIME - update last access time only if older than last modification time or last status change time
                - MS_REMOUNT - remount with new mountflags and data
                - MS_STRICTATIME - always update last access time
                - MS_SYNCHRONOUS - make all file and directory updates synchronous
        - Unmounting a File System: umount() and umount2()
             - fn - int mount(const char *target) - unmounts a mounted file system
             - fn - int umount2(const char *target, int flags) - allows finer control over unmount operations via the flags argument
    j. Advanced Mount Features
        - Mounting a File System at Multiple Mount Points
        - Stacking Multiple Mounts on the Same Mount Point
        - Mount Flags that Are Per Mount Options
        - Bind Mounts
        - Recursive Bind Mounts
    k. A Virtual Memory File System: tmpfs
        - mount -t tmpfs source target - creates a tmpfs virtual file system
    l. Obtaining Information About a File System: statvfs()
        - fn - int stavfs(const char *pathname, struct statvfs *statvsbuf) - obtain informatiom about a mounted file system
            - struct statvfs {
                unsigned long f_bsize; /* File System Block Size in Bytes */
                unsigned long f_frsize; /* Fundamental File System System Block Size in Bytes */
                unsigned long f_blocks; /* Total Number of Blocks in File */
                unsigned long f_bfree; /* Total Number of Free Blocks */
                unsigned long f_bavail; /* Number of Free Blocks Available to Unprivileged Process */
                unsigned long f_files; /* Total Number of I-Nodes */
                unsigned long f_ffree; /* Total Number of Free I-Nodes */
                unsigned long f_favail; /* Number of I-Nodes Available to Unprivileged Process */
                unsigned long f_fsid; /* File System ID */
                unsigned long f_flag; /* Mount Flags */
                unsigned long f_namemax; /* Maximum Name of Filenames on this File System */
            }

Chapter 15: File Attributes
    a. Retrieviing File Information
        - fn - int stat(const char *pathname, struct stat *statbuf) - returns info about a named file
        - fn - int lstat(const char *pathname, struct stat *statbuf) - returns info about link if symbolic link
        - fn - int fstat(int fd, struct stat *statbuf) - returns info about a file descriptor
            - struct stat {
                dev_t st_dev; /* IDs of device on which file resides */
                ino_t st_ino; /* I-nmode number of file */
                mode_t st_mode; /* File type and permissions */
                nlink_t st_nlink; /* Number of hard links to the file */
                uid_t st_uid; /* User ID of the file owner */
                dev_t st_rdev; /* Group ID of the file owner */
                off_t st_size; /* Total file size in bytes */
                blksize_t st_blksize; /* Optimal block size for I/O bytes */
                blkcnt_t st_blocks; /* IDs of deveice on which file resides */
                time_t st_atime; /* Time of last file access */
                time_t st_mtime /* Time of last file modification */
                time_t st_ctime; /* Time of last status change */
            }
    b. File Timestamps
        - System calls that can change atime, mtime, and ctime
            - chmod(), chown(), exec(), link(), mkdir(), mkfifo(), mknod(), mmap(), msync(), open(), creat(), pipe(), read(), readdir(), removexattr(), rename(), rmdir(), sendfile(), setattr(), symlink(), truncate(), unlink(), utime(), write()
        - Nanesecond Timestamps - 2.6 Linux supports nanosecond resolution for the three timestamp fields of the stat structure
        - Changing File Timestamps with utime() and utimes()
            - fn - int utime(const char *pathname, const struct utimbuf *buf) - can change last file access and modification timestamps
                - struct utimbuf {
                    time_t actime;
                    time_t modtime;
                }
            - fn - int utimes(const char *pathanme, const struct timeval tv[2]) - can change last file access and modification timestamps with microsecond accuracy
            - fn - int futimes(int fd, const struct timeval tv[2]) - can change last file access and modification timestamps of file indicated by file descriptor
            - fn - int lutimes(const char *pathname, cosnt struct timeval tv[2]) - can change last file access and modification timestamps of file or symbolic link
        - Changign File Timestamps with utimensat() and futimens()
            - Advantages
                - Can set timestamps with nanosecond precision
                - It is possible to set the timestamps independently
                - It is possible to independently set either of the timestamps to the current time
            - fn - int utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags) - updates the timestamps of the file specified by pathname to the values specified in the array times
            - fn - int futimens(int fd, const struct timespec times[2]) - updates the timestamps of the file referred to by the open file descriptor fd
    c. File Ownership
        - Ownership of New Files
            - Rule - when a new file is created, its user ID is taken from the effective user ID of the process, on lnux this is the file-system user ID
            - When Mounting
                - If you use -o grpid, -o bsdgroups - the group ownership of any new file created is taken from parent directory group ID
                - If you use -o nogrpid, -o sysvgroups
                    - If set-group-ID bit is not enabled - the group ownership of any new files created is taken from the parent directory group ID
                    - If set-group-ID bit is enabled - the group ownership of any new files created is taken from the process effective group ID
            - Changing File Ownership: chown(), fchown(), and lchown() - change the owner user ID and group ID of a file
                - fn - int chown(const char *pathname, uid_t owner, gid_t group) - file named in pathname
                - fn - int lchown(const char *pathname, uid_t owner, gid_t group) - file or link
                - fn - int fchown(int fd, uid_t owner, gid_t group) - fd
    d. File Permissions
        - Permissions on Regular Files
            - Categories - Owner, Group, Other - rwxrwxrwx
            - Permissions
                - Read - the contents of a file may be read
                - Write - the contents of the file may be changed
                - Execute - the file may be executed
        - Permissions on Directories
            - Categories - Owner, Group, Other - rwxrwxrwx
            - Permissions
                - Read - the contents of the directory may be listed
                - Write - files may be created in and removed from the directory
                - Execute - files within the directory may be accessed i.e. search permission
        - Permission Checking Algorithm
            - Rule 1 - if the process is privilege, all access is granted
            - Rule 2 - if the effective user ID of the process is the same as the user ID of the file, then access is granted according to the owner permissions on the file
            - Rule 3 - if the effective group ID of the process or any of the process supplementary group IDs matches the group ID of the file, then access is granted according to the group permissions on the file
            - Rule 4 - otherwise access is granted according to the other permissiosn on the file
        - Permission Checking for Privilege Processes - on Linux, for a file that is not a director, Linux grants execute permission to a privileged process only if that permission is granted to at least one of the permission categories for the file
        - Checking File Accessibility
            - fn - int access(const char *pathname, int mode) - checks the accessibility of the file based on a process's real user and group IDs and supplementary group IDs
                - mode constants for access
                    - F_OK - Does the file exists?
                    - R_OK - Can the file be read?
                    - W_OK - Can the file be written?
                    - X_OX - Can the file be executed?
        - Sticky Bits - For directories, stickly bit acts as the restricted deletion flag, if set, means an unprivileged process can unlink and rename files in the directory only if it has write permission on the directory and owns either the file or the directorys
        - The Process File Mode Creation Mask: umask()
            - umask - process attribute that specifies which permission bits should always be turned off when new files or directories are created by the process
            - If umask is 022 = ----w--w- - means write permission are automatically turned off for group and other
                - If mode argument to open is 0666, then user would have read and write, while group and other would only have read
                - If mode argument to open is 0777, then user would have read, write, and execute, while group and other would only have read and execute
            - fn - mode_t umask(mode_t mask)
        - Changing File Permissiosn: chmod() and fchmod()
            - fn - int chmod(const char *pathname, mode_t mode) - changes the permssions of the file named in pathname
            - fn - int fchmod(int fd, mode_t mode) - changes the permissions of the file referred to by the open file descriptor fd
    e. I-node Flags (Extended Attribute)
        - FS_APPEND_FL - a - append only
        - FS_COMRP_FL - c - enable file compression
        - FS_DIRSYNC_FL - D - synchronous directory updates
        - FS_IMMUTABLE_FL - i - immutable
        - FS_JOURNAL_DATA_FL - j - enable data journaling
        - FS_NOATIME_FL - A - don't update file last access time
        - FS_NODUMP_FL - d - no dump
        - DS_NOATIL_FL - t - no tail packing
        - FS_SEFCRM_FL - s - secure deletion
        - FS_SYNC_FL - S - synchronous file and directory updates
        - FS_TOPDIR_FL - T - treaat as top-level directory for Orlov
        - FS_UNRM_FL - u - file can be deleteda

Chapter 16: Extended Attributes
    a. Overview
        - Extended Attributes - allow arbitrary metadata, in the form of name-value pairs
        - EA Namespaces - User, Trusted, System, And Security
            - User - can be manipulated by users
            - Trusted - can only be manipulated by privileged users
            - System - used by the kernel to associate system objects with a file e.g. access control list
            - Security - used to store file security labels for operating system securiyt modules and to associate capabilities with executable files 
        - Creating and Viewing EAS from the Shell
            - setfattr - sets or removes an EA
            - getfattr - gets a specific EA or all EAs assocaited with a file
    b. Extendede Attributes Implementation Details
        - Restrictions on User EAs - can only be placed on regular files and directories
        - Implementation Limits
            - the length of an EA name is limited to 255 characters
            - the EA value is limited to 64kb
    c. System Calls for Manipulating Extended Attributes
        - Creating and Modifying EAs
            - fn - int setxattr(const char *pathname, const char *name, const void *value, size_t size, int flags) - set the value of one of the file's EAs 
            - fn - int lsetxattr(const char *pathname, const char *name, const void *value, size_t size, int flags) - set the value of one of the file's EAs 
            - fn - int fsetxattr(int fd, const char *name, const void *value, size_t size, int flags) - set the value of one of the file's EAs 
        - Retrieving the Value of An EA
            - fn - ssize_t getxattr(const char *pathname, const char *name, void *value, size_t size) - retrieves the value of an EA
            - fn - ssize_t lgetxattr(const char *pathname, const char *name, void *value, size_t size) - retrieves the value of an EA
            - fn - ssize_t fgetxattr(int fd, const char *name, void *value, size_t size) - retrieves the value of an EA
        - Removing an EA
            - fn - int removexattr(const char *pathname, const char *name) - removes an EA from a file
            - fn - int lremovexattr(const char *pathname, const char *name) - removes an EA from a file
            - fn - int fremovexattr(int fd, const char *name) - removes an EA from a file
        - Retrieivng the Names of All EAs Associated with a File
            - fn - ssize_t listxattr(const char *pathname, char *list, size_t size) - returns a list containng all the names of all of the EAs associated with a file
            - fn - ssize_t llistxattr(const char *pathname, char *list, size_t size) - returns a list containng all the names of all of the EAs associated with a file
            - fn - ssize_t flistxattr(int fd, char *list, size_t size) - returns a list containng all the names of all of the EAs associated with a file