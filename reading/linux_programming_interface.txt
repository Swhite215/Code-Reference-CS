Title: Linux Programming Interface
Authors: Michael Kerrisk

Summarization of Content

Chapter 1 - History
    a. A Brief History of UNIX and C
        - First Edition - November 1971 - PDP-11 w/ FORTRAN compiler
            - ar, cat, chmod, chown, cp, dc, ed, find, ln, ls, mail, mkdir, mv, rm, sh, su, who
        - Second Edition - June 1972 - Installed on 10 Machines
        - Third Edtiion - February 1973 - C Compiler and Pipes
        - Fourth Edition - November 1973 - Almost Totally C
        - Fifth Edition - June 1974 - Installed on > 50 Systems
        - Sixth Edition - May 1975 - Widely used outside of AT&T
        - Seventh Edition  - January 1979 - Improved Reliability and File System
            - awk, make, sed, tar, uucp, Bourne Shell, FORTRAN 77 Compiler
        - 3BSD - December 1979 - Berkely Software Distribution
        - System V - 1989 - Commercial Licensing
    b. A Brief History of Linux
        - GNU Project - 1984 - Richard Stallman develops free UNIX-like system without kernel
        - GNU Public License
        - Linux - March 1994
        - Linux 2.6 - December 2003
    c. Standardization
        - C Programming Language
            - American National Standards Institute ANSI C89
            - International Standard Organization ISO C99
        - POSIX - Portable Operating System Interface
            - Institute of Electrical and Electronic Engineers - POSIX.1 1988
            - POSIX.2 1992
        - FIPS 151-1 and FIPS 151-2
        - X/Open Company and The Open Group
        - SUSv3 and POSIX.1-2001
        - SUSv4 and POSIX.1-2008

Chapter 2 - Fundamental Concepts
    a. Core Operating System: The Kernel
        - Kernel - central software that manages and allocates computer resources i.e. CPU, RAM, and Devices
        - Tasks: Process Scheduling, Memory Management, Provision of File System, Processes Management, Device Access, Networking, System API
        - Modes: Kernel vs. User
    b. Shell
        - Versions: Bourne (sh), C (csh), Korn (ksh), Bourne Again (bash)
        - Capabilities: variables, loops, conditional statements, functions, I/O
    c. Users and Groups
        - Users - User ID, Home Directory, Login Shell
        - Groups - Group Name, Group ID, User List
        - Superuser - ID = 0, Name = root
    d. Single Directory
        - / -> bin,boot,etc,home,usr
        - File Types - link, directory, devices, pipes, sockets
        - Directory - special file whose contents take the form of a table of filenames coupled with references to files
        - Symbolic Links - contains name of another file
        - Filenames - 255 char portable filename character set
        - Pathnames - string of / separated directories ending in a file or directory
    e. File I/O Model
        - System Calls - open(), read(), write(), close()
        - Descriptors - 0 is standard input, 1 is standard output, and 2 is standard error
        - stdio - fopen(), fclose(), scan(), printf(), fgets(), fputs()
    f. Programs
        - Source-Code - human-readable text
        - Binary - machine-language instructions that a computer can understand
        - Filter - program reads from stdin, performs a transformation, and writes transformed data to stdout
        - CLI Arguments
            - int main(int argc, char *argv[])
            - argc is total number of arguments
            - argv is array of individual arguments
    g. Processes - instance of an executing program
        - Segments
            - Text - instruction of the program
            - Data - static variables used by the program
            - Heap - area from which programs can dynamically allocate extra memory
            - Stack - piece of memory that grows and shrinks as functions are called and returned
        - Create - parent process uses fork() to create child process that inherits parent's data, stack, and heap
        - Process Identifier PID and Parent Process Identifier PPID
        - Termination - _exit() or kill w/ signal
        - IDs
            - Process Real User ID and Real Group ID
            - Effective User ID and Effective Group ID
            - Supplementary Group IDs
        - Privilege Process - effective user id is 0 and bypasses permission restrictions
        - Init - parent of all processes, /sbin/init, creates and monitors a range of processes required by a running system
        - Daemon - special purpose process that is long-lived and runs in the background
        - Environment List - environment variables used to communicate information to processes
        - Resource Limits - setrlimit() to set soft limit and hard limit
    h. Memory Mappings
        - File Mapping - maps a region of a file into the calling process's virtual memory
        - Anonymous Mapping - initialized to 0
    i. Static and Shared Libraries
        - Static - structured bundle of compiled object modules
        - Shared - grabbed by dynamic linker and loaded into memory when needed by program
    j. Interprocess Communication
        - Mechanisms
            - Signals - indicate an event has occurred, "software interrupts"
            - Pipes - transfers data between processes
            - Sockets - transfer data from one process to another, either on same host or different hosts connected by a network
            - File Locking - allows a process to lock regions of a file in order to prevent other processes from reading or updating
            - Message Queues - used to exchange messages (packets of data) between processes
            - Semaphores - used to synchronize the actions of processes
            - Shared Memory - allows two or more processes to share a piece of memory
    k. Threads
        - Processes that share the same virtual memory as well as a range of other attributes
    l. Sessions, Controlling Terminals, and Controlling Processes
        - Session - collection of process groups
        - Controlling Terminal - established when session leader process first opens a terminal device
        - Foreground Process - may read input from terminal and send output to it
        - Background Process
    m. Pseudoterminals
        - Pair of connected virtual devices, known as master and slave with an IPC channel allowing two way data transfer
        - Slave provides an interface that behaves like a terminal, allowing another program to drive the terminal-oriented program connected to slave device
        - Examples Telnet and SSH
    n. Date and Time
        - Real Time - calendar time since Midnight on 01/01/1970
        - Process Time - total amount of CPU time that a process has used since starting
            - System CPU Time - time spent executing code in kernel mode
            - User CPU Time - time spent executing code in user mode
        - Time command - real, system CPU, and user CPU time
    o. Client-Server Architecture
        - Client - asks the server to carry out some service by sending it a request message
        - Server - examines client's request, performs appropriate actions, and then sends a response message back to client
    p. Realtime
        - Extensions - asynchronous I/O, shared memory, memory-mapped files, memory locking, realtime clocks and timers, scheduling policies, realtime signals, message queues and semaphores

Chapter 3: System Programming Concepts
    a. System Calls
        - Goal - controlled entry point into the kernel, allowing a process to request that the kernel perform some action on the process' behalf
        - System Call API
        - System Calls
            - Change the processor state from user mode to kernel mode
            - Set of system calls is fixed
            - Each system call may have a set of arguments that specify information transferred from user space to kernel space and vice-versa
        - Order
            - Application program makes a system call by invoking a wrapper function in the C Library
            - Wrapper function makes system call arguments available to the system by copying arguments into specific registers
            - Wrapper function copies system call number into CPU register %eax
            - Wrapper function executes a trap machine instruction, which causes the processor to switch from user mode to kernel mode and execute code pointed to by location 0x80
            - Kernel invokes system_call() routine
                - Saves register values onto the kernel stack
                - Checks validity of the system call number
                - Invokes appropriate system call service routine using system call number to index a table of all system calls sys_call_table
                - Service routine performs the required task and then returns a result status to system_call() routine
                - Restores register values from the kernel stack and places the system call return value on the stack
                - Returns to the wrapper function
            - Processor switches back to user mode
            - If return value of system call indicates an error, wrapper function sets errno using the value
            - Wrapper function returns to the caller, providing an integer return value indicating the success or failure of the system call
        - Overhead - system calls have a small but appreciable overhead
    b. Library Functions
        - Goal - one of the multitude of functions that constitutes the standard C library
        - Some use system calls and others do not
        - Standard C Library
            - GNU C Library - glibc
            - Version - /lib/libc.so.6
    c. Handling Errors
        - Important - always check status value from system call and library functionss for an error
        - System Call Errors
            - Error is normally indicated by -1
            - Check Example - fd = system call, if (fd == -1) {/* Code to Handle an Error */}
            - Print Error Message - perror() and strerror()
        - Library Function Errors Three Types
            - Return in same way as system calls
            - Set errno to indicate specific error condition aand returns a value other than -1 on error
            - Errno is not used at all
    d. Example Programs in this Book
        - Command-Line Options and Arguments
            - standard getopt() library
        - Common Functions and Header Files
            - Header File - tlpi_hdr.h pg. 51
            - Error Diagnostic Functions - error_functions.h
                - errMsg() - prints a message on standard error
                - errExit() - prints a message on standard error and terminates the program
                - err_exit() - similar to errExit() but does not flush standard output before print error and does not flush stdio buffers or invoke exit handlers
                - errExitEN)() - similar to errExit() but prints error number instead
                - fatal() - used to diagnose general errors, including errors that don't set errno
                - usageErr() - diagnose errors in command-line argument usage
                - cmdLineErr() - diagnose errors in command-line arguments specified to a program
                - Parsing Command Line Arguments
                    - getInt()
                    - getLong()
    e. Portability Issues
        - Feature Test Macros - have header files expose the definitions (constants, function prototypes, and so on) that follow a particular standard
        - System Data Types - pg. 65

Chapter 4: File I/O: The Universal I/O Model
    a. Overview
        - File Descriptor - a usually small, nonnegative number
        - Standard File Descriptors
            - 1 - stdin - STDIN_FILENO
            - 2 - stdout - STDOUT_FILENO
            - 3 - stderr - STDERR_FILENO
        - Key System Calls
            - fd = open(pathname, flags, mode) - opens the file identified by pathname, returning a file descriptor used to refer to the file in subsequent calls e.g. read, lseek, and write
            - numread = read(fd, buffer, count) - reads at most count bytes from the open file referred to by fd and stores them in buffer
            - numwritten = write(fd, buffer, count) - writes at most count bytes from the buffer to the open file referred to by fd
            - status = close(fd) - releases fd and its associated kernel resources
        - Key Code Example - pg. 71 and Linux Workspace tlpi-dist/fileio/copy.c
    b. Universality of I/O
        - open(), read(), write(), and close() are used to perform I/O on all types of files, including devices such as terminal
            - ./copy test test.old - copy a regular file
            - ./copy a.txt /dev/tty - copy a regular file to this terminal
            - ./copy /dev/tty b.txt - copy input from this terminal to a regular file
            - ./copy /dev/pts/16 /dev/tty - copy input from another terminal
    c. Opening a File: open()
        - fn - int open(const char *pathname, int flags, .... /* mode_t mode */);
            - pathname - file to be opened
            - flag - bit mask that specifies the access mode for the file i.e. permissions to be placed, depend on mode, process umask and optional access control list
        - Examples
           - fd = open("startup", O_RDONLY); - open existing file for reading
           - fd = open("myfile", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR); - open new or existing file for reading and writing, truncating to zero bytes, file permissions read-write for owner, nothing for all others
           - fd = open("w.log", O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR); - open new or existing file for writing, writes should always append to end of file
        - File Descriptor returned - if open() succeeds, it should return the lowest number unused file descriptor for the process
        - open() flags argument
            - File Access Mode Flags - only one of these values should be specified in flags
                - O_RDONLY - open for reading only
                - O_WRONLY - open for writing only
                - O_RDWR - open for reading and writing
            - File Creation Flags - control aspects of behavior of the open() call
                - O_CLOEXEC - set the close on-exec flag
                - O_CREAT - create file if it doesn't already exist
                - O_DIRECTORY - fail if pathname is not a directory
                - O_EXCL - with O_CREAT; create file exclusively
                - O_LARGEFILE - used on 32-bit systems to open large files
                - O_NOCTTY - dont let pathname become the controlling terminal
                - O_NOFOLLOW - dont dereference symbolic links
                - O_TRUNC - truncate existing file to zero length
            - File Status Flags
                - O_APPEND - writes are always appended to end of file
                - O_ASYNC - generate a signal when I/O is possible
                - O_DIRECT - file I/O bypasses buffer cache
                - O_DSYNC - provide synchronized I/O data integrity
                - O_NOATIME - don't update file last access time on read
                - O_NONBLOCK - open nonblocking mode
                - O_SYNC - make file write synchronous
        - Errors from open() - if an error occurs open() returns -1 and errno identifies the cause of the error
            - EACCES - file permissions don't allow the calling process to open the file in the mode specified by the flags or because of directory permissions, the file could not be accessed or the file did not exist and could not be created
            - EISDIR - the specified file is a directory, and the caller attempted to open it for writing, which is not allowed
            - EMFILE - the process resource limit on the number of open file descriptors has been reached
            - ENFILE - the system wide limit on the number of open files has been reached
            - ENOENT - the specified file doesn't exists, and O_CREAT was not specified
            - EROFS - the specified file is on a read-only file system and the caller tried to open for writing
            - ETXTBSY - the specified file is an executable file that is currently executing
    d. The creat() System Call
        - fn - int creat(const char *pathname, mode_t mode);
        - Goal - creates and opens a new file with the given pathname, or if the file already exists, opens the file and truncates it to zero length
    e. Reading from a File: read()
        - fn - ssize_t read(int fd, void *buffer, size_t count);
            - count - specifies the maximum number of bytes to read
            - buffer - supplies the address of the memory buffer into which the input data is to be placed, buffer must be at least count bytes long
                - system calls dont allocate memory for buffers that are used to return information to the caller, instead we must pass a pointer to a previously allocated memory buffer of the correct size
            - successful call to read returns the number of bytes actually read, or 0 if end of file is encountered
        - Examples
            - numRead = read(STDIN_FILENO, buffer, MAX_READ);
    f. Writing to a File: write()
        - fn - ssize_t write(int fd, void *buffer, size_t count);
            - count - specifies the maximum number of bytes to write
            - buffer - supplies the address of the memory buffer from which the input data is to be written, buffer must be at least count bytes long
            - successful call to write returns the number of bytes actually written
    g. Closing a File: close()
        - fn - int close(int fd);
        - closes an open file decsriptor, freeing it for subsequent reuse by the process. When a process terminates, all of its open file descriptrs are automatically closed
        - Example
            - if (close(fd) == -1); errExit("close");
    h. Changing the File Offset: lseek()
        - File Offset - location in the file at which the next redad or write will commence
        - fn - off_t lseek(int fd, off_t offset, int whence);
            - offset - specifies a value in bytes
            - whence - indicates the base point from which offset is to be interpreted
                - SEEK_SET - the file offset is set offset bytes from the beginning of the file
                - SEEK_CUR - the file offset is adjusted by offset bytes relative to the current file descriptor
                - SEEK_END - the file offset is set to the size of the file plus offset. In other words, offset is interpreted with respect to the next byte after the last byte of the file
        - File Holes - a program seeks past the end of a file and then performs I/O, it is possible to write bytes at an arbitrary point past the end of the file, files holes do not take up disk space
            - Advantage - a sparsely populated file consumes less disk space than would otherwise be required if the null bytes actually neeeded to be allocated in disk blocks
        - Key Code Example - pg. 84 or tlpi-dist/fileio/seek_io.c
    i. Operations Outside the Universal I/O Model: ioctl()
        - fn - int ioctl(int fd, int request, .... /* argp */);
            - fd - open file descriptor
            - request - control operation to be performed
            - argp - could be anything, typically a pointer to either an integer or a structure

Chapter 5: File I/O: Further Details
    a. Atomicity and Race Conditions
        - Atomicity - kernel guarantees that all of the steps in the operation are completed without being interrupted by another process or thread
        - Race Conditions - a situation where the result produced by the two processes operating on a shared resource depends in an unexpected way on the relative order in which the processes gain access to the CPU(s)
        - Creating a File Exclusively - use open() with O_CREAT and O_EXCL to guarantee the check for a file and creation are carried out as a single atomic operation
        - Appending Data to A File - use open() with O_APPEND to ensure that the seek to the next byte past the end of the file and the write operation is carried out as a single atomic operation
    b. File Control Operations
        - fn - int fcntl(int fd, int cmd, ...); - performs a range of control operations on an open file descriptor
    c. Open File Status Flags
        - F_GETFL - retrieves settings like access mode and status flags
    d. Relationship Between File Descriptors and Open Files
        - Per-Process File Descriptor Table - Each Entry
            - a set of flags controlling the operation of the file decsriptor
            - a reference to the open file description
        - System Wide Table of All Open File Descriptions - Each Entry
            - the current file offset (as updated by read() and write(), or by explicitly using lseek())
            - status flags specified when opening the file (i.e. the flags argument to open())
            - the file access mode (read-only, write-only, or read-write)
            - settings relating to signal-driven I/O
            - a reference to the i-node object for this file
        - I-Node Table - Each Entry
            - file type e.g. regular file, socket, or FIFO, and permissions
            - a pointer to a list of locks held on this file
            - various properties of the file, including its size and timestamps relating to different types of file operations
    e. Duplicating File Descriptors
        - fn - int dup(int oldfd) - returns a new descriptor that refers to the same open file description
        - fn - int dup2(int oldfd, int newfd) - makes a duplicate of the file descriptor given in oldfd using the descriptor number supplied in newfd
        - fn - int dup3(int oldfd, int newfd, int flags) - same as dup2, but adds an additional argument, flags, that is a bit mask that modifies the behavior of the system call
    f. File I/O at a Specified Offset: pread() and pwrite()
        - fn - ssize_t pread(int fd, void *buf, size_t count, off_t offset) - read at the location specified by offset
        - fn - ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset) - writes at the location specified by offset
    g. Scatter-Gather I/O: readv() and writev()
        - fn - ssize_t readv(int fd, const struct iovec *iov, int iovcnt) - reads a contiguous sequence of bytes from the file referred to by the file descriptor fd and places those bytes into the buffers specified by iov
        - fn - ssize_t writev(int fd, const struct iovec *iov, int iovcntl) - gathers data from all buffers specified by iov and writes them as a sequence of contiguous bytes to the file referred to by the file descriptor fd
    h. Truncating a File: truncate() and ftruncate()
        - fn - int truncate(const char *pathname, off_t length) - sets the size of a file to the value specified by length
            - if file is longer than length, excess data is lost
            - if file is shorter than length, extended by padding with a sequence of null bytes or a hole
    i. Nonblocking I/O
        - if file can't be opened immediately, then open() returns an error instead of blocking
        - after a successful open(), subsequent I/O are also nonblocking
    j. I/O on Large Files
        - _FILE_OFFSET_BITS macro
            - converts all of the relevant 32-bit functions and data types into their 64-bit counterparts e.g. open() with open64()
    k. The /dev/fd Directory - contains filenames of the form /dev/fd/n, where n corresponds to one of the open file descriptors for the process
    l. Creating Temporary Files
        - fn - int mkstemp(char *template) - generates a unique filename based on a template supplied by the caller and opens the file, returning a file descriptor that can be used with I/O system calls

Chapter 6: Processes
    a. Processes and Programs
        - process - an instance of an executing program
        - program - file containing a range of information that describes how to construct a process at run time
            - binary format identification - metainformation describing the format of the executable file
            - machine language instructions - these encode the algorithm of the program
            - program entry point address - this identifies the location of the instruction at which execution of the program should commence
            - data - values used to initialize variables and also literal constants used by the program
            - symbol and relocation tables - these describe the locations and names of functions and variables within the prorgam. Used for debugging, run-time symbol resolution and more
            - shared library and dynamic linking information - includes fields listing the shared libraries that the program needs to use at run time and the pathname of the dynamic linker that should be used to load these libraries
            - other information - other information to describe how to construct a process
    b. Process ID and Parent Process ID
        - process ID - a positive integer that uniquely identifies the process on the system
            - fn - pid_t getpid(void) - returns the process ID of the calling process
        - parent process ID - a positive integer that uniquely identifies the parent process of the process
            - fn - pid_t getppid(void)
    c. Memory Layout of a Process
        - Segment
            - text segment - contains the machine-language instructions of the program run by the process
            - initialized data segment - contains global and static variables that are explicitly initialized
            - uninitialized data segment - contains global and static variables that are not explicity initialized
            - stack - a dynamically growing and shrinking segment containing stack frames. One stack frame is allocated for each currently called function and stores the functions local variables, arguments, and return value
            - heap - an area from which memory can be dynamically allocated at run time. Top end is called program break
    d. Virtual Memory Management
        - Virtual Memory Management - make efficient use of both the CPU and physical memory by exploiting a property that is typical of programs, locality of reference
            - Spatial Locality - tendency of a program to reference memory addresses that are near those that were recently accessed because of sequential processing of instructions, and sometimes, sequential processing of data structures
            - Temporal Locality - tendency of a program to access the same memory addresses in the near future that is accessed in the recent past e.g. because of loops
            - Pages - fixed size units of memory used by programs
            - Unused pages are maintained in the swap area
            - Resident set - the pages present in physical memory page frames
        - Processes Valid Virtual Address Range
            - as the stack grows downward beyond limits previously reached
            - when memory is allocated and deallocated on the heap, by raising the progam break using brk(), sbrk(), or the malloc family of functions
            - when System V shared memory regions are attached using shmat() and detached using shmdt()
            - when memory mappings are created using mmap() and unmapped using munmap()
        - Advantages of Virtual Address Space
            - processes are isolated from one another and from the kernel, so that one process can't read or modify the memory of another process or the kernel
            - where appropriate, two or more processes can share memory
            - the implementation of memory protection schemes is facilitated, that is, page table entries can be marked to indicate that the contents of the corresponding page are readable, writable, executable, or some other combination of these protections
            - programmers, and tools such as the compiler and linker, don't need to be concerned with the physical layout of the program in RAM
            - program loads and runs faster because only a portion needs to reside in memory
    e. The Stack and Stack Frames
        - Stack - grows and shrinks linearly as functions are called and return
            - Stack Pointer - tracks the current top of the stack, each time a function is called, an additional frame is allocatd on the stack, and the frame is removed when the function returns
        - Stack Frame
            - Function Arguments and Local Variables (automatic), they are automatically created when a function is called and they automatically disappear when the function returns
            - Call Linkage Information - each function uses certain CPU registers, such as the program counter, which points to the next machine-language instruction to be executed
    f. Command Line Arguments
        - argc - number of arguments
        - argv - array of pointers to command line arguments as string, each with a null terminated character
        - Important Example: tlpi-dist/proc/necho.c and
        - Review - getopt() in Appendix B
    g. Environment List
        - Environment List/Environment - associated array of strings in the format key=value
        - Accessing the Enviroment From a Program
            - Global Variable - extern char **environ
            - Important Example: tlpi-dist/proc/display_env.c
            - fn - char *getenv(const char *name) - returns a pointer to the corresponding value string
        - Modifying the Environment
            - fn - int putenv(char *string) - adds a new variable to the calling process's environment or modifies the values of an existing variable, string format is key=value
            - fn - int setenv(const char *name, const char *value, int overwrite) - creates a new environment variable by allocating a memeory buffer for a string of the form name=value, and copying the strings pointed to by name and value into that buffer
            - fn - int unsetenv(const char *name) - removes the variable defined by name from the environment
            - fn - int clearenv(void) - erase the entire environment
    h. Performing a Nonlocal Goto: setjmp() and longjmp()
        - Jumping
            - fn - int setjmp(jmp_buf env) - establishes a target for a later juimp performed by longjmp(), this target is exactly the point where the setjmp() call occurred
            - fn - void longjmp(jmp_buf env, int val) - jumps to location set by setjmp()
            - Important Example: tlp-dist/proc/longjmp.c
        - Abusing longjmp() - don't longjmp into a function that has already returned, SUSv3 says that if longjmp is called from within a nested signal handler then the program behavior is undefined
        - Avoid setjmp() and longjmp() where possible

Chapter 7: Memory Allocation
    a. Allocating Memory on the Heap
        - A process can allocate memory by increasing the size of the heap, a variable size segment of contiguous virtual memory that begins just after the uninitialized data segment of a process and grows and shrinks as memeory is llocated and freed. Limit of heap is called program break
        - Adjusting the Program Break: brk() and sbrk()
            - Resizing the heap is as simple as telling the kernel to adjust its idea of where the process's program break is
            - fn - int brk(void *end_data_segment) - sets the program breeak to the location specified by end_data_segment, end_data_segment is effectively roudned up to the next page boundary
            - fn - void *sbrk(intptr_t increment) - adjusts the program break by adding increment to it
        - Allocating Memory on the Heap: malloc() and free()
            - Advantages over brk() and sbrk()
                - standardized as part of the C language
                - easier to use in threaded programs
                - provide a simple interface that allows memory to be allocated in small units
                - allow us to arbitrarily deallocate blocks of memory, which are maintained on a free list and recycled in future calls to allocate memory
            - fn - void *malloc(size_t size) - allocates size bytes from the heap and returns a pointer to the start of the newly allocated block of memory that is not initialized
            - fn - void free(void *ptr) - deallocates the block of memory pointed to by its ptr argument, which should be an address previously returned by malloc()
                - free doesn't lower the program break, instead adds the block of memory to a list of free blocks that are recycled by future calls to malloc()
        - Implementations of malloc() and free()
            - malloc() - first scans the list of memory blocks previsouly released by free() in order to find one whose size is larger or equal to its requirement
                - if no block on the free list is large enough, then malloc() calls sbrk() to allocate more memory, memory is more than bytes required
        - Tools and Libraries for malloc debugging
            - mtrace() and muntrace() allow a program to turn tracing of memory allocation calls on and off
            - mcheck() and mprobe() allow a program to perform consistency checks on blocks of allocated memory
            - MALLOC_CHECK_ environment variable serves a similar purpose to mcheck() and mprobe()
        - Controlling and Monitoring the malloc package
            - mallopt() modifies the various parameters that control the algorithm used by malloc()
            - mallinfo() returns a structure containing various statistics about the memory allcoated by malloc()
        - Other Methods of Allocating Memory on the Heap
            - fn - void *calloc(size_t numitems, size_t size) - allocates memory for an array of identical items
            - fn - void *realloc(void *ptr, size_t size) - used to resize a block of memory previously allocated by one of the functions in the malloc package
        - Allocating Aligned Memory: memalign() and posix_memalign()
            - fn - void *memalign(size_t boundary, size_t size) - allocates size bytes starting at an address aligned to a multiple of boundary, which must be a power of two
            - fn - int posix_memalign(void **memptr, size_t alignment, size_t size)
    b. Allocating Memory on the Stack
        - fn - *alloca(size_t size) - allocates memory dynamically, however, instead of obtaining memory from the heap, alloca() obtains memory from the stack by increasing the size of the stack frame

Chapter 8: Users and Groups
    a. The Password File: /etc/passwd
        - /etc/passwd - system password file, contains one line for each user account on the system, it is composed of seven fields separated by a colon
        -  mtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash
            - mtk - login name, unique name that the user must enter in order to log in
            - x - encrypted password, field contains a 13 character encrypted password, if shadow passwords have been enabled, it just contains the letter x
            - 1000 - user id, numeric ID for the user
            - 100 - group id, numeric id for the first of the groups the user is a member of
            - Michael Kerrisk - comment, holds text about the user
            - /home/mtk - home directory, initial directory into which the user is placed after logging in
            - /bin/bash - login shell, program to which control is transferred once the user is logged in
    b. The Shadow Password File: /etc/shadow
        - Historically, UNIX systems maintained all user information, including the encrypted password, in /etc/passwd, which presented a security problem
        - /etc/shadow - was devised as a method of preventing attacks on passwords, encrypted file
    c. The Group File: /etc/group
        - the set of groups to which a user belongs is defined by the combination of the group ID field in the user's password entry and the groups under which the user is listed in the group file
        - group file contains one line for each group in the system and each line consists of four colon-separated fields
            - jambit:x:106:claus, felli, frank, harti, markus,martin,mtk,paul
                - jambit - group name, name of the grop
                - x - encyrpted password
                - 106 - group id, numeric id for the group
                - claus, felli, frank, harti, markus, martin, mtk, paul - user list, comma separatedlist of names of the users who are members of this group
    d. Retrieving User and Group Information
        - Retrieving Record from the Password File
            - fn - struct passwd *getpwnam(const char *name) - given a login name in name, returns a pointer to a structure of the following type, containing the corresponding information from the password record:
            - fn - struct passwd *getpwuid(uid_t uid); - returns exactly the same information as getpwnam, but does the lookup using the numeric user id
                - struct passwd {
                    char *pw_name; // login name
                    char *pw_passwd; //encrypted password
                    uid_t pw_uid; // user id
                    gid_t pw_gid; // group id
                    char *pw_gecos; //comment
                    char *pw_dir; // initial working directory
                    char *pw_shell; // login shell
                }
        - Retrieving Records from the Group File
            - fn - struct group *getgrnam(const char *name) - looks up group information by group name, returns a pointer to a structure of the following type
            - fn - struct group *getgrgid(gid_t gid) - returns exactly the same information as getgrnam, but does the look up by numeric group id
                - struct group {
                    char *gr_name; // group name
                    char *gr_passwd; // encrypted password
                    gid_t gr_gid; // group id
                    chasr **gr_mem; // array of pointers to names of members listed in the /etc/group
                }
        - Scanning All Records in the Password and Group Files
            - fn - struct passwd *getpwent(void); - returns all records from the password file one by one, returning null when there are no more records
            - fn - void setpwent(void); - restart from the beginning of the password file
            - fn - void endpwent(void); - closes the password file
            - fn - struct passwd *getgrent(void); - returns all records from the group file one by one, returning null when there are no more records
            - fn - void setgrent(void); - restart from the beginning of the group file
            - fn - void endgrent(void); - closes the group file
        - Retrieiving Records from the Shadow Password File
            - fn - struct spwd *getspname(const char *name); - given a login name, returns a pointer to a structure of the following type
                - struct spwd {
                    char *sp_name; // login name
                    char *sp_pwdp; // encrypted password
                    long sp_lstchg; // time of last password change
                    long sp_min; // min number of days between password changes
                    long sp_max; // max number of days before change of password is required
                    long sp_warn; // number of days beforehand that a user is warned of upcoming password expiration
                    long sp_intact; // number of days after expiration that account is considered inactive and locked
                    long sp_expire; // date when account expires
                    unsigned long sp_flag; // reserved for future use
                }
            - fn - struct spwd *getspent(void); - returns all records from the shadow password file
            - fn - void setspent(void); - restart from the beginning of the shadow password file
            - fn - void endspent(void); - closes the shadow password file
    e. Password Encryption and User Authentication
        - Form #1 - application require authentication and manages its own database of usernames and passwords for this purpose
        - Form #2 - allowing users to enter their information as defined in /etc/passwd and /etc/shadow
        - For security reasons, UNIX systems encrypt passwords using a one-way encryption algorithm, which means that there is no method of recreating the original password from its encrypted form
        - The only way of validating the password is to encrypt it using the same method and see if the encrypted result matches the value stores in /etc/shadow
        - fn - char *crypt(const char *ley, const char *salt) - takes a key (i.e. a password) of up to 8 characters, and applies a variation of the Data Encryption Standard algorithm to it.
            - The salt argument is used to vary the algorithm, the 2-char salt argument can cause the encryption algorithm to vary in any of 64*64=4096 ways, causing cracker to need to check the password against 4096 encrypted versions of the dictionary

Chapter 9: Process Credentials
    a. Real User ID and Real Group ID
        - Real User and Group IDs - identify the user and group to which the process belongs
            - As part of the login process, a login shell gets its real user and group IDs from the third and fourth fields of the user's password record in /etc/passwd
    b. Effective User ID and Effective Group ID
         - Effective User and Group IDs - in conjunction with the supplementary group IDs, are used to determine the permissions granted to a process when it tries to perform various operations
    c. Set-User-ID and Set-Group-ID Programs
        - set-user-ID program allows a process to gain privileges it would not normally have by setting the process's effective user ID to the same value as the user ID of the executable
    d. Saved Set-User-ID and Saved Set-Group-ID
        - Saved Set User and Group IDs - are designed for use with set-user-ID and set-group-ID programs. When a program executes:
            - if the set-user-id or set-group-id permission bit is enabled on the executable, then the effective user (group) ID of the process is made the same as the owner of the executable
            - if the set-user-id or set-group-id permission bit is not enabled, then no change is made
            - values for saved set-user-ID and saved set-group-ID are copied from the corresponding effective IDs
    e. File-System User ID and File-System Group ID
        - On Linux, it is the file-system user and group IDs, rather than the effective user and group IDs, that are used in conjunction with supplementary group IDs to determine permissions when performing file-system operations such as opening files, changing file ownership, and modifying file permissions
    f. Supplementary Group IDs - set of additional groups to which a process belongs, a process inherits these IDs from its parent
    g. Retrieving and Modifying Process Credentials
        - Retrieving and Modifying, Real, Effective, and Saved Set IDs
            - Retrieving Real and Effective IDs
                - fn - uid_t getuid(void) - returns the real user ID of the calling process
                - fn - uid_t getgid(void) - returns the real group ID of the calling process
                - fn - uid_t geteuid(void) - returns the effective user ID of the calling process
                - fn - uid_t getegid(void) - returns the effective group ID of the calling process
            - Modifying Effective IDs
                - fn - int setuid(uid_t uid) - changes the effective user ID, and possibly the real user ID and saved set-user-ID
                    - if an unprivileged process calls setuid(), only the effective user ID of the process is changed, and can only be changed to the same value as either the real user ID or saved set-user-ID
                    - if a privileged process calls setuid(), real, effective, and saved set-user IDs are all set to the value specified in the uid argument
                - fn - int setgid(gid_t gid) - changes the effective group ID, and possibly the real group ID and saved set-group-ID
                    - rule 1 applies like above
                    - privileged programs can use setgid() to freely change the group ID to any desired values
                - fn - int seteuid(uid_t euid) - changes effective user ID
                    - if an unprivileged process calls seteuid(), only the effetive user ID of the process is changed, and can only be changed to the corresponding real or saved set ID
                    - if a privleged process calss seteuid(), can change effective ID to any value
                - fn - int setegid(gid_t egid) - changes effective group ID
            - Modifying Real and Effective IDs
                - fn - int setreuid(uid_t ruid, uid_t euid) - allow process to change real and effetive user ID
                    - unprivileged process can set the real user ID only to the current value of the real or effective user ID, and the effective user ID can only be set to the current value of the real user ID, effective user ID, or saved set-user-ID
                    - privileged process can make any changes to the IDs
                    - for both, the saved set-user-ID is also set to the same value as the effective user ID
                - fn - int setregid(gid_t rgid, gid_t egid) - allow process to change real and effective group ID
            - Retrieving Real, Effective, and Saved Set IDs
                - fn - int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid) - returns the current value of the calling process' real, effective, and saved set user IDs
                - fn - int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid) - returns the current value of the calling process' real, effective, and saved set group IDs
            - Modifying Real, Effective, and Saved Set IDs
                - fn - int setresuid(uid_t ruid, uid_t euid, uid_t suid) - allows process to change real, effective, and saved set user IDs
                - fn - int setresgid(gid_t rgid, gid_t egid, gid_t sgid) - allows process to change real, effective, and saved set group IDs
            - Retrieving and Modifying File-System IDs
                - fn - int setfsuid(uid_t fsuid) - changes the file-system user ID of a process to the value specified by fsuid
                    - unprivileged process can set the file-system user ID to the current value, the real user ID, effective user ID, file-system user ID, or saved set-user-ID
                    - privileged process can set the file-system user ID to any value
                - fn - int setfsgid(gid_t fsgid) - changes the file-system group ID of a process to the value specified by fsuid
        - Retrieving and Modifying Supplementary Group IDs
            - fn - int getgroups(int gidgetsize, gid_t grouplist[]) - returns the set of groups of which the calling process is currently a member, in the array pointed to by grouplist
            - fn - int setgroups(size_t gidsetsize, const gid_t *grouplist) - replaces the calling process's supplementary group IDs with the set given in the array grouplist
            - fn - int initgroups(const char *user, gid_t group - ) - initializes the process's supplmentary group IDs by scanning /etc/group and building a list of all groups of which the named user is a member

Chapter 10: Time
    a. Types of Time
        - Real Time - time as measured either from some standard point (calendar time) or from some fixed point in the life of a process
        - Process Time - amount of CPU time used by a process
    b. Calendar Time
        - fn - int gettimeofday(struct timeval *tv, struct timezone *tz) - returns the calendar time in the buffer pointed to by tv
            - tv argument is a pointer to a structure of the following form
                - struct timeval {
                    time_t tv_sec; /* Seconds since 00:00:00, 1 Jan 1970 UTC,
                    suseconds_t tv_usec; /* Additional microseconds */
                }
        - fn - time_t time(time_t *timep) - returns the number of seconds since Epoch i.e. the same value that gettimeofday() returns
    c. Time Conversion Functions
        - Converting time_t to Printable Form
            - fn - char *ctime(const time_t *timep) - returns a 26 byte string containing the date and time in a standard format e.g. Wed Jun 8 14:@2:34 2011
        - Converting Between tim_t and Broken-Down Time
            - fn - struct tm *gmtime(const time_t *timep) - converts a calendar time into a broken down time corresponding to UTC
            - fn - struct *localtime(const time_t *timep) - converts a calendar time into a broken down time that takes into account timezone and DST settings
                - struct tm {
                    int tm_sec; /* Seconds (0-60) */,
                    int tm_min; /* Minutes (0-59) */,
                    int tm_hour; /* Hours (0-23) */,
                    int tm_mday /* Day of the Month (1-31) */,
                    int tm_mon; /* Month (0-11) */,
                    int tm_year; /* Year Since 1900 */,
                    int tm_wday; /* Day of the Week (Sunday = 0) */,
                    int tm_yday; /* Day in the Year (0-365m; Jan 1 = 0) */,
                    int tm_isdst; /* Daylight Savings Time Flag */,
                }
        - Converting Between Broken Down Time and Printable Form
            - Converting from Broken-Down Time to Printable Form
                - fn - char *asctime(const struct tm *timeptr) - returns a pointer to a statically allocated string containing the time in the same form as ctime()
                - fn - size_t strftime(char *outstr, size_t maxsize, const char *format, const struct tm *timeptr) - given a broken down time pointed to by timeptr, strftime places a corresponding null terminated, date-plus-time string in the buffer allocated by outstr
                - fn - char *currTime(const char *format) - returns a string containing the current time as formatted by strftime() when given the argument format
            - Converting From Printable Form to Broken-Down Time
                - fn - char *strptime(const char *str, const char *format, struct tm *timeptr) - converts a date-plus-time string to a broken down time
    d. Timezones
        - Timezone Definitions - timezone information are stored in /usr/share/zoneinfo, where each file contains information about the timezone regime in a particular country or region
        - Local Time for the system is defined by the timezone file /etc/localtime which is often linked to one of the files in /usr/share/zoneinfo
        - Specifying Timezone for a Program
            - Set the TZ environment variable to a string consisting of a colon followed by one of the timezone names defined in /user/share/zoneinfo
            - Setting TZ influences ctime(), localtime(), mktime() and strftime()
            - fn - tzset(), initializes three global variables
                - char *tzname[2]; - /* Name of timezone and alternate (DST) timezone */
                - int daylight; - /* Nonzero if there is an alternate (DST) timezone */
                - long timezone; - /* Seconds difference between UTC and local standard time */
    e. Locales
        - Locale - subset of a user's environment that depends on language and cultural conventions
        - Internationalization - programs designed to run in more than one locale should deal with locales in order to display and input information in the user's preferred langauge and format
        - Locale Definitions - information is maintained in a directory hierarchy under /usr/share/locale or /usr/lib/locale
            - language[_territory[.codeset]][@modifier]
            - Contenst of Locale Specific Subdirectories
                - LC_CTYPE - A file contianing character classiciations and rules for case conversion
                - LC_COLLATE - A file containing the collation rules for a character set
                - LC_MONETARY - A file containing formatting rules for monetary values
                - LC_NUMERIC - A file containing formatting rules for numbers other than monetary values
                - LC_TIME - A file containing formatting rules for dates and times
                - LC_MESSAGES - A directory containing files specifying formats and values used for affirmative and negative (yes/no) responses
        - Specifying the Local for a Program
            - fn - char *setlocale(int category, const char *locale) - used to both set and query a program's current locale
    f. Updating the System CLock
        - fn - int settimeofday(const struct timeval *t, const struct timezone *tz) - sets the system's calendar time to the number of seconds and microseconds specified in the timeval structure pointed to by tv
        - fn - int adjtime(struct timeval *delta, struct timeval *olddelta) - causes the system to gradually adjust to the desired value
    g. The Software Clock
        - Jiffies - size of jiffy is defined by the constant HZ within the kernel source code
            - Clock rate can be set to 100, 250, or 1000 hertz, giving jiffy values of 10, 4, and 1 milliseconds respectively
    h. Process Time
        - User CPU Time - amount of time spent executing in user mode, sometimes referred to as virtual time
        - System CPU Time - amount of time spent executing in kernel mode
        - fn - clock_t time(struct tms *buf) - retrieves process time information, returning it in the structure pointed to by buf
            - struct tms {
                clock_t tms_utime; /* User CPU time used by caller */
                clock_t tms_stime; /* System CPU time used by caller */
                clock_t tms_cutime; /* User CPU time of all (waited for) children */
                clock_t tms_cstime; /* System CPU time of all (waited for) children */
            }
        - fn - clock_t clock(void) - retrieves process time, a single value that measures the total (i.e. user+system) CPU time used by the calling process

Chapter 11: System Limits and Options
    a. Quick Facts
        - Examples:
            - How many files can a process hold open at one time?
            - Does the system support realtime signals?
            - What is the largest value that can be stored in a variable of type int?
            - How big an argument list can a program have?
            - What is the maximum length of a pathname?
        - Variances
            - Across UNIX implementations
            - At run time on a particular implementation
    b. System Limits
        - Minimum Value - defines an upper limit on some resource or feature, a system must support at minimum, a max value of something for a feature
        - Maximum Value - defines a lower limit on some resource or feature, a system may support at maximum, a minimum value of something for a feature
        - Format - constant in <limits.h> with a name prefixed by a string _POSIX_XXX_MAX or _POSIX_XXX_MIN
        - Runtime Invariant Values - limit whose value, if defiend in <limits.h>, is fixed for the implementation, however the value may be indeterminate
        - Pathname Variable Values - limits that relate to pathnames (files, directories, terminals, and so on)
        - Runtime Increasable Values - limit that has a fixed minimum value for a particular implementation, and all the systems running the implementation will provide at least this minimum value, however a system may increase this limit at run time
        - Summary of Select SUSv3 Limits
            - ARG_MAX - _SC_ARG_MAX - maximum bytes for arguments (argv) plus environment (environ) that can be supplied to exec()
            - _SC_CLK_TCK - unit of measurement for time
            - LOGIN_NAME_MAX - _SC_LOGIN_NAME_MAX - maximum size of a login name (including terminmating null byte)
            - OPEN_MAX - _SC_OPEN_MAX - maximum number of file decsriptors that a process can have open at one time, and one greater than maximum usable descriptor number
            - NGROUPS_MAX - _SC_NGROUPS_MAX - maximum number of supplementary groups of which a process can be a member
            - _SC_PAGESIZE - size of a virtual memory page
            - RTSIG_MAX - _SC_RTSIG_MAX - maximum number of distinct realtime signals
            - SIGQUEUE_MAX - _SC_SIGQUEUE_MAX - maximum number of queued realtime signals
            - STREAM_MAX - _SC_STREAM_MAX - maximum number of stdio streams that can be open at one time
            - NAME_MAX - _PC_NAME_MAX - maximum number of bytes in a filename excluding terminating null byte
            - PATH_MAX - _PC_PATH_MAX - maximum number of bytes in a pathname, including terminating null byte
            - PIPE_BUF - _PC_PIPE_BUF - maximum number of bytes that can be written atomically to a pipe or FIFO
        - Determining Limits and Options From the Shell: getconf
            - getconf variable-name [pathname] - obtain the limits implemented by a particular UNIX implementation
    c. Retrieving System Limits and Options at Run Time
        - fn - long sysconf(int name) - allows an application to obtain the values of system limits at run time, name argument is one of the _SC_* constants defined in <unistd.h>
    d. Retrieivng File-Related Limits and Options at Run Time
        - fn - long pathconf(const char *pathname, int name) - allow an application to obtain the values of file-related limits at run time
        - fn - long fpathconf(int fd, int name) - allow an application to obtain the values of file-related limits at run time
    e. Indeterminate Limits - we may find that some system limit is not defined by an implementation limit constant, and that sysconf() or pathconf() informs us that the limit is indeterminate
        - Strategies
            - we could elect to use the minimum limit value specified by SUSv3, constants with the names of the form _POSIX_XXX_MAX
            - ignore checking the limits and instead perform the relevant system or library function call
            - write our own program or function to either deduce or estimate the limit
            - employ a tool such as GNU Autoconf, an extensible tool that can determine the existence and settings of various systems features and limits
    f. System Options
        - Example - support for features such as realtime signals, POSIX shared memory, job control, and POSIX threads
        - Option Constant Values
            - -1 means that the option is not supported
            - 0 means that the option may be supported
            - >0 means that the option is supported
        - SUSv3 Options
            - _POSIX_ASYNCHRONOUS_IO or _SC_ASYNCHRONOUS_IO - Asynchonous I/O
            - _POSIX_CHOWN_RESTRICED or _PC_CHOWN _RESTRICTED - Only privileged processes can use chown() and fchown() to change the user ID and group ID of a file to arbitrary values
            - _POSIX_JOB_CONTROL or _SC_JOB_CONTROL - Job Control
            - _POSIX_MESSAGE_PASSING or _SC_MESSAGE_PASSING - POSIX Message Queues
            - _POSIX_PRIORITY_SCHEDULING  or _SC_PRIORITY_SCHEDULING - Process Scheduling
            - _POSIX_REALTIME_SIGNALS or _SC_REALTIME_SIGNALS - Realtime Signals Extension
            - _POSIX_SAVED_IDS - Processes have saved set-user-IDs and saved set-group-IDs
            - _POSIX_SEMAPHORES or _SC_SEMAPHORES - POSIX Semaphores
            - _POSIX_SHARED_MEMORY_OBJECTS or _SC_SHARED_MEMORY_OBJECTS - POSIX Shared Memory Objects
            - _POSIX_THREADS or _SC_THREADS - POSIX Threads
            - _XOPEN_UNIX or _SC_OPEN_UNIX - The XSI extension is supported
    
Chapter 12: System and Process Information
    a. The /proc File System
        - /proc virtual file system - resides under /proc, is dynamically written as processes are created, and contains various files that expose kernel information and change it in some cases
        - Obtaining Information About a Process: /proc/PID
            - For each process on the system, the kernel provides a corresponding directory named /proc/PID, where PID is the ID of the process - /proc/1 is data pertaining to init process
            - Example of Information Provided
                - Name: init - name of command run by the process
                - State: S - state of the process
                - Tgid: 1 - thread group ID
                - Pid: 1 - actual thread ID
                - PPid: 0 - parent process ID
                - TracerPid: 0 - PID of tracing process
                - Uid: 0 0 0 0 - real, effective, saved-set, and FS UID
                - Gid: 0 0 0 0 - real, effective, saved-set, and FS GIDs
                - FDSize: 256 - # of file descriptor slots currently allocated
                - Groups: - supplmentary group IDs
                - VMPeak: 852kB - peak virtual memory size
                - VmSize: 724kB - current virutal memory size
                - VmLck: 0kB - locked memory
                - VmHWM: 288kB - peak resident set size
                - VmRSS: 288kb - current resident set size
                - VmData: 148kB - data segment size
                - VmStk: 88kB - stack size
                - VmExe: 484kB - text size
                - VmLib: 0kB - shared library code size
                - VmPTE: 12kB - size of page table
                - Threads: 1 - # of threads in this thread's thread group
                - SigQ: 0/3067 - current/max queued signales
                - SigPnd: 0000000000000 - signals pending for thread
                - ShdPnd: 0000000000000 - signals pending for process
                - SigBlk: 0000000000000 - blocked signals
                - SigIgn: 0000000000000 - ignored signals
                - SigCgt: 0000000000000 - caught signals
                - CapInh: 0000000000000 - inehritable capabilities
                - CapPrm: 0000000000000 - permitted capabilities
                - CapEff: 0000000000000 - effective capabilities
                - CapBns: 0000000000000 - capability bonding set
                - Cpus_allowed: 1 - CPUs allowed, mask
                - Cpus_allowed_list: 0 - Same as above, list format
                - Mems_allowed: 1 -  Memory nodes allowed, mask
                - Mems_allowed_list: 0 - Same as above, list format
                - voluntary_ctxt_switches: 6998 - voluntary context switches
                - nonvoluntary_ctxt_switchs: 107 - involuntary context switches
                - Stack usage:  8 kB
        - Selected files in each /proc/PID directory
            - cmdline - command line arguments delimted by \0
            - cwd - symbolic link to current working directory
            - environ - enviroment list NAME=value pairs, delimited by \0
            - exe - symbolic link to file being executed
            - fd - directory containing symbolic links to files opened by this process
            - maps - memory mappings
            - mem - process virtual memory
            - mounts - mount points for this process
            - root - symbolic link to root directory
            - status - various information e.g. process IDs, credentials, memory usage, signals
            - task - contains one sub directory for each thread in process
        - The /proc/PID/fd directory - /proc/1968/fd/1 - is a symbolic link to the standard output of process 1968
        - Threads: the /proc/PID/task directory - /proc/PID/task/TID - subdirectory for each thread in PID process
        - System Information Under /proc
            - /proc - various system information
            - /proc/net - status information about networking and sockets
            - /proc/sys/fs - settings related to file systems
            - /proc/sys/kernel - various general kernel settings
            - /proc/sys/net - networking and socket settings
            - /proc/sys/vm - memory management settings
            - /proc/sysvipc - information about system V IPC objects
        - Accessing /proc Files - often accessed using shell scripts
        - Accessing fiels in /proc/PID - be careful accessing, plan for possibility process has terminated
    b. System Identification: uname()
        - fn - int uname(struct utsname *utsbuf) - returns a range of identifying information about the host system on which an application is running, in the structure pointed to by utsbuf
            - struct utsname {
                char sysname[_UTSNAME_LENGTH]; - /* Implementation Name */
                char nodename[_UTSNAME_LENGTH]; - /* Node name on the network */
                char release[_UTSNAME_LENGTH]; - /* Implementation release level */
                char version[_UTSNAME_LENGTH]; - /* Release version level */
                char machine[_UTSNAME_LENGTH]; - /* Hardware on which system is running */
                char domainname[_UTSNAME_LENGTH]; - /* NIS domain of the host */
            }
        - fn - sethostname() - sets nodename above
        - fn - setdomainname() - sets domainname above

Chapter 13: File I/O Buffering
    a. Kernel Buffering of File I/O: The Buffer Cache
        - read() and write() don't directly initiate disk access, instead they simply copy data from a user-space buffer and a buffer in the kernel called the buffer cache
        - Effect of Buffer Size on I/O System Call Performance
            - > Buffer Size, up to 1024 bytes, the faster the I/O is performed
            - Elapsed, Total CPU, User CPU, and System CPU is measured
    b. Buffering in the stdio Library
        - Topic: buffering of data into large blocks to reduce system calls is exactly what is done by the C library I/O functions e.g. fprintf(), fscanf(), fgets(), fputs(), fputc(), fgetc()
        - Setting the Buffering Mode of A Stdio Stream
            - fn - int setvbuf(FILE *stream, char *buf, int mode, size_t size) - controls the form of buffering employed by the stdio library
            - buf argument
                - buf is NULL - stdio library automatically allocates a buffer for use with stream
                - buf is non-NULL - points to a block of memory of size bytes that is used as the buffer for stream
            - mode argument
                - _IONBF - don't buffer I/O, each stdio library call results in an immediate write() or read() system call
                - _IOLBF - employ line-buffered I/O
                - _IOFBF - employ fully buffered I/O
            - fn - void setbuf(FILE *stream, char *buf) - controls form of buffering employed
            - fn - void setbuffer(FILE *stream, char *buf, size_t size) - controls form of buffering employed
        - Flushing a stdio buffer
            - fn - int fflush(FILE *stream) - force the data in a stdio output stream to be written i.e. flushed to a kernel buffer via write()
    c. Controlling Kernel Buffering of a File I/O
        - Synchronized I/O Data Integrity and Synchronized I/O File Integrity
            - Synchronized I/O Completion - means an I/O operation that has either been successfully transferrred to the disk or diagnosed as unsuccessful
                - Syncrhonized I/O Data Integrity Completion - ensuring that a file data update transfers sufficient information to allow a later retrieval of that data to proceeed
                - Synchronized I/O File Integrity Completion - during a file update, all updated file metadata is transferred to disk, even if it is not necessary for the operation of a subsequent read of the file data
        - System Calls for Controlling Kernel Buffering of FIle I/O
            - fn - int fsync(int fd) - causes the buffered data and all metadata associatd with the open file descriptor fd to be flushed to disk
            - fn - int fdatasync(int fd) - only forces the file to the synchronized I/O data integrity completion state
            - fn - void sync(void) - causes all kernel buffers containing updated file information to be flushed to disk
        - Making All Writes Synchronous
            - Specifying the O_SYNC flag when calling open() makes all subsequent output synchronous
    e. Summary of I/O Buffering
        - User Data -> stdio Library Calls printf(), fputc(), etc -> stdio buffer -> I/O system calls write(), etc -> Kernel Buffer Cache -> Kernel Initiated Write -> Disk
    f. Advising the Kernel About I/O Patterns
        - fn - int posix_fadvise(int fd, off_t offset, off_t len, int advice) - allows a process to inform the kernel about its likely pattern for accessing file data
            - advice argument
                - POSIX_FADV_NORMAL - process has no special advice to give about access patterns
                - POSIX_FADV_SEQUENTIAL - process expects to read data sequentially from lower offsets to higher offsets
                - POSIX_FADV_RANDOM - process expects to access the data in random order
                - POSIX_FADV_WILLNEED - process expects to access the specified file region in the near future
                - POSIX_FADV_DONTNEED - process expects not to access the specified file region in the near future
                - POSIX_FADV_NORESUE - process expects to access data in the specified file region once, and then not to reuse it
    g. Bypassing the Buffer Cache: Direct I/O
        - Direct I/O - an application bypasses the buffer cache when performing disk I/O, thus transferring data directly from user space to a file or disk device
            - specify the O_DIRECT flag when opening a file or device with open()
        - Alignment Restrictions for Direct I/O
            - The data buffer being transferred must be aligned on a memory boundary that is a multiple of the block size
            - The file or device offset at which data transfer commences must be a multiple of the block size
            - The length of the data to be transferred must be a multiple of the block size
    h. Mixing Library Functions and System Calls for File I/O
        - fn - int fileno(FILE *stream) - returns the corresponding file descriptor
        - fn - FILE *fdopen(int fd, const char *mode) - given a file descriptor, it creates a corresponding stream that uses this descriptor for its I/O

Chapter 14: File Systems
    a. Device Special Files
        - Device Special File - corresponds to a device on the system
        - Each device type has a corresponding device driver, which handles I/O requests for the device
        - API provided by device drivers is fixed and includes operations corresponding to the system calls open(), close(), read(), write(), mmap(), and ioctl()
        - Device Types
            - Character Devices - handle data on a character by character basis. Terminals and keyboards are examples of character devices
            - Block Devices - handle data a block at a time
        - Device IDs
            - Major ID Number - identifies the general class of device, and is used by the kernel to look up the appropriate driver for this type of device
            - Minor ID Number - uniquely identifies a particular device within a general class
    b. Disks and Partitions
        - Disk Drives - hard disk drive is a mechanical device consisting of one or more platters that rotate at high speed
        - Dis Partitions - each disk is divided into one or more (nonoverlapping) partitions. Each partition is treated by the kernel as a separate device residing under the /dev directory
        - Disk Partition Contains
            - file system holding regular files and directories
            - a data area accessed as raw mode device
            - a swap area used by the kernel for memeory management
    c. File Systems - organized collection of regular files and directories
        - Examples - ext2, Minix, System V, and BSD, FAT, FAT32, NTFS, ISO 9660 CD-ROM, HFS, NFS, SMB, NCP, Coda, ext3, ext4, Reiserfs, JFS, XFS, and Btrfs
        - File Sytem Structure
            - Logical Block - basic unit for allocating space in a file system, some multiple of contiguous physical blocks on the disk device e.g. 1024, 2048,, or 4096
            - Boot Block - contains information used to boot the operating system
            - Superblock - single block, contains parameter information about the file system, including:
                - the size of the i-node table
                - the size of logical blocks in this file system
                - the size of the file system in logical blocks
            - I-node Table - each file or directory has a unique entry in the i-node table, this entry records varioous informations about the file
            - Data Blocks - the great majority of space in a file system is used for the blocks of data that form the files and directories residing in the file system
    e. I-nodes
        - Data Contained
            - File type e.g. regular file, directory, symbolic link, characer device
            - Owner
            - Group
            - Access Permissions - U,G,O
            - Three Timestamps
                - time of last access to the file
                - time of last modification of the file
                - time of last status change
            - Number of hard links to the file
            - Size of the file in bytes
            - Number of blocks actually allocated to the file, measured in 512 bytes
            - Pointers to the data blocks of the file
        - I-nodes and Data Block Pointers
            - Important - ext2 doesn't store the data blocks of a file contiguosly or even in sequential order, the kernel maintains a set of pointers in the i-node
            - First 12 - point to first 12 blocks of the file
            - 13th - pointer to a block of pointers that gives the location of the 13th and subsequent data blocks of the file (pointers depends on size, 4 bytes so 256 pointers for a 1024 byte block)
            - 14th - double indirect pointer - points to blocks of pointers that in turn point to blocks of pointers that in turn point to data blocks of the file
    f. The Virtual File System - kernel featrure that creates an abstraction layer for file-system operations
        - Ideas
            - The VFS defines a generic interface for file-system operations. All programs that work with files specify their operations in terms of this generic interface
            - Each file system provides an implementation for the VFS interface
            - Interface Operations for: open(), read(), write(), lseek(), close(), truncate(), stat(), mount(), umount(), mmap(), mkdir(), link(), unlink(), symlink(), and rename()
    g. Journaling File Ssystem 
        - Goal - eliminate the need for length file-system consistency checks after a system crash
        - Journaling - logs all metadata updates to a special on-disk journal file before they are actually carried out. Updates are logged in groups of related metadata updates
            - In the event of system crash, on system reboot, the log can be used to rapildy redo any incomplete updates and bring the file system back to a consistent state
        - Journaling File Systems - Reiserfs, ext3, JFS, XFS, ext4, Btrfs
    h. Single Directory Hierarchy and Mount Points
        - File systems are mounted under the root directory and appear as subtrees within the overall hierarchy
    i. Mounting and Unmounting File Systems
        - Files On Mounted or Mountable
            - /proc/mounts - lis the currently mounted file systems
            - /etc/mtab - contains information that is similar but slightly more detailed, including the file system-specific options given to mount()
            - /etc/fstab - maintained manually by the system administrator, contains descriptions of all of the available file systems on a system
            - File Format
                - /dev/sda9 /boot ext3 rw 0 0
                    - /dev/sda9 - name of the mounted device
                    - /boot - mount point for the device
                    - ext3 - file system type
                    - rw - mount flags
                    - 0 - used to control the operation of file system backups by dump()
                    - 0 - used to control the order in which fsck() checks file systems at system boot time
        - Mounting a File System: mount()
            - fn - int mount(const char *source, const char *target, const char *fstype, unsigned long mountflags, cosnt void *data) - mounts the file system contained on the device specified by source under the directory specified by target
            - mount flags
                - MS_BIND - create a bind mount
                - MS_DIRSYNC - make directory updates synchronous
                - MS_MANDLOCK - permit mandatory locking of files
                - MS_MOVE - atomically move mount point to new location
                - MS_NOATIME - don't update last access time for files
                - MS_NODEV - don't allow access to devices
                - MS_NODIRATIME - don't update last access time for directories
                - MS_NOEXEC - don't allow programs to be executed
                - MS_NOSUID - disable set-user-ID and set-group-ID programs
                - MS_RDONLY - read only mount file
                - MS_REC - recursive mount
                - MS_RELATIME - update last access time only if older than last modification time or last status change time
                - MS_REMOUNT - remount with new mountflags and data
                - MS_STRICTATIME - always update last access time
                - MS_SYNCHRONOUS - make all file and directory updates synchronous
        - Unmounting a File System: umount() and umount2()
             - fn - int mount(const char *target) - unmounts a mounted file system
             - fn - int umount2(const char *target, int flags) - allows finer control over unmount operations via the flags argument
    j. Advanced Mount Features
        - Mounting a File System at Multiple Mount Points
        - Stacking Multiple Mounts on the Same Mount Point
        - Mount Flags that Are Per Mount Options
        - Bind Mounts
        - Recursive Bind Mounts
    k. A Virtual Memory File System: tmpfs
        - mount -t tmpfs source target - creates a tmpfs virtual file system
    l. Obtaining Information About a File System: statvfs()
        - fn - int stavfs(const char *pathname, struct statvfs *statvsbuf) - obtain informatiom about a mounted file system
            - struct statvfs {
                unsigned long f_bsize; /* File System Block Size in Bytes */
                unsigned long f_frsize; /* Fundamental File System System Block Size in Bytes */
                unsigned long f_blocks; /* Total Number of Blocks in File */
                unsigned long f_bfree; /* Total Number of Free Blocks */
                unsigned long f_bavail; /* Number of Free Blocks Available to Unprivileged Process */
                unsigned long f_files; /* Total Number of I-Nodes */
                unsigned long f_ffree; /* Total Number of Free I-Nodes */
                unsigned long f_favail; /* Number of I-Nodes Available to Unprivileged Process */
                unsigned long f_fsid; /* File System ID */
                unsigned long f_flag; /* Mount Flags */
                unsigned long f_namemax; /* Maximum Name of Filenames on this File System */
            }

Chapter 15: File Attributes
    a. Retrieviing File Information
        - fn - int stat(const char *pathname, struct stat *statbuf) - returns info about a named file
        - fn - int lstat(const char *pathname, struct stat *statbuf) - returns info about link if symbolic link
        - fn - int fstat(int fd, struct stat *statbuf) - returns info about a file descriptor
            - struct stat {
                dev_t st_dev; /* IDs of device on which file resides */
                ino_t st_ino; /* I-node number of file */
                mode_t st_mode; /* File type and permissions */
                nlink_t st_nlink; /* Number of hard links to the file */
                uid_t st_uid; /* User ID of the file owner */
                dev_t st_rdev; /* Group ID of the file owner */
                off_t st_size; /* Total file size in bytes */
                blksize_t st_blksize; /* Optimal block size for I/O bytes */
                blkcnt_t st_blocks; /* IDs of device on which file resides */
                time_t st_atime; /* Time of last file access */
                time_t st_mtime /* Time of last file modification */
                time_t st_ctime; /* Time of last status change */
            }
    b. File Timestamps
        - System calls that can change atime, mtime, and ctime
            - chmod(), chown(), exec(), link(), mkdir(), mkfifo(), mknod(), mmap(), msync(), open(), creat(), pipe(), read(), readdir(), removexattr(), rename(), rmdir(), sendfile(), setattr(), symlink(), truncate(), unlink(), utime(), write()
        - Nanesecond Timestamps - 2.6 Linux supports nanosecond resolution for the three timestamp fields of the stat structure
        - Changing File Timestamps with utime() and utimes()
            - fn - int utime(const char *pathname, const struct utimbuf *buf) - can change last file access and modification timestamps
                - struct utimbuf {
                    time_t actime;
                    time_t modtime;
                }
            - fn - int utimes(const char *pathanme, const struct timeval tv[2]) - can change last file access and modification timestamps with microsecond accuracy
            - fn - int futimes(int fd, const struct timeval tv[2]) - can change last file access and modification timestamps of file indicated by file descriptor
            - fn - int lutimes(const char *pathname, cosnt struct timeval tv[2]) - can change last file access and modification timestamps of file or symbolic link
        - Changing File Timestamps with utimensat() and futimens()
            - Advantages
                - Can set timestamps with nanosecond precision
                - It is possible to set the timestamps independently
                - It is possible to independently set either of the timestamps to the current time
            - fn - int utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags) - updates the timestamps of the file specified by pathname to the values specified in the array times
            - fn - int futimens(int fd, const struct timespec times[2]) - updates the timestamps of the file referred to by the open file descriptor fd
    c. File Ownership
        - Ownership of New Files
            - Rule - when a new file is created, its user ID is taken from the effective user ID of the process, on linux this is the file-system user ID
            - When Mounting
                - If you use -o grpid, -o bsdgroups - the group ownership of any new file created is taken from parent directory group ID
                - If you use -o nogrpid, -o sysvgroups
                    - If set-group-ID bit is not enabled - the group ownership of any new files created is taken from the parent directory group ID
                    - If set-group-ID bit is enabled - the group ownership of any new files created is taken from the process effective group ID
            - Changing File Ownership: chown(), fchown(), and lchown() - change the owner user ID and group ID of a file
                - fn - int chown(const char *pathname, uid_t owner, gid_t group) - file named in pathname
                - fn - int lchown(const char *pathname, uid_t owner, gid_t group) - file or link
                - fn - int fchown(int fd, uid_t owner, gid_t group) - fd
    d. File Permissions
        - Permissions on Regular Files
            - Categories - Owner, Group, Other - rwxrwxrwx
            - Permissions
                - Read - the contents of a file may be read
                - Write - the contents of the file may be changed
                - Execute - the file may be executed
        - Permissions on Directories
            - Categories - Owner, Group, Other - rwxrwxrwx
            - Permissions
                - Read - the contents of the directory may be listed
                - Write - files may be created in and removed from the directory
                - Execute - files within the directory may be accessed i.e. search permission
        - Permission Checking Algorithm
            - Rule 1 - if the process is privilege, all access is granted
            - Rule 2 - if the effective user ID of the process is the same as the user ID of the file, then access is granted according to the owner permissions on the file
            - Rule 3 - if the effective group ID of the process or any of the process supplementary group IDs matches the group ID of the file, then access is granted according to the group permissions on the file
            - Rule 4 - otherwise access is granted according to the other permissiosn on the file
        - Permission Checking for Privilege Processes - on Linux, for a file that is not a directory, Linux grants execute permission to a privileged process only if that permission is granted to at least one of the permission categories for the file
        - Checking File Accessibility
            - fn - int access(const char *pathname, int mode) - checks the accessibility of the file based on a process's real user and group IDs and supplementary group IDs
                - mode constants for access
                    - F_OK - Does the file exists?
                    - R_OK - Can the file be read?
                    - W_OK - Can the file be written?
                    - X_OX - Can the file be executed?
        - Sticky Bits - For directories, stickly bit acts as the restricted deletion flag, if set, means an unprivileged process can unlink and rename files in the directory only if it has write permission on the directory and owns either the file or the directory's
        - The Process File Mode Creation Mask: umask()
            - umask - process attribute that specifies which permission bits should always be turned off when new files or directories are created by the process
            - If umask is 022 = ----w--w- - means write permission are automatically turned off for group and other
                - If mode argument to open is 0666, then user would have read and write, while group and other would only have read
                - If mode argument to open is 0777, then user would have read, write, and execute, while group and other would only have read and execute
            - fn - mode_t umask(mode_t mask)
        - Changing File Permissiosn: chmod() and fchmod()
            - fn - int chmod(const char *pathname, mode_t mode) - changes the permssions of the file named in pathname
            - fn - int fchmod(int fd, mode_t mode) - changes the permissions of the file referred to by the open file descriptor fd
    e. I-node Flags (Extended Attribute)
        - FS_APPEND_FL - a - append only
        - FS_COMRP_FL - c - enable file compression
        - FS_DIRSYNC_FL - D - synchronous directory updates
        - FS_IMMUTABLE_FL - i - immutable
        - FS_JOURNAL_DATA_FL - j - enable data journaling
        - FS_NOATIME_FL - A - don't update file last access time
        - FS_NODUMP_FL - d - no dump
        - DS_NOATIL_FL - t - no tail packing
        - FS_SEFCRM_FL - s - secure deletion
        - FS_SYNC_FL - S - synchronous file and directory updates
        - FS_TOPDIR_FL - T - treat as top-level directory for Orlov
        - FS_UNRM_FL - u - file can be deleted

Chapter 16: Extended Attributes
    a. Overview
        - Extended Attributes - allow arbitrary metadata, in the form of name-value pairs
        - EA Namespaces - User, Trusted, System, And Security
            - User - can be manipulated by users
            - Trusted - can only be manipulated by privileged users
            - System - used by the kernel to associate system objects with a file e.g. access control list
            - Security - used to store file security labels for operating system security modules and to associate capabilities with executable files 
        - Creating and Viewing EAS from the Shell
            - setfattr - sets or removes an EA
            - getfattr - gets a specific EA or all EAs assocaited with a file
    b. Extended Attributes Implementation Details
        - Restrictions on User EAs - can only be placed on regular files and directories
        - Implementation Limits
            - the length of an EA name is limited to 255 characters
            - the EA value is limited to 64kb
    c. System Calls for Manipulating Extended Attributes
        - Creating and Modifying EAs
            - fn - int setxattr(const char *pathname, const char *name, const void *value, size_t size, int flags) - set the value of one of the file's EAs 
            - fn - int lsetxattr(const char *pathname, const char *name, const void *value, size_t size, int flags) - set the value of one of the file's EAs 
            - fn - int fsetxattr(int fd, const char *name, const void *value, size_t size, int flags) - set the value of one of the file's EAs 
        - Retrieving the Value of An EA
            - fn - ssize_t getxattr(const char *pathname, const char *name, void *value, size_t size) - retrieves the value of an EA
            - fn - ssize_t lgetxattr(const char *pathname, const char *name, void *value, size_t size) - retrieves the value of an EA
            - fn - ssize_t fgetxattr(int fd, const char *name, void *value, size_t size) - retrieves the value of an EA
        - Removing an EA
            - fn - int removexattr(const char *pathname, const char *name) - removes an EA from a file
            - fn - int lremovexattr(const char *pathname, const char *name) - removes an EA from a file
            - fn - int fremovexattr(int fd, const char *name) - removes an EA from a file
        - Retrieivng the Names of All EAs Associated with a File
            - fn - ssize_t listxattr(const char *pathname, char *list, size_t size) - returns a list containing all the names of all of the EAs associated with a file
            - fn - ssize_t llistxattr(const char *pathname, char *list, size_t size) - returns a list containing all the names of all of the EAs associated with a file
            - fn - ssize_t flistxattr(int fd, char *list, size_t size) - returns a list containing all the names of all of the EAs associated with a file

Chapter 17: Access Control Lists
    a. Overview
        - ACL Entries
            - Tag Type - indicates whether this entry applies to a user, to a group, or to some other category user
                - ACL_USER_OBJ - permissions granted by file owner
                - ACL_USER - permissions granted to user identified by the tag qualifier
                - ACL_GROUP_OBJ - specifies permissions granted to the file groups
                - ACL_GROUP - permissions granted to group identified by the tag qualifier
                - ACL_MASK - specifies permissions that may be granted
                - ACL_OTHER - specifies the permissions that are granted to users that don't match any other ACL entry
            - Tag Qualifier - identifies a specific user or group i.e. a user ID or group ID
            - Permission Set - specifies the permissions (read, write, and execute) that are granted by entry
        - Minimal and Extended ACLS
            - Minimal - semantically equivalent to the traditional file permission set
            - Extended - one that additionally contains ACL_USER, ACL_GROUP, and ACL_MASK
    b. ACL Permission Checking Algorithm
        - Rule 1: if process is privileged then all access is granted
        - Rule 2: if the effective user ID of the process matches the owner of the file, then the process is granted the permissions specified in the ACL_USER_OBJ
        - Rule 3: if the effective user ID of the process matches the tag qualifier in one of the ACL_USER entries, then the process is granted the permissions specified in the ACL_USER, masked against the value of the ACL_MASK
        - Rule 4: if one of the process group IDs i.e. effective group ID or supplementary, matches the file group in ACL_GROUP_OBJ or tag qualifies in any of the ACL_GROUP, then access is determined by either ACL_GROUP_OBJ or ACL_GROUP
    c. Long and Short Text Forms for ACLS
        - Long - ACLs contain one ACL entry per line
        - Short - ACLs consist of sequence of ACL entries separated by commas
    d. ACL_MASK Entry and ACL Group Class
        - ACL_MASK - acts as an upper limit on the permissions granted by ACL entries in the so called group class
        - Group Class - set of all ACL_USER, ACL_GROUP, and ACL_GROUP_OBJ entries in the ACL
    e. The getfacl and setfacl Commands
        - getfacl - view the ACL on a file
        - setfacl - set ACL on a file
    f. Default ACLs and File Creation
        - Default ACL - determines ACLs and permissions that are placed on files and subdirectories that are created in the directory
    g. ACL Implementation Limits
        - ext2, ext3, ext4 - 500
        - XFS - 25
        - Reiserfs - 8191
    h. The ACL API
        - Fetching a File's ACL into Memory - acl_get_file()
        - Retrieving Entries from An In-Memory ACL - acl_get_entry()
        - Retrieving and Modifying Attributes in an ACL Entry
            - Tag Types - acl_get_tag_type() and acl_set_tag_type()
            - Tag Qualifiers - acl_get_qualifier() and acl_set_qualifier()
            - Permission Set - acl_get_permset() and acl_set_permset()
        - Creating and Deleting ACL Entries - acl_create_entry()
        - Updating a Files ACL - acl_set_file()
        - Converting an ACL Between In-Memory and Text Form - acl_from_text() or acl_to_text()
        - Other Functions in the ACL API - acl_calc_mask()

Chapter 18: Directories and Links
    a. Directories and Hard Links
        - Directory - stored in the file system in a similar way to a regular file
            - Directory is marked with a different file type in its i-node-entry
            - Directory is a file with a special organization i.e. a table consisting of filenames and i-node numbers
    b. Symbolic Soft Links
        - Symbolic or Soft Link - a special file type whose data is the name of another file
        - Interpretation of Symbolic Links by System Calls
            - Derefence or Follow - work on the file to which the link refers
            - Don't Dereference - operate directly on the link file itself
        - File Permissiosn and Ownership for Symbolic Links - ignored for most operations
    c. Creating and Removing Hard Links
        - fn - int link(const char *oldpath, const char *newpath) - creates a hard link
        - fn - int unlink(const char *pathname) - removes a hard link  
        - Note - An open file is deleted only when all file decsriptors are closed
    d. Changing the Name of a File
        - fn - int rename(const char *oldpath, const char *newpath) - used to rename and to move it to another directory
    e. Working with Symbolic Links: symlink() and readlink()
        - fn - int symlink(const char *filepath, const char *linkpath) - creates a new symbolic link
        - fn - ssize_t readlink(const char *pathname, char *buffer, size_t bufsize) - retrieves the contents of the link itself
    f. Creating and Removing Directories: mkdir() and rmdir()
        - fn - int mkdir(const char *pathname, mode_t mode) - creates a new directory
        - fn - int rmdir(const char  *pathname) - removes a directory
    g. Removing a File or Directory: remove()
        - fn - int remove(const char *pathname) - removes a file or an empty directory
    h. Reading Directories: opendir() and readdir()
        - fn - DIR *opendir(const char *dirpath) - opens a directory and returns a handle that can be used to refer to the directory in later calls
        - fn - DIR *fdopendir(int fd) - opens a directory and returns a handle that can be used to refer to the directory in later calls
        - fn - struct dirent *readdir(DIR *dirp) - reads successive entries from a directory stream
            - struct dirent {
                ino_t d_ino; /* File i-node number */
                char d_name[]; /* NUll termninated name of file */
            }
        - fn - void rewinddir(DIR *dirp) - moves the directory stream back to the beginning
        - fn - int closedir(DIR *dirp) - closes the open directory stream
        - fn - int dirfd(DIR *dirp) - returns the file descriptor associated with the directory stream
        - fn - int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result) - reentrant read of successive entries from a directory stream
    i. File Tree Walking
        - fn - int nftw(const char *dirpath, int(*func) (const char *pathname, const struct state *statbuf, int typeflag, struct FTW *ftwbuf), int noopenfd, int flags) - walks through the directory tree specified by dirpath and calls the programmer defined function func once for each file in the directory tree
    j. The Current Working Directory of a Process
        - Retrieving the Current Working Directory
            - fn - int char *getcwd(char *cwdbuf, size_t size) - returns a process's current working directory
        - Changing the Current Working Directory
            - fn - int chdir(const char *pathname) - changes the process's current working directory to the relative or absolute pathname specified in pathname
            - fn - int fchdir(int fd) - changes the process's current working directory to the directory specified via a file descriptor previously obtained
    k. Operating Relative to a Directory File Descriptor
    l. Changing the Root Directory of a Process
        - fn - int chroot(const char *pathname) - changes a process's root directory
    m. Resolving a Pathname: realpath()
        - fn - char *realpath(const char *pathname, char *resolved_path) - dereferences all symbolic links in pathname and resolves all references to /. and /.. to produce a null-terminated string containing the corresponding absolute pathname
    n. Parsing Pathname Strings: dirname() and basename()
        - fn - char *dirname(char *pathname) - return directory name
        - fn - char *basename(char *pathanme) - returns file name or end of directory path

Chapter 19: Monitoring File Events
    a. Overview
        - inotify API Key Steps
            - Create an inotify instance
            - Add items to watch
            - Read event notifications
            - Closes the inotify instance
    b. The inotify API
        - fn - int inotify_init(void) - creates a new inotify instance
        - fn - int inotify_add_watch(int fd, const char *pathname, uint32_t mask) - either adds a new watch item to or modifies an existing watch item in the watch list for the inotify instance referred to by the file descriptor
    c. inotify Events
        - IN_ACCESS - file was accessed
        - IN_ATTRIB - file metadata changed
        - IN_CLOSE_WRITE - file opened for writing was closed
        - IN_CLOSE_NOWRITE - file opened read-only was closed
        - IN_CREATE - file/directory created inside watched directory
        - IN_DELETE - file/directory deleted from within watched directory
        - IN_DELETE_SELF - watched file/directory was itself deleted
        - IN_MODIFY - file was modified
        - IN_MOVE_SELF - watched file/directory was itself moved
        - IN_MOVED_FROM - file moved out of watched directory
        - IN_MOVED_TO - file moved into watched directory
        - IN_OPEN - file was opened
        - IN_ALL_EVENTS - shorthand for all of the above input events
        - IN_MOVE - shorthand for IN_MOVED_FROM | IN_MOVED_TO
        - IN_CLOSE - shorthand for IN_CLOSE_WRITE | IN_CLOSE_NOWRITE
        - IN_DONT_FOLLOW - don't dereference symbolic link
        - IN_MASK_ADD - add events to current watch mask for pathname
        - IN_ONESHOT - monitor pathname for just one event
        - IN_ONLYDIR - fail if pathname is not a directory
        - IN_IGNORED - watch was removed by application or by kernel
        - IN_ISDIR - filename returned in name is a directory
        - IN_Q_OVERFLOW - overflow on event queue
        - IN_UNMOUNT - file system containing object was unmounted
    d. Reading inotify Events
        - read() to read events from the inotify file descriptor
            - struct inotify_event {
                int wd; /* Watch descriptor on which event occurred */
                uint32_t mask; /* Bits describing event that occurred */
                uint32_t cookie; /* Cookie for related events */
                uint32_t len; /* Size of 'name' field */
                char name[]; /* Optional null-terminated filename */
            }
    e. Queue Limits and /proc Files
        - /proc/sys/fs/inotify
            - max_queued_events - value is used to set an upper limit on the number of events that can be queued on the new inotify instance
            - max_user_instances - limit on the number of inotify instances that can be created per real user ID
            - max_user_watches - limit on the number of watch items that can be created per real user ID
    f. An Older System for Monitoring File Events: dnotify

Chapter 20: Signals - Fundamental Concepts
    a. Concepts and Overview
        - Signal - a notification to a process that an event has occurred e.g. software interrupt
        - Signal Identifier - unique (small) integer, starting sequentially from 1
        - Categories
            - Traditional/Standard - used by the kernel to notify processes of events
            - Realtime - described later
        - Signal Steps
            - Generated -> Pending -> Delivered
        - Process Handling
            - signal is ignored, that is it is discarded by the kernel and has no effect on the process
            - process is terminated, sometimes referred to as abnormal process termination
            - core dump file is generated and the process is terminated
            - process is stopped
            - execution is resumed
    b. Signal Types and Default Actions
        - SIGABRT - 6 - abort process
        - SIGALRM - 14 - real timer expired
        - SIGBUS - 7 - memory access error
        - SIGCHLD - 17 - child terminated or stopped
        - SIGCONT - 18 - continue if stopped
        - SIGEMT - undef - hardware fault
        - SIGHUP - 1 - hangup
        - SIGFPE - 8 - arithmetic exception
        - SIGILL - 4 - illegal instruction
        - SIGINT - 2 - terminal interrupt
        - SIGNIO - 29 - I/O possible
        - SIGKILL - 9 - sure kill
        - SIGPIPE - 13 - broken pipe
        - SIGPROF - 27 - profiling timer expired
        - SIGPWR - 30 - power about to fail
        - SIGQUIT - 3 - terminal quit
        - SIGSEGV - 11 - invalid memory reference
        - SIGSTKFLT - 16 - stack fault on coprocessor
        - SIGSTOP - 19 - sure stop
        - SIGSYS - 31 - invalid system call
        - SIGTERM - 15 - terminate process
        - SIGTRAP - 5 - trace/breakpoint trap
        - SIGTSTP - 20 - terminal stop
        - SIGTTIN - 21 - terminal read from background
        - SIGTTOU - 22 - terminal write from background
        - SIGURG - 23 - urgent data on socket
        - SIGUSR1 - 10 - user defined signal 1
        - SIGUSR2 - 12 - user defined signal 2
        - SIGVTALRM - 26 - virtual timer expired
        - SIGWINCH - 28 - terminal window size change
        - SIGXCPU - 24 - cpu time limit exceeded
        - SIGXFS - 25 - file size limit exceeded
    c. Changing Signal Dispositions: signal()
        - fn - void (*signal(int sig, void (*handler)(int)))(int) - changes the signal handler of a signal for a process
    d. Introduction to Signal Handlers
        - Signal Handler - a function that is called when a specified signal is delivered to a process
        - Flow
            - Start of Program
            - Delivery of Signal
            - Kernel Calls Signal Handler
            - Signal Handler Code Executed
            - Program Resumes at Interruption Point
    e. Sending Signals: kill()
        - fn - int kill(pid_t, int sig) - how a process sends a signal to another process
            - pid options
                - pid > 0, signal is sent to the process with the process ID specified by pid
                - pid = 0, signal is sent to every process in the same process group as the calling process, including the process itself
                - pid < -1, signal is sent to all of the processes in the process group whose ID equals the absolute value of pid
                - pid = -1, signal is sent to every process for which the calling process has permission to send a signal, except init and the calling process
                    - if a privileged process makes this request, then all processes on the system will be signaled, except for init and calling process
    f. Checking for the Existence of a Processss
        - fn - int kill(pid_t, int sig) - if sig is specified as 0, then no signal is sent, instead kill() performs error checking to see if the process can be signaled, in turn cehck to see if specific process with ID exists
        - Other Techniques
            - wait() - checks particular process exists only if the monitored process is a child of the caller
            - semaphores and exclusive file locks - if a process holds a sempahore or file lock, then if we can acquire the semaphore or lock we know the process has terminated
            - IPC channels such as pipes and FIFOs - set up process so that it holds a file descriptor open for writing on the channel, then monitoring process holds open a read descriptor for the channel, and it knows monitored process has terminated when it sees end of file
            - /proc/PID interface - if /proc/ID exists, then process exists
    g. Other Ways of Sending Signals
        - fn - int raise(int sig) - process sends a signal to itself, equivalent to kill(getpid(), sig) or pthread_kill(pthread_self(), sig)
        - fn - int killpg(pid_t pgrp, int sig) - sends a signal to all of the members of a process group
    h. Displaying Signal Descriptions
        - fn - char *strsignal(int sig) - returns a pointer to a printable decsription of the signal
        - fn - void psignal(int sig, const char *nsg) - displays the string given in its argument msg, followed by a colon, and then the signal description corresponding to sig, local sensitive
    i. Signal Sets - represent group of different signals
        - fn - int sigemptyset(sigset_t *set) - initializes a signal set to contain no members
        - fn - int sigfillset(sigset_t *set) - initializes a set to contain all signals
        - fn - sigaddset(const sigset_t *set, int sig) - add signal to set 
        - fn - sigdelset(cosnt sigset_t *set, int sig) - remove signal from set
        - fn - int sigismember(const sigset_t *set, int sig) - returns 1 if sig is a member of set and 0 otherwise
        - fn - sigandset(sigset_t *dest, sigset_t *left, sigset_t *right) - places the intersection of the sets left and right in the set dest
        - fn - sigorset(sigset_t *dest, sigset_t *left, sigset_t *right) - places the union of the sets left and rigth in the set dest
        - fn - int sigisemptyset(const sigset_t *set) - returns true if set contains no signals
    j. The Signal Mask (Blocking Signal Delivery)]
        - Signal Mask - a set of signals whose delivery to the process is currently blocked. If a signal that is blocked is sent to a process, delivery of that signal is delayed until it is unblocked by being removed from the process signal mask
        - fn - int sigprocmask(int how, const sigset_t *set, sigset_t *oldset) - change the process signal mask, to retrieve the existing mask, or both
            - how arguments
                - SIG_BLOCK - signals specified in the signal set pointed to by set are added to the signal mask. Signal mask is set to the union of its current value and set
                - SIG_UNBLOCK - signals specified in the signal set pointed to by set are removed from the signal mask
                - SIG_SETMASK - signal set pointed to by set is assigned to the signal mask
    k. Pending Signals
        - fn - int sigpending(sigset_t *set) - determines which signals are pending for a process
    l. Signals Are Not Queued
        - The Point: Standard set of pending signals is only a mask, it indicates whether or not a signal has occurred, but now how many times it has occurred. Real time signals are queued
    m. Changing Signal Dispositions: sigaction()
        - fn - int sigaction(int sig, const struct sigaction *act, struct signaction *oldact) - sets disposition and allows you to retrieve the disposition of a signal without changing it, and to set various attributes controlling precisely what happens when a signal handler is invoked
            - sig - identifies the signal whose disposition we want to retrieve or change
            - act - pointer to a structure specifying a new disposition for the signal
            - oldact - used to return information about the signal's previous disposition
            - struct sigaction {
                void (*sa_handler)(int); - /* Address of Handler */
                sigset_t sa_mask; /* Signals blocked during hanlder invocation */
                int sa_flags; /* Flags controlling handler invocation */
                void (*sa_restorer)(void) - /* Not for application user */
            }
            - sa_flags
                - SA_NOCLDSTOP - if sig is SIGCHLD, don't generate this signal when a child process is stopped or resumed as a consequence of receiving a signal
                - SA_NOCLDWAIT - if sig is SIGCHLD, don't transform children into zombies when they terminate
                - SA_NODEFER  - when the signa is caught, do not automatically add it to the process signal mask while the handler is executing
                - SA_ONSTACK - invoke the handler for this signal using an alternate stack installed by sigaltstack()
                - SA_RESETHAND - when signal is caught, reset it's disposition to default
                - SA_RESTART - automatically restart system calls interrupted by this signal handler
                - SA_SIGINFO - invoke the signal handler with additional arguments providing further information about the signal
    n. Waiting for a Signal: pause()
        - fn - int pause(void) - suspends execution of the process until the call is interrupted by a signal handler

Chapter 21: Signals - Signal Handlers
    a. Designing Signal Handlers
        - Two Common Designs
            - Signal handler sets a global flag and exits. The main program periodically checks this flag and it it is set, takes appropriate action
            - Signal handler performs some type of cleanup and then either terminates the process or uses a nonlocal goto to unwind the stack and return control to a predetermined location in the main program
        - Signals Are Not Queued
        - Rentrant and Async Signal Safe Functions
            - Rentrant - it can safely be simultaneously executed by multiple threads of execution in the same process, safe means functions achieves its expected result, regardless of the state of execution
            - Nonentrant - if function updates global or static data structures
        - Async-Signal-Safe Functions - one that the implementation guarantees to be safe when called from a signal handler i.e. nonrentrant or not interruptible by a signal handler
        - Async-Signal-Safe Table List on pg. 426
        - Global Variables and the sig_atomic_t Data Type
            - If looking to share global variables between main program and a signal handler, use atomic read and write integer data type called sig_atomic_t
    b. Other Methods of Terminating a Signal Handler
        - exit() - terminate the process
        - kill() or raise() to send a signal that kills the process
        - Perform a nonlocal goto from the signal handler, use sigsetjmp and siglongjmp to manage changes to process signal mask
        - abort() - terminate the process with a core dump
    c. Handling a Signal on An Alternate Stack: sigalstack()
        - Why - ensure that when a process grows beyond its stack and generates a SIGSEGV signal for the process, the SIGSEGV can be handled by a signal handler
        - fn - int sigalstack(const stack_t *sigstack, stack_t *old_sigstack) - establishes an alternate signal stack and returns information about any alternate signal stack that is already established
    d. The SA_SIGINFO FLag - allows handler to obtain additional information about a signal when it is delivered
        - typedef struct {
            int si_signo; /* Signal Number */
            int si_code; /* Signal Code */
            int si_trapno; /* Trap number for hardware generated signal */

            union sigval si_value; /* Accompanying data from sigqueu() */
            pid_t si_pid; /* Process ID of the sending process */
            uid_t si_uid; /* Real user ID of the sender */
            int si_errno; /* Errro Number */
            void si_addr; /* Address that generated signal */

            int si_overrun; /* Overrun Count */
            int si_timerid; /* Timer ID */

            long si_band; /* Band event */
            int si_fd; /* File descriptor */
            int si_status; /* Exit status or signal */

            clock_t si_utime si_fd; /* User CPU Time */
            clock_t si_stime ; /* System CPU Time */
        }
    e. Interruption and Restarting of System Calls
        - Manually Handle Restart of System Call
        - Use SA_RESTART to permit automatic restarting of system calls

Chapter 22: Signals - Advanced Features
    a. Core Dump Files
        - Core Dump - a file containing a memory image of the process at the time it was terminated
        - Circumstances in Which Core Dump Files Are Not Produced
            - Process doesn't have permission to write the core dump file
            - A regular file with the same name already exists, and it is writable, but there is more than one hard link to the file
            - The directory in which the core dumpe file is to be created doesn't exist
            - The process resource limit on the size of a core dump file is set to 0
            - The process resource limit on the size of a file that may be produced is set to 0
            - The binary executable file that the process is executing doesn't have read permissions enabled
            - The file system on which the current working directory resides is mounted read only, full, or has no i-nodes
        - Naming the Core Dump File: /proc/sys/kernel/core_pattern
            - Use a format string in the /proc/sys/kernel/core_pattern file
            - Specificers and Replacements
                - %c - core file size soft resource limit
                - %e - executable filename
                - %g - real group ID of dumped process
                - %h - name of host system
                - %p - process ID of dumped process
                - %s - number of signal that terminated process
                - %t - time of dump, in seconds since Epoch 
                - %u - real user ID of dumped process
                - %% - a single % character
    b. Special Cases for Delivery, Disposition, and Handling
        - SIGKILL and SIGSTOP - always terminates and stops a process respectively
        - SIGCONT and stp signals - if stopped SIGCONT always causes resume, pending signals are discarded
    c. Interruptible and Uninterruptible Process States
        - TASK_INTERRUPTIBLE - operations can be interrupted by signals
        - TASK_UNINTERRUPTIBLE - signals are not delivered until process exists this state
        - TASK_KILLABLE - wakes process if signal is fatal
    d. Hardware Generated Signals - SIGBUS, SIGFPU, SIGILL, SIGSEGV
        - Returning from the Signal Handler - infinite loop
        - Ignoring the Signal - shouldn't ignore due to unexpected behavior
        - Blocking the Signal - shouldn't block due to unexpected behavior
    e. Synchronous and Asynchronous Signal Generation
        - Asynchronous - process can't predictr when the signal will be delivered holds true
        - Synchronous - signal is delivered immediately
    f. Timing and Order of Signal Delivery
        - When is a signal delivered?
            - When the process is reschedulded after it earlier timed out
            - At completion of a system call
        - Order of Delivery of Multiple Unblocked Signals
            - All signals are immeditaly delivered to the process in ascending order i.e. lower signals first
    g. Implemenation and Portability: signal()
    h. Realtime Signals
        - Advantages
            - Increased range of signals that can be used for application-defined purposes
            - Signals are queued
            - Can include an integer or pointer value as data
            - Order of delivery of different signals is guaranteed, if multiple signals of the same type they are delivered in the same order they were sent
        - Limits on the Number of Queued Realtime Signals - _POSIX_SIGQUEUE_MAX or _SC_SIGQUEUE_MAX
        - Using Realtime Signals
            - fn - int sigqueue(pid_t pid, int sig, const union sigval value) - sends the realtime signal specified by sig to the process specified
            - sigaction - establishes a signal handler for realtime signals
        - Handling Realtime Signals
    i. Waiting for a Signal Using a Mask: sigsuspend()
        -  fn - int sigsuspend(const sigset_t *mask) - atomically unblocks a signal and suspends the process 
    j. Synchronously Waiting for a Signal
        - fn - int sigwaitinfo(const sigset_t *set, siginfo_t *info) - suspends execution of the process until one of the signals in the signal set pointed to by set becomes pending
    k. Fetching Signals via A File Descriptor
        -  fn - int signalfd(int fd, sigset_t *mask, int flags) - creates a special file descriptor from which signals directed to the caller can be read
    l. Interprocess Communication with Signals
        - Disadvantages
            - Reentrancy Requirements
            - Race Conditions
            - Handling of Global Variables
            - Standard Signals Not Queued
            - Signals Carry Limited Information

Chapter 23: Timers and Sleeping
    a. Interval Timers
        - fn - int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)
            - establishes a timer interval, which is a timer that expires at a future point in time and optionally at regular intervals after that
            - Types of Timers
                - ITIMER_REAL - creater a timer that counts down in real time, sends SIGALRM signal when timer expires
                - ITIMER_VIRTUAL - create a timer that counts down in process virtual time, sends SIGVTALRM signal when timer expires
                - ITIMER_PROF - create a profiling timer, counts time in process i.e. sum of user-mode and kernel mode CPU time, sends SIGPROF signal when timer expires
        - fn - int getitimer(int which, struct itimerval *curr_value) - returns the current state of the timer specified by which
        - Simpler Timer Interface: alarm()
            - fn - unsigned int alarm(unsigned int seconds) - establishes a real time timer that expires once, with no repeating interval
        - Interactions between setitimer() and alarm() - both share the same per-process real-time timer, setting a timer with one function changes any timer previously set by either of the functions
    b. Scheduling and Accuracy of Timers
        - High Resolution Timers - as accurate as the underlying hardware allows
    c. Setting Timeouts on Blocking Operations
        - Use - place an upper limit on the time for which a blocking system call can remain blocked e.g. cancel a read() from a terminal if user has not entered input within a certain time
    d. Suspending Execution for a Fixed Interval (Sleeping)
        - Low Resoution Sleeping: sleep()
            - fn - unsigned int sleep(unsigned int seconds) - suspends execution of the calling thread for the number of seconds specified in the seconds argument or until a signal is caught
        - High Resolution Sleeping: nanosleep()
            - fn - int nanosleep(const struct timespec *request, struct timespec *remain) - same as sleep with finer resolution when specifying the sleep interval
    e. POSIX Clocks
        - Retrieving the Value of a Clock: clock_gettime()
            - fn - int clock_gettime(clockid_t clockid, struct timespec *tp) - returns the time according to the clock specified in clockid
            - fn - int clock_getres(clockid_t clockid, struct timespec *res) -  returns the resolution of the clock specified in clockid
            - Clock Types
                - CLOCK_REALTIME - settable system-wide real-time clock
                - CLOCK_MONOTONIC - nonsettable monotonic clock
                - CLOCK_PROCESS_CPUTIME_ID - per process CPU time clock
                - CLOCK_THREAD_CPUTIME_ID - per thread CPU time clock
        - Setting the Value of a Clock: clock_settime()
            - fn - int clock_settime(clockid_t clockid, const struct timespec *tp) - sets the clock specified by clockid to the time supplied in the buffer pointed to by tp
        - Obtaining the Clock ID of a Specific Process or Thread
            - fn - int clock_getcpuclockid(pid_t pid, clockid_t *clockid) - returns the identifier of the CPU time clock of the process whose ID is pid, use this to call gettime to find out the CPU time consumed
        - Improved High Resolution Sleeping: clock_nanosleep()
            - fn - int clock_nanosleep(clockid_t clockid, int flags, cons struct timespec *request, struct timespec *remain) - suspends the calling process until either a specified interval of time has passed or a signal arrives
    f. POSIX Interval Timers
        - Timer Steps
            - timer_create() - creates a new timer and defines the method by which it will notify the process when it expires
            - timer_settime() - arms (starts) or disarms (stops) a timer
            - timer_delete() - deletes a timer that is no longer required
        - Creating a Timer: timer_create()
        - Arming and Disarming a Timer: timer_settime()
        - Retrieving the Current Value of a Timer: timer_gettime()
        - Deleting a Timer: timer_delete()
        - Timer Overrun
            - fn - int timer_getoverrun(timer_t timerid) - returns the overrun count for the timer specified by timerid
    g. Timers that Notify via File Decsriptors: The timerfd API
        - fn - int timerfd_create(int clockid, int flags) - creates a new timer object and returns a file decsriptor referring to that object
        - fn - int timerfd_settime(int fd, int flags, const struct itimerspec *new_value, struct itimerspec *old_value) - starts or stops the timer referred to be fd
        - fn - int timerfd_gettime(int fd, struct itimerspec *curr_value) - returns the interval and remaining time for the timer identified by the file descriptor fd

Chapter 24: Process Creation
    a.  Overview of fork(), exit(), wait(), and execve()
        - fork() - allows one process, the parent, to create a new process, the child, the child is almost an exact duplicate of the parent i.e. stack, data, heap, and text segments
        - exit(status) - terminates a process, making all resources i.e. memory, open file descriptors, etc, used by the process available for subsequent reallocation by the kernel
        - wait(&status)
            - if a child of this process has not yet terminated, wait suspends execution of the proces until one of its children has terminated
            - termination status of the child is returned in the status argument
        - execve(pathname, argv, envp) - loads a new program (pathname) with argument list (argv) and environment list (envp) into a process's memory
        - Order
            - Parent Process A
            - Parent Process A - calls fork()
            - Parent Process A - calls wait()
            - Child Process A
            - Child Process A - calls exit(status)
            - Parent Process A - Starts, receives SIGCHLD
    b. Creating a New Process: fork()
        - fn - pid_t fork() - creates a new process, the child, which is an almost exact duplicate of the calling process, the parent
            - After invocation, two processes exist, and in each process execution continues from the point where fork() returns
        - File Sharing Between Parent and Child - child receives duplicates of all of the parent's file descriptors, which means they share them
        - Memory Semantics of fork() - actual copying is too much work
            - Kernel marks text segment of each process as read-only, so that process can't modify its own code, so parent and child can share text segment
            - Copy-on-Write for data, heap, and stack segments, kernel traps any attempts to modify one of these pages and instead makes a duplicate, parent and child can modify copies without affecting each other
        - Controlling a Process's Memory Footprints - use fork() and wait() to control memory footprint
    c. The vfork() System Call
        - fn - pid_t vfork(void) - create a new child process, designed to be used in porograms where the child performs an immediate exec() call
            - No duplication of virtual memory pages is done for the child process
            - Execution of the parent process is suspended until child has performed exit() or _exit()
    d. Race Conditionals After fork() - it is indeterminate which process, the parent or the child, next has access to the CPU
    e. Avoiding Race Conditions by Synchronizing with Signals
        - Parent Process - Add Signal Handler
        - Parent Process - Call Fork
        - Parent Process - Wait for Signal
        - Child Process - Created
        - Child Process - Send Signal to Parent Process and Exit
        - Parent Process - Continue Exeuction

Chapter 25: Process Termination
    a. Terminating a Process: _exit() and exit()
        - Abnormal Termination - caused by the delivery of a signal whose default action is to terminate the process
        - Normal Termination - exit(), _exit(), or return from main
        - fn - void exit(int status) - termiantes a process normally
        - fn - void exit(int status)
            - Exit hanlders are called, in reverse order of their registration
            - The stdio stream buffers are flushed
            - The _exit() system call is invoked, using the value supplied in status
    b. Details of Process Termination
        - Open file descriptors, directory streams, and conversion descriptors are closed
        - File locks held by process are released
        - System V shared memory segments are detached
        - If controlling process, SIGHUP signal is sent to each process in the controlling terminal's foreground process group, and terminal is disassociated from the session
        - Any POSIX named semaphores that are open in the calling process are closed
        - Any POSIX message queues that are open in the calling process are closed
        - If any process orphans, all processes in the group are sent a SIGHUP followed by a SIGCONT signal
        - Any memory locks are removed
        - Any memory mappings are unmapped
    c. Exit Handlers - programmer supplied function that is registered at some point during the life of the process and is then automatically called during normal process termination via exit()
        - Registering Exit Handlers
            - fn - int atexit(void (*func)(void)) - adds func to list of functions that are called when the process terminates
            - fn - int on_exit(void (*func)(int, void *), void *arg) - adds func to list of functions that are calledn when the process terminates, function can have arguments

Chapter 26: Monitoring Child Processes
    a. Waiting on a Child Process
        - The wait() System Call
            - fn - pid_t wait(int *status) - wait for one of the children of the calling process to terminate and returns its termination status
            - If no child has terminated, wait blocks, if child has already terminated, immediately returns
            - If status is not null, information about how the child terminated is returned
            - Kernel adds the process CPU times and resource usage statistics to running total for all the children of this parent process
            - wait() returns the process ID of the child that has terminated
        - The waitpid() System Call
            - allows waiting for a specific child
            - is non blocking
            - able to be notified when a child has been stopped, resumed, or terminated
            - fn - pid_t waitpid(pid_t pid, int *status, int options)
                - pid > 0, wait for child whose process ID is pid
                - pid = 0, wait for any child in same process group
                - pid < -1, wait for any child whose process group is absolute value of pid
                - id = -1, wait for any child
            - option
                - WUNTRACED - return information when a child is stopped
                - WCONTINUED - return information about children that have resumed
                - WNOHANG - if no changed state, return immediately instead of blocking
        - THe Wait Status Value
            - child terminated by calling _exit() or exit()
            - child was terminated
            - child was stopped
            - child was resumed
        - Process Termination from a Signal Handler
            - Child signal handler raises signal itself for custom handling
        - The waitid() System Call
            - fn - int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options)
            - options
                - WEXITED - wait for children that have terminated
                - WSTOPPED - wait for children that have been stopped
                - WCONTINUED - wait for children that have been resumed
                - WNOHANG - return immediately if no child has status information
                - WNOWAIT - child remains in waitable state, status is returned
        - The wait3() and wait4() System Calls - return resource usage information about the terminated child
    b. Orphans and Zombies
        - Orphan - parent process terminates before child, adopted by init and waited to remove
        - Zombie - terminates before Parent has called wait(), must be reaped at some point i.e. reaping loop on pg. 556
    c. The SIGCHLD SIgnal
        - Establishing a Handler for SIGCHLD - signal sent to process whenever child terminates, must reap repeatedly until all zombie children are handled
        - Delivery of SIGCHLD for Stopped Children - possible
        - Ignoring Dead Child Processes - set disposition of SIGCHLD to SIG_IGN causes any child process that subsequently terminhates to be immediately removed from the system instead of being converted into a zombie

Chapter 27: Program Execution
    a. Executing  a New Program: execve()
        - Action - loads a new program into a process's memory, old program is discareded and the stack, data, and heap are replaced
        - Use - inside child produced by fork()
        - fn - int execve(const char *pathname, char *const argv[], char *const envp)
            - pathname - path to new program
            - argv - arguments list
            - envp - environment list
        - Errors
            - EACCES - pathname doesnt refer to a regular file, execute permission is disabled, or directory is not searchable
            - ENOENT - file doesn't exist
            - ENOEXEC - file is marked as executable but not in a recognizable format
            - ETXTBSY - file is opened for writing
            - E2BIG - space required for argv and envp execeeds maximum
    b. The exec() Library Functions
        - fn - int execle() - pathname
        - fn - int execlp() - filename
        - fn - int execvp() - filename
        - fn - int execv() - pathname
        - fn - int execl() - pathname
        - The PATH Environment Variables - string consisting of colon-separated directory names called path prefixes, searched when looking for a file
        - Passing the Caller's Environment to the New Program
            - execlp(), execvp(), execl(), and execv() inherit environment from calling process
        - Executing a File Referred to by a Descriptor: fexecve()
            - fn - int fexecve()
    c. Interpreter Scripts
        - Interpreter - a program that reads commands in text form and executes them
        - Unix - allows interpreter scripts to be run in the same way as a binary program file
    d. File Descriptors and exec()
        - Default - all file descriptors opened by a program that calls exec() remain open across the exec() and are available for use by the new program
        - The close-on-exec flag FD-CLOEDXEC - ensure certain file descriptors are closed befor exec()
    e. Signals and exec()
        - Kernel resets the dispositions of all handled signals to SIG_DFL
    f. Executing a Shell Command: system()
        - fn - int system(const char *command) - allows the calling program to execute an arbitrary shell command

Chapter 28: Process Creation and Program Execution in More Detail
    a. Process Accounting
        - Action - kernel writes an accounting record to the system wide process accounting file as each process terminates
        - Enabling and Disabling Process Accounting
            - fn - int acct(const char *acctfile) - enables process accounting for a file
        - Processs Accounting Records
            - struct acct {
                char ac_flag; /* Accounting Flags */
                u_int16_t ac_uid; /* User ID of the Process */
                u_int16_t ac_gid; /* Group ID of the Process */
                u_int16_t acl_create_entry; /* Controlling Terminal of Process */
                u_int32_t ac_btime; /* Start Time */
                comp_t ac_utime; /* User CPU Time */
                comp_t ac_stime; /* System CPU Time */
                comp_t ac_etime; /* Elapsed Real Time */
                comp_t ac_mem; /* Average Memory Usage */
                comp_t ac_io; /* Bytes Transferred */
                comp_t ac_rw; /* Bloks Read Written */
                comp_t ac_minflt; /* Minor Page Faults */
                comp_t ac_majflt; /* Major Page Faults */
                comp_t ac_swaps; /* Number of Swaps */
                u_int32_t exitcode; /* Process Termination Status */
            }
            - ac_flag
                - AFORK - process was created by fork()
                - ASU - process made use of superuser privileges
                - AXSIG - process was terminated by a signal
                - ACORE - process produced a core dump
    b. The clone() System Call
        - fn - int clone() - creates a new process with finer control
    c. Speed of Process Creation
        - Speed Ranking (Fastest to Slowest)
            - clone() -> vfork() -> fork() -> vfork() + exec() -> fork() + exec()\

Chapter 29: Threads - Introduction
    a. Overview
        - Threads - mechanisms that permits an application to perform multiple tasks concurrently, multiple threads can exist in a single process, share same global memory including initialized data, uninitialized data, and heap segments
        - Shared Attibutes
            - process ID and parent process ID
            - process group ID and session ID
            - controlling terminal
            - process credentials
            - open file descriptor
            - recrod locks created using fork()
            - signal dispositions
            - umask, cwd, root directory
            - interval timers
            - System V Semaphore
            - resource limits
            - CPU time consumed
            - resourecs consumed
            - nice value
        - Distinct Attributes
            - thread ID
            - signal mask
            - thread specific data
            - alternate signal stack
            - errno variable
            - floating point environment
            - real time scheduling policy and priority
            - CPU affinity
            - capabilities
            - stack
    b. Background Details of the Pthreads API
        - Data Types
            - pthread_t - thread identifier
            - pthread_mutex_t - mutex
            - pthread_mutexattr_t - mutex attributes
            - pthread_cond_t - conditiona variable
            - pthread_condattr_t - conditional variable attributes
            - pthread_key_t - key for thread specific data
            - pthread_once_t - one time initialization
            - pthread_attr_t - thread attributes object
    c. Thread Creation
        - fn - int pthread_create() - new thread commences execution by calling the function identified by start with the argument arg
    d. Thread Termination
        - fn - void pthread_exit(void *retval) - terminates the calling thread and specifies a return value that can be obtained by caling pthread_join()
    e. Thread IDs
        - fn - pthread_t pthread_self(void) - returns unique process ID
        - fn - int pthread_equal() - allows us to check whether two thread IDs are the same
    f. Joining with a Terminated Thread
        - fn - int pthread_join(pthread_t thread, void **retval) - waits for the thread identified by thread to terminate
    g. Detaching a Thread
        - fn - int pthread_detach(pthread_t thread) - clean up and remove a thread when it terminates without allowing waiting

Chapter 30: Threads - Thread Synchronization
    a. Protecting Accesses to Shared Variables: Mutexes
        - Issue - multiple threads attempting to modify the same variable at the same time, or thread attempting to read the value of a variable while another thread is modifying it
        - Pattern
            - lock the mutex for a shared resource
            - access the shared resource
            - unlock the mutex
        - Statically Allocated Mutexes
            - Allocated as a static variable
            - Created dynamically at run time
        - Intiailization - pthread_mutex_t mtx = PTHREAD_MUTEX_INTIALIZER
        - Locking and Unlocking a Mutex
            - fn - int pthread_mutex_lock(pthread_mutex_t *mutex) - locks a mutex
            - fn - int pthread_mutex_unlock(pthread_mutex_t *mutex) - unlocks a mutex, can only be done by the thread that locked the mutex
            - note - it is indeterminate which thread acquires an unlocked mutex
        - Extras
            - fn - pthread_mutex_trylock() - attempts to lock mutex, fails if currently locked
            - fn - pthread_mutex_timedlock() - attempts to lock mutex, can sleep while waiting to acquire mutex
        - Performance of Mutexes
            - Mutex are implemented using atomic machine language operations and require system calls only in case of lock contention
        - Mutex Deadlocks
            - Issue - multiple threads accessing two or more shared resources, each governed by a mutex
            - Solution - define mutex hierarchy i.e. threads should lock the mutexes in the same order
        - Dynamically Initializing a Mutex
            - fn - int pthread_mutex_init() - dynamically initializes a mutex
            - fn - int pthread_mutex_destroy() - destroys dynamically intiailized mutex
        - Mutex Attributes
            - Mutex Types
                - PTHREAD_MUTEX_NORMAL - self deadlock detection is not provided for this type of mutex
                - PTHREAD_MUTEX_ERRORCHECK - error checking is performed on all operations
                - PTHREAD_MUTEX_RECURSIVE - maintains the concept of a lock count
    b. Signaling Changes of State: Condition Variables
        - Condition Variable - allows one thread to inform other threads about changes in the state of a shared variable or other shared resources and allows other threads to wait for such notification
        - Statically Allocated Condition Variables
            - Initialization - pthread_cond_t cond = PTHREAD_COND_INITIALIZER
        - Signaling and Waiting on Condition Variables
            - fn - int pthread_cond_signal(pthread_cond_t *cond) - signal the condition variable specified by cond, guarantees that at least one of the blocked threads is woken up
            - fn - int pthread_cond_broadcast(pthread_cond_t *cond) - signal the conditional variable specified by cond, all blocked threads are woken up
            - fn - int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex) - blocks a thread until the condition variable cond is signaled
            - fn - int pthread_cond_timedwait() - blocks a thread, for a limited time, until the condition variable cond is signaled
        - Dynamically Allocated Condition Variables
            - fn - int pthread_cond_init() - dynamically initializes a condition variable
            - fn - int pthread_cond_destroy(pthread_cond_t *cond) - destroys a dynamically initialized condition variable

Chapter 31: Threads - Thread Safety and Per-Thread Storage
    a. Thread Safety and Reentrancy Revisited
        - Thread-Safe - it can safely be invoked by multiple threads at the same time
        - Achieving Thread Safety - associate a mutex with a shared variable in critical sections
        - Non-Thread-Safe Function - table 31-1 on pg. 657
        - Reentrant and Nonreentrant
            - Reentrant - achieves thread safety without the use of mutexes by avoiding the use of global or static variables
    b. One-Time Initialization
        - fn - int pthread_once() - calls a caller defined function once to do initialization work
    c. Thread Specific Data
        - Technique - make an existing function thread safe without changing its interface by maintaining a separate copy of a variable for each thread that calls the function
        - Overview of Thread Specific Data API
            - function creates a key, which differentiates items used by function from eachother
            - function allocates a thread specific data block for each thread
            - function saves pointer associated with key
        - Details of the Thread Specific Data API
            - fn - int pthread_key_create() - creates a new thread specific data key that is returned to the caller
            - fn - int pthread_setspecific() - save a copy of value in data structure that associates it with the calling thread and with key
            - fn - void pthread_getspecific() - returns previoulsy saved value associated with the given key for this thread
    d. Thread Local Storage
        - Action - provides persistent per-thread storage

Chapter 32: Threads - Thread Cancellation
    a. Canceling a Thread
        - fn - int pthread_cancel() - sends a cancellation request to the specified thread
    b. Cancellation State and Type
        - fn - int pthread_setcancelstate() - set flag that controls cancel state
            - PTHREAD_CANCEL_DISABLE - the thread is not cancelable
            - PTHREAD_CANCEL_ENABLE - the thread is cancelable - default
        - fn - int pthrhead_setcanceltype() - set flag that controls cancel type
            - PTHREAD_CANCEL_ASYNCHRONOUS - the thread can be cancelled at any time
            - PTHRHEAD_CANCEL_DEFERRED - the cancellation remains pending until a cancellation point is reached - default
    c. Cancellation Points - location where cancellation is acted upon
        - Table 32-1 - cancellation points
    d. Testing for Thread Cancellation
        - fn - void pthread_testcancel() - acts as a cancellation point for threads that don't have one e.g. compute loop
    e. Cleanup Handlers
        - fn - void pthread_cleanup_push() - add clean up handler to thread's stack of cleanup handlers
        - fn - pthread_cleanup_pop() - removes clean up handler from thread's stack of cleanup handlers
        - Note - each use of push must be paired with pop in th e same lexical block

Chapter 33: Threads - Further Details
    a. Thread Stacks
        - Each thread has its own stack whose size is fixed when the thread is created
        - fn - pthread_attr_stacksetsize() - changes the size of the stack
        - fn - pthread_attr_setstack() - changes size of stack and location
    b. Threads and Signals
        - Insight - avoid combining signals and threads whenever possible
        - How the UNIX Signal Model Maps to Threads
            - Signal actions are process wide
            - Signal dispositions are process wide
            - Signal may directed to either the process as a whole or specific thread
            - Kernel arbitrarily selects a thread to deal with signals delieverd to a multithreaded process
            - Signal mask is per thread
            - Kernel maintains a record of the siognals that are pending for the process as well as for each thread
        - Manipulating the Thread Signal Mask
            - fn - int pthread_sigmask() - changes thread's signal mask
        - Sending a Signal to a Thread
            - fn - int pthread_kill() - sends the signal sig to a thread in the same process
            - fn - int pthread_sigqueue() - combines kill and quue functionality, sends a signal with accompanying data to a thread in the same process as the caller
        - Dealing with Asynchronous Signals Sanely
            - Preferred Approach
                - All threads block all of the asynchronous signals that the process might receive
                - Create a single dedicated thread that accepts incoming signals
            - fn - int sigwait() - waits for the delivery of one of the signals in the signal set pointed to by set
    c. Threads and Process Control
        - Threads and exec() - when any thread calls one of the exec() functions, the calling program is completely replaced
        - Threads and fork() - when a multithreaded process calls fork(), only the calling thread is replicated in the child process
        - Threads and exit() - if any thread calls exit() or equivalent, the main thread does a return, all threads vanish after cleanup
    d. Thread Implementation Models
        - Many to One M:1 - all of the details of thread creation, scheduling, and synchronization are handled entirely with the process by a user space threading library
        - One to One - each thread maps onto a separate Kernel Scheduling Entity, the kernel handles each thread scheduling
        - Many to Many - each process can have multiple associated KSEs, and several threads may map to each KSE
    e. Linux Implementations of POSIX Threads
        - LinusThreads
        - Native Posix Threads Library
        - Discovering the Threading Implementation
            - getconf GNU_LIBPTHREAD_VERSION

Chapter 34: Process Groups, Sessions, and Job Control
    a. Overview
        - Process Group - set of one or more processesing sharing the same process group identifier
            - Process Group Leader - process that first becomes the first member of the group and whose process ID becomes the process group ID of the group
            - Lifetime - period of time beginning when the leader joins the group and ending when the last member process leaves the group
        - Session - collection of process groups, membership is determiend by the session identifier SID
            - Session leader - process that creates a new session and whose process ID becomes the session ID
            - All processes in a session share a single controlling terminal
        - Foreground Process - can read input from the controlling terminal, signals sent are sent to the foreground process group
        - Background Process - can not read input from the controlling terminal
        - Opening Terminal -> session leader becomes controlling process for the terminal
    b. Process Groups
        - fn - pid_t getpgrp() - returns process group ID
        - fn - int setpgid() - changes the process group of a process
    c. Sessions
        - fn - pid_t getsid() - returns the session ID of a process
        - fn - pid_t setsid() - creates a new session, calling process becomes the leader of new session
    d. Controlling Terminals and Controlling Processes
        - All of the processes in a session may have a single controlling terminal. Upon creation, a session has no controlling terminal, the controlling terminal is established when the session leader first opens a terminal
        - Removing a Process's Association with the Controlling Terminal - ioctl() used to remove a process association with its controlling terminal
        - Establishign a Controlling Terminal on BSD - session leader must use ioctl() to explicitly establish a terminal as the controlling terminal
        - Obtaining a Pathname for Controlling Terminal
            - fn - char *ctermid() - returns a pathname referring to the controlling terminal
    e. Foreground and Background Process Groups
        - Controlling terminal maintains notion of a foreground proces group, only one process group can be in the foreground, all aother process groups in the session are background process groups
        - fn - pid_t tcgetpgrp() - retrieve process group of a terminal
        - fn - int tcsetprgp() - changes the process group of a terminal
    f. The SIGHUP Signal
        - When controlling process loses its terminal connection, the kernel sends it a SIGHUP signal
        - Handling of SIGHUP by the Shell
            - Most shells are programmed to establish a handler for SIGHUp, which terminates the shell after sending a SIGHUP signal to each of the process groups (foreground and background) createsd by the shell
    g. Job Control
        - Feature that permits a shell user to simultaenously execute multiple commands, one in the foreground and others in the background, Jobs can be stopped and resumed and moved between foreground and background
        - Using Job Control Within the Shell
            - & command is run as background job
            - ctrl-c foregound process is terminated
            - ctrl-z foreground process is stopped
            - fg stopped foreground procress is continued
        - Implementing Job Control
        - Handling Job Control Signals
            - Most applications do not ned to take special action for dealing with job control signals
            - Vi and less must perform screen handling, switching from edit mode back to terminal
        - Orphaned Process Groups - orphaned if tehe parent of every member is either itself a member of the group or is not a member of the groups session

Chapter 35: Process Priorities and Scheduling
    a. Process Priorities (Nice Values)
        - Scheduling Model - Round Robin Time Sharing
            - Time Slice - use of CPU for a brief period of time
            - Requirements
                - Fairness - each process getst a share of the CPU
                - Responsiveness - a process doesnt wait for long periods before it receives use of the CPU
        - Nice Value - -20 (high priority) to +19 (low priority)
            - Effects of the Nice Value - nice value acts as weighing factor that causes thee kernel scheduler to favor processese with higher priorities
        - Retrieving and Modifying Priorities
            - fn - int getpriority() - retrieves own nice value
            - fn - int setpriority() - sets own nice value
            - who
                - PRIO_PROCESS - operate on the process whose ID process equals who
                - PRIO_PGRP - operate on all members of the process group whose process group ID equal who
                - PRIO_USER - operate on all processes whose real user ID equals who
    b. Overview of Realtime Process Scheduling
        - RealTime Requirements
            - application must provide a guaranteed maximum response time, in many cases this time must be quite small
            - a high priority process should be able to maintain exclusive access to the CPU unitl it completes or voluntarily relinquishes the CPU
            - application should be able to control the precise order in which its component process are scheduled
        - The SCHED_RR Policy
            - Pattern - processes of equal priority are executed in a round robin time sharing fashion
            - A process maintains control of the CPU until either:
                - it reaches the end of its time slice
                - it voluntarily relinquishes the CPU, by performing a blocking call or by calling sched_yield()
                - it terminates
                - it is prempted by a higher priority process
            - A proces can be premeted by:
                - a higher priority process that was blocked became unblocked
                - the priority of another process was raised to a higher level than the currently blocked process
                - the priority of the currently running process was decreased to a lower value than that of some other runnable process
        - The SCHED_FIFO Policy
            - Pattern -  first highest priority gets CPU until either:
                - it voluntarily relinquishes the CPU
                - it terminates
                - it is preempted by a high priority process
        - The SCHED_BATCH and SCHED_IDLE Policies
            - SCHED_BATCH - midly disfavors nice value in favor of batch style execution
            - SCHED_IDLE - schedules process with extremely low priority, lower than 19 nice value
    c. Realtime Process Scheduling API
        - Realtime Priority Ranges
            - fn - int sched_get_priority_min() - returns minimum priority for policy
            - fn - int sched_get_priority_max() - returns maximum priority for policy
        - Modifying and Retriving Policies and Priorities
            - fn - int sched_setscheduler() - changes both the scheduling policy and priority of a process
        - Policies - SCHED_FIFO, SCHED_RR, SCHED_OTHER, SCHED_BATCH, SCHED_IDLE
        - Retrieving Scheduling Policies and Priorities
            - fn - int sched_getscheduler() - returns scheduling policy 
            - fn - int sched_getparam() - returns priority of a process
        - Relinquishing the CPU
            - fn - int sched_yield() - yields to be placed at the back of the queue
        - The SCHED_RR Time Slice
            - fn - int sched_rr_get_interval() - returns the length of the time slice allocated for SCHED_RR policy
    d. CPU Affinity
        - Idea - influencing a process to be scheduled on the same CPU if possible
        - fn - int sched_setaffinity() - sets the CPU affinity of the process specified by pid
        - fn - void CPU_ZERO() - intializes set to be empty
        - fn - void CPU_SET() - adds CPU to the set
        - fn - void CPU_CLR() - removes the CPU from set
        - fn - int CPU_ISSET() - returns true if the CPU is in the set
        - fn - int sched_getaffinity() - retrieves the CPU affinity mask of the process

Chapter 36: Process Resources
    a. Process Resource Usage
        - fn - int getrusage(int who, struct rusage *res_usage) - retrieves statistic about various system resources used by the calling process
            - who
                - RUSAGE_SELF - info about the calling process
                - RUSAGE_CHILDREN - info about all children of the calling process
                - RUSAGE_THREAD - info about calling thread
            - rusage
                - ru_utime - user CPU time used
                - ru_stime - system CPU time used
                - ru_maxrss - maximum size of resident set
                - ru_ixrss - integral text memory size
                - ru_idrss - integral data memory used
                - ru_isrss - integral stack memory used
                - ru_minflt - soft page faults
                - ru_majflt - hard page fault
                - ru_nswap - swaps out of physical memory
                - ru_inblock - block input operations via file
                - ru_oublock - block output operations via file
                - ru_msgsnd - IPC messages sent
                - ru_msgrcv - IPC messages received
                - ru_nsignals - signals received
                - ru_nvcsw - voluntary context switches
                - ru_nivcsw - involuntary context switches
    b. Process Resource Limits
        - fn - getrlimit() - fetch resource limits
        - fn - setrlimit() - set resource limits
    c. Details of Specific Resource Limits
        - RLIMT_AS - specifies the maximum size of the process's virtual memory address space in byte
        - RLIMIT_CORE - specifies the maximum size for core dump files
        - RLIMIT_CPU - specifies the maximum number of seconds of CPU time that can be used by the process
        - RLIMIT_DATA - specifies the maximum size of the process's data segment
        - RLIMIT_FSIZE - specifies the maximum size of files that process may create
        - RLIMIT_MEMLOCK - specifies the maximum number of bytes of virtual memory that a process may lock into physical memory, to prevent the memory from being swapped out
        - RLIMIT_MSGQUEUE - specifies the maximum number of bytes that can be allocated for POSIX message queues
        - RLIMIT_NICE - specifies a ceiling on the nice value that may be set for this process
        - RLIMIT_NOFILE - specifies a number one greater than the maximum file descriptor number that a process may allocate
        - RLIMIT_NPROC - specifies the maximum number of processes that may be created for the real user ID of the calling process
        - RLIMIT_RSS - specifies the maximum number of pages in the process's resident set i.e. the total number of virtual memory pages currently in physical memory
        - RLIMIT_RTPIO - specifies a ceiling on the realtime priority that may be set for this process
        - RLIMIT_RTTIME - specifies the maximum amount of CPU time in microseconds that a process running under a realtime scheduling policy may consume without sleeping
        - RLIMIT_SIGPENDING - specifies the maximum number of signals that may be queued for the real user ID of the calling process
        - RLIMIT_STACK -= specifies the maximum size of the process stack

Chapter 37: Daemons
    a. Overview
        - Daemon Characterisitcs
            - long lived, often created at system startup and runs until the system is shut down
            - runs in the background and has no controlling terminal which ensures that the kernel never automatically generates any job control or terminal related signals
        - Daemon Example
            - cron - a daemon that executes commands at a scheduled time
            - sshd - the secure shell daemon, which permits logins from remote hosts using secure communications protocol
            - httpd - the HTTP server daemon which serves web pages
            - inetd - the internet superserver daemon, which listens for incoming network connections to specified TCP/IP ports and launches appropriate server programs to handle these connections
    b. Creating a Daemon
        1. Perform a fork(), after which the parent exists and the child continues, which leaves child in background and not a process group leader
        2. Child calls setsid() to start a new session and free itself of any association with a controlling terminal
        3. Take steps to ensure if the daemon opens a terminal, the device does not become the controlling terminal
        4. Clear the process umask to ensure that when the daemon creates files and directories, they have the requested permissions
        5. Change the process's current working directory, typically to root, to avoid the file system being unmounted
        6. Close all open file descriptors that the daemon inherited from its parent
        7. Open /dev/null and use dup2() to make all descriptor refer to this device
    c. Guidelines for Writing Demons
        - Establish SIGTERM signal handler to do any cleanup before terminating
        - Be wary of possible memory leaks and file descriptor leaks
        - Ensure just one instance of the daemon is up
    d. Using SIGHUP to Reinitialize a Daemon
        - Add a SIGHUP signal handler to Daemon, allowing signals to be sent to trigger reconfigurations etc as SIGHUP won't normally be sent to Daemon
    e. Logging Messages and Erros Using syslog
        - Overview
            - The syslog facility provides a single, centralized logging facility that can be used to log messages by all applications on the system
            - Components
                - syslog daemon - accepts log messages from two different sources
                - syslog library function
                - Message Attributes
                    - facility - stype of program generating the message
                    - level - severity of the message
                - Destionations - terminal, virtual console, disk file, FIFO, users, a process on another system
        - The syslog API
            - fn - void openlog() - establishes a connection to the system log facility and sets defaults that apply to subsequent syslog calls
                - log_options
                    - LOG_CONS - if an error, write message to system console
                    - LOG_NDELAY - open connection to logging system immediately
                    - LOG_NOWAIT - don't wait for child process that may have been created
                    - LOG_ODELAY - connecting is delayed until first message is logged
                    - LOG_PERROR -   write messages to standard error as well as to the system log
                    - LOG_PID - log the caller's process ID with each message
                - facility
                    - LOG_AUTH - security and authorization messages
                    - LOG_AUTHPRIV - privaty security and authorization messages
                    - LOG_CRON - messages from the cron and at daemons
                    - LOG_DAEMON - message from other system daemons
                    - LOG_FTP - messages from ftp daemons
                    - LOG_KERN - kernel messages
                    - LOG_LOCAL0 - reserved for local use
                    - LOG_LPR - messages from the line printer system
                    - LOG_MAIL - messages from the mail system
                    - LOG_NEWS - messages related to Usenet network news
                    - LOG_SYSLOG - internal messsages from the syslogd daemoni
                    - LOG_USER - messages generated by user processes
                    - LOG_UUCP - messages from the UUCP system
            - Logging a Message
                - fn - void syslog() - writes a messsage
                    - level
                        - LOG_EMERG - emergency or panic condition
                        - LOG_ALERT - conditiona requiring immediate action
                        - LOG_CRIT - critical conditions
                        - LOG_ERR - general error condition
                        - LOG_WARNING - warning message
                        - LOG_NOTICE - normal condition that may require special handling
                        - LOG_INFO - information message
                        - LOG_DEBUG - debugging message
            - Closing the Log-
                - fn - void closelog() - deallocates the file descriptor used for the /dev/log socket
            - Filtering Log Messages
                - fn - int setlogmask() - sets a mask that filters the messages written by syslog

Chapter 39: Writing Secure Privileged Programs
    a. Overview
        - Running with Privilege
            - Program was started under a privileged user ID
            - Program has its set-user-ID or set-group-ID permission bit set
        - Problem - if a program contains bugs, or can be subverted by a malicious user, than the security of the system or an application can be compromised
    b. Is a Set-User-ID or Set-Group-ID Program Required?
        - Try to solve the problem without using these IDs, only use when necessary
    c. Operate with Least Privilege
        - Only allow privileges at key points i.e. when the program needs them, and disable them otherwise
        - Best Practice - hold privileges only while they are required
        - Best Practice - drop privileges permanently when they will never again be required
    d. Be Careful When Executing a Progam
        - Best Practice - drop privileges permanently before execing into another program
        - Best Practice - avoid executing a shell (or another interpreter) with privileges
        - Best Practice - close all unnecessary file descriptors before an exec()
    e. Avoiding Exposing Sensitive Information
    f. Confine the Process
        - Best Practice - consider using capabilities
        - Best Practice - consider using a chroot jail
    g. Beware of Signals and Race Conditions
    h. Pitfalls When Performing File Operations and File I/O
        - Best Practice - the process umask should be set to a value that ensures the process necer creates publicly writable files
        - Best Practice - judicious use of seteuid() or setreuid() to temporarily change process credentials may be required in order to ensure that a newly created file doesn't belong to the wrong user
        - Best Practice - in set-user-ID-root program, file should be created initially so that it is not writable by other users
        - Best Practice - checks on file attributes should be performed on open file descriptors
        - Best Practice - if program must be creator of file, use the O_EXCL flag when calling open()
        - Best Practice - a privileged program should avoid creating or relying on files in publicly writable directoriesi such as /tmp
    i. Don't Trust Inputs or the Environment
        - Best Practice - don't trust the environment list
        - Best Practice - handle untrusted user inputs defensively
        - Best Practice - avoid unreliable assumptions about the process's run-time environment
    j. Beware of Buffer Overruns
        - Attack - stack crashing, where a malicious user employs a buffer overrun to place carefully coded bytes into a stack frame in order to force the privileged program to execute arbitrary code
        - Best Practice - use snprintf(), strncpy(), strncat() - that allow the caller to specify the maximum number of characters that should be copied
    k. Beware of Denial-of-Service Attacks
        - Attack - make a service unavailable either by sending the server malformed data that causes it to crash or by overloading it with bogus requests
        - Best Practice - server should perform load throttling, dropping requests when the load exceeds predetermined limit
        - Best Practice - server should employ timeouts for communication with a client
        - Best Practice - in the event of an overload, the server should log suitable messages so that the system administrator is notified of the problem, logging should also be throttled
        - Best Practice - server should be programmed so that it doesn't crash in the face of an unexpected load
        - Best Practice - data structures should be designed to avoid algorithmic-complexity attacks
    l. Check Return Statuses and Fail Safety

Chapter 39: Capabilities
    a. Rationale for Capabilities
        - A more granular management of actions that require privilege, without providing the privilege to do everything
    b. Linux Capabilities
        - CAP_AUDIT_CONTROL - enable and disable kernel audit logging
        - CAP_AUDIT_WRITE - write records to the kernel auditing log
        - CAP_CHOWN - change file's user ID or change file's group ID
        - CAP_DAC_OVERRIDE - bypass file read, write, and execute permissions checks
        - CAP_DAC_READ_SEARCH - bypass file read permission checks and directory read and execute
        - CAP_FOWNER - generally ignore permission checks on operations that normally require the process' file system user ID to match the file's user ID
        - CAP_FSETID - modify a file without having the kernel turn off set-user-ID and set-group-ID
        - CAP_IPC_LOCK - override memory locking restrictions
        - CAP_IPC_OWNER - bypasas permission checks for operations on System V IPC objects
        - CAP_KILL - bypass permission checks for sending signals
        - CAP_LEASE - establish leases on arbitrary files
        - CAP_LINUX_IMMUTABLE - set append and immutable i-node flags
        - CAP_MAC_ADMIN - configure or make state changes for mandatory access controll
        - CAP_MAC_OVERRIDE - override MAC
        - CAP_MKNOD - use mknod() to create devices
        - CAP_NET_ADMIN - perform various network related operations
        - CAP_NET_BIND_SERVICE - bind to privileged socket ports
        - CAP_NET_BROADCAST - perform socket broadcastrs and listen to multicasts
        - CAP_NET_RAW - use raw and packet sockets
        - CAP_SETGID - make arbitrary changes to process group IDs
        - CAP_SETFCAP - set file capabilities
        - CAP_SETPCAP - grant and remove capabilities in the process's permitted set to or from any other process
        - CAP_SETUID - make arbitrary changes to process user IDs
        - CAP_SYS_ADMIN - exceed file max limimt in system calls that open files
        - CAP_SYS_BOOT - use reboot() to reboot the system
        - CAP_SYS_CHROOT - use chroot() to set process root directory
        - CAP_SYS_MODULE - load and unload kernel modules
        - CAP_SYS_NICE - raise nice value
        - CAP_SYS_PACCT - use acct() to enable or disable process accounting
        - CAP_SYS_PTRACE - trace arbitrary processes using ptrace()
        - CAP_SYS_RAWIO - perform operations on I/O ports using iopl() and ioperm()
        - CAP_SYS_RESOURCE - use reserved space on file systems
        - CAP_SYS_TIME - modify system clock
        - CAP_SYS_TTY_CONFIG - perform virtual hangup of terminal or pseudoterminal using vhangup()
    c. Proces and File Capabilities
        - Process Capabilities
            - Permitted - the capabilities a process may employ
            - Effective - capabilities used by the kernel to perform privilege checking
            - Inheritable - capabilities that may be carried over to the permitted set when a program is execed by this process
        - File Capabilities
            - Permitted - set of capabilities that may be added to the process's permitted set during exec()
            - Effective - single bit, if enabled, permitted to new effective
            - Inheritable - set is masked to determine set of capabilities that are to be enabled in the process's permitted set after an exec()
        - Purpose of the Process Permitted and Effective Capability Sets - defines capabilitiers a procress may employ
        - Purpose of the File Permitted and Effective Capability Sets - provides a mechanism by which an executable file can give capabilities to a process
        - Purpose fo the Process and File Inheritable Sets - provides a mechanism by which a process can preserve some of its capabilties across an exec
        - Assigning and Viewing File Capabilities from the Shell
            - setcap() - set capabilities
            - getcap() - get capabilities
    d. The Modern Capabilities Implementation
        - Requirements
            - For each privileged operation, the kernel should check whether the process has the relevant capability, rather than checking for an effective or file system user ID of 0
            - The kernel must provide system calls allowing a process's capabilities to be retrieved and modifies
            - The kernel must support the notion of attaching capabilities to an executable file, so the process gains the associated capabilities when that file is execed
    e. Transformation fo Process Capabilities During exec()
        - Capability Bounding Set - security mechanism used to limit the capabilties that a process can gain during an exec()
        - Preserving Root Semantics 
    f. Effect on Process Capabilities of Changing User IDs
    g. Changing Process Capabilities Programmatically - a process can raise or drop its capabilities set using either the capset() system call or preferably the libcap API
        - The libcap API
            - cap_get_proc() - to retrieve a copy of the process's current capability sets
            - cap_set_flag() - update the user space structure to raise CAP_SET and drop CAP_CLEAR capabilities from the permitted, effective, and inheritable sets stored in the user-space structure
    h. Creating Capabilities Only Environment
        - Secure Bits Flags
            - SECBIT_KEEP_CAPS - don't drop permitted capabiltiies when a process with one or more 0 user IDs sets all of its user IDs to nonzero values
            - SECBIT_NO_SETUID_FIXUP - don't change capabilities when effective or filesystem user IDs are switched between 0 and nonzero values
            - SECBIT_NOROOT - dont grant capabilities if a process with a real or effective user ID of 0 does an exec() or it execs a set-user-ID-root program
    i. Discovering the Capabilities Required by a Program
        - Use strace() to see which system call fails with the error EPERM, the error used to indicate the lack of a required capability
        - Use a kernel probe to produce monitoring output when the kernel is asked to perform capability checks
    j. Older Kernels and Systems Without File Capabilities

Chapter 40: Login Accounting
    a. Overview of the utmp and wtmp Files
        - utmp - maintains a record of users currently logged in to the system, as each user logs in, a record is written to the file
        - wtmp - audit trail of all user logins and logouts, login record is appended, logout record is appended
    b. The utmpx API
    c. The utmpx Structure
        - struct utmpx {
            ut_type; /* Type of Record */
            ut_pid /* PID of Login Process */
            ut_line; /* Terminal Device Name */
            ut_id; /* Suffix from Terminal Name */
            ut_user; /* Username */
            ut_host; /* Hostname for Remote Login or Kernel for Run-Level Messages */
            ut_exit; /* Exist Status of Process Marked as Dead_Process */
            ut_session; /* Session ID */
            ut_tv; /* Entry Time */
            ut_addr_v6; /* ID Address of Remote Host */
            __unused; /* Reserved for Future Use */
        }
        - ut_type
            - EMPTY - record does not contain valid accounting information
            - RUN_LVL - indicates a change in the system's run level during system startup or shutdown
            - BOOT_TIME - time of the system boot
            - NEW_TIME - contains new time after a system clock change
            - OLD_TIME - contains old time after a system clock change
            - INIT_PROCESS - record for a process spawned by init
            - LOGIN_PROCESS - record for a session leader process for a user login
            - USER_PROCESS - record for a user process, usually a login session
            - DEAD_PROCESS - a process that has exited
        - Example Login Session
            - an INIT_PROCESS record, written by init
            - a LOGIN_PROCESS record, written by getty
            - A USER_PROCESS record, written by login
            - A DEAD_PROCESS record, written by init
    d. Retrieving Information from the utmp and wtmp Files
        - fn - void setutxent() - rewinds utmp file to the beginning
        - fn - void endutxent - closes utmp file
        - fn - struct utmpx *getutxent() - retrieves next sequential record from the utmp file
        - fn - struct utmpx *getutxid() - searches utmp file for record 
        - fn - struct utmpx *getutxline() - searches for a record
        - fn - int utmpxname - records a copy of the pathname given to it
    e. Retrieving the Login Name: getlogin()
        - fn - char *getlogin() - finds the name of the terminal associated with the calling process's standard input, searches utmp for a record with ut_line, then returns ut_user from record
    f. Updating the utmp and wtmp Files for a Login Session
        - Login - record to utmp file, append to wtmp file
        - Logout - erase utmp record, append to wtmp file
        - fn - struct utmpx *pututxline() - writes the utmpx structure pointed to by ut into the /var/run/utmp file
        - fn - void updwtmpx() - appends the utmpx record pointed to by ut to the file specified in wtmpx_file
    g. The lastlog File - records the time each user last logged in to the system

Chapter 41: Fundamentals of Shared Libraries
    a. Object Libraries
        - Object Library - compiled source files, link to produce executable
    b. Static Libraries
        - Benefits
            - We can place a set of commonly used object files into a single library file that can then be used to build multiple executables
            - Link comands become simpler by just specifying the name of the static library
        - Creating and Maintaining
            - ar options archive object-file...
        - Using a Static Library
            - cc -g -o prog prog.o libdemo.a
    c. Overview of Shared Libraries
        - Issue to Solve - when a program is built against a static library, the resulting executable files include copies of all the object files that were linked into the program, redundancy
        - Advantages
            - Reduced disk space
            - Reduces overall virtual memory
            - Must relink executable using that module if change occurs
            - Some programs can be loaded into memory and started more quickly
            - Possible to make changes to the object modules without requiring programs to be relinked in order to see the changes
    d. Creating and Using Shard Libraries - A First Pass
        - Creating a Shared Library
            - Use gcc to create three object modules
            - Use -shared to create a shared library with the three object modules
        - Posiiton-Independent Code
            - cc -fPIC specifies the compiled should generate position-independent-code, allows code to be located at any virtual address at run time
        - Using a Shared Library
            - Embed the name of the shared library inside the executable during the link phase
            - Mechanism for resolving the embedded library name and then loading into memory
        - The LB_LIBRARY_PATH - add directory to this environment variable where shared library resides
        - Static Linking and Dynamic Linking Contrasted
            - Static Linking - compile time loading of libraries
            - Dynamic Linking - run time loading of the shared libraries used by an executable
        - The Shared Library Soname
            - Soname - alias of shared library
    e. Useful Tools for Working with Shared Libraries
        - The ldd command - displays the shared libraries that a program (or a shared library) requires to run
        - The objdump and readelf commands
            - objdump - obtain binary machine code among other things
            - readelf - displays similar information but in a different manner
        - The nm command - lists the set of symbols defined within an object library or executable program
    f. Shared Library Versions and Naming Conventions
        - Major - incompatible API changes
        - Minor - compatible API changes
        - Patch - backwards compatabile fixes
    g. Installing Shared Libraries
        - /usr/lib - the directory in which most standard libraries are installed
        - /lib - libraries required during system startup
        - /usr/local/lib - nonstandard or experimental libraries
        - Directories in /etc/ld.so.conf
        - ldconfig
            - Searches a standard set of directories and creates or updates a cache file to contain a list of the major library versions in all of these directories
            - Examines the latest minor version of each major version of each library to find the embedded soname and then creates or udpates relative symbolic links for each soname in the same directory
    h. Compatible Vs. Incompatible Libraries
        - Compatible
            - Semantics of each public function and variable in the library remains unchanged
            - No function or variable in the library's public API is removed, can add new functions or variables
            - Structures allocated within and returned by each function remain unchanged, excluding adding extra spaces early
    i. Upgrading Shared Libraries
        - Action - create a new library version, install it in the appropriate directory, and update the soname and linker name symbolic links as required using ldconfig
    j. Specifying Library Search Directories in an Object File
        - Acton - during static editing phase, insert into the excetuable a list of directories that should be searched at run time for shared libraries
        - Using the -rpath Linker Option When Building a Shared Library
            - Used for linking libraries together
    k. Finding Shared Libraries at Run Time
        - Rules
            - If executable has any directories listed in DT_RPATH then these directories are searched
            - If LD_LIBRARY_PATH is defined, then these directories are searched
            - If executable has directoies in DT_RUNPATH, those are searched
            - /etc/ld.so.cahce is checked
            - /lib and /usr/lib are searched in that order
    l. Run Time Symbol Resolution
        - Idea - main() definitions override shared library definitions
        - Idea - if a global symbol is defined in multiple libraries, then a reference to that symbol is bound to the first definition found by scanning libraries in the left to right order in which they were listed on the static link command link
    m. Using a Static Library Instead of a Shared Library
        - Static vs. Shared - useful if user can't or doesn't want to install a shared library on the system where the program is to be used

Chapter 42: Advanced Features of Shared Libraries
    a. Dynamically Loaded Libraries
        - When an executable starts, the dynamic linker loads all of the shared libraries in the programs dynamic dependency list
        - dlopen API - enables a program to open a shared library at run time, search for a function by name in that library, and then call the function
        - Opening a Shared Library: dlopen()
            - fn - void dlopen() - loads the shared library into calling process's virtual address space and increments the count of open references to the library
            - flags
                - RTLD_LAZY - undefined function symbols should be resolved only as the code is executed
                - RTLD_NOW - all undefined symboils should be immeditaely resolved before dlopen() completes
                - RTLD_GLOBAL - symbols in this library and its dependency tree are made available for resolving references in other libraries
                - RTLD_LOCAL - inverse of RTLD_GLOBAL
                - RTLD_NODELTEE - don't unload the library during dlclose()
                - RTLD_NOLOAD - don't load the library
                - RTLD_DEEPBIND - when resolving symbole references, search for definitions in the library before searching for definitions in libraries that have already been loaded
        - Diagnosing Errors: dlerror()
            - fn - const char *dlerror(void) - obtain a pointer to a string thast indicates the cause of the error
        - Obtaining the Address of a Symbol: dlsym()
            - fn - void *dlsym() - searches for the named symbol (a function or variable) in the library
        - Closing a Shared Library: dlclose()
            - fn - int dlclose() - closes the lirbary and decrements the system's counter of open references to the library
        - Obtaining Information About Loaded Symbols: dladdr()
            - fn - int dladdr() - returns a stucture containing information about that address
                - struct {
                    *dli_fname; /* Pathname of shared library containing 'addr' */
                    *dli_fbase; /* Base address at which shared library is loaded */
                    *dli_sname; /* Name of symbol whose definition overlaps 'addr' */
                    *dli_saddr; /* Actual value of the symbol returned in 'dli_sname' */
                }
        - Accessing Symbols in the Main Program - use --export-dynamic linker option
    b. Controlling Symbol Visibility
        - Reasons
            - If unspecified interfaces are exported, then authors of applications that use the library may choose to employ these interfaces, creating a compatability problem
            - During run time symbol resolution, any symbols that are exported might interpose definitions that are provided in other shared libraries
            - Exporting unnecessary symbols increase the size of the dynamic symbol table that must be loaded
        - Techniques
            - In a C program, use the static keyword to make a symbol private to a source code module
            - GNU C compiler gcc set visibility to hidden
            - Version scripts
            - Use RTLD_GLOBAL flag to specify that the symbols defined by the library should be made availble for binding by subsequently loaded libraries
    c. Linker Version Scripts
        - Controlling Symbol Visibility with Version Scripts
            - Version Tag -> Global Symbols -> Local Symbols
    d. Initialization and Finalization Functions
        - Initiialziation - defined using gcc constructor attribute - executes when the library is loaded
        - Finalization - defined using gcc constructor attribute - executes when the library is unloaded
    e. Preloading Shared Libraries
        - Define LD_PRELOAD - string consisting of space separated or colon separated names of shared libraries that should be loaded before any other shared libraries
    f. Monitoring the Dynamic Linker
        - Assign help to LD_DEBUG, dynamic linker displays help information about LD_DEBUG
            - libs - display library search paths
            - reloc - display relocation processing
            - files - display progress for input file
            - symbols - display symbol table processing
            - bindings - display information about symbol binding
            - version - display version dependencies
            - all - all previous options
            - statistics - display relocation statistics
            - unused - determined unused DSOs
            - help - display this help message and exit

Chapter 43: Interprocess Communication Overview
    a. A Taxonomy of IPC Facilities
        - Communication - these facilities are concerned with exchanging data between processes
        - Synchronization - these facilities are concerned with synchronizing the actions of processes or threads
        - Signals - can be used for synchronization
    b. Communication Facilities
        - Data Transfer - one process writes data to IPC facility, and another process reads the data, user -> kernel and then kernel -> user
            - Byte Stream - data exchanged via pipes, FIFOs, and stream sockets, each read can read an arbitrary number of bytes
            - Message - data exchanged via System V message queues, POSIX message queues, and datagram sockets, each read operations reads a whole message as written by the writer process
            - Pseudoterminals - used in specialized situations
        - Shared Memory - exchanging memory by placing it in a region of memory shared between the processes
            - System V, POSIX, and memory mappings
    c. Synchronization Facilities
        - Semaphores - kernel managed integer whose value is never permitted to fall below 0
        - File Locks - designed to coordinate the actions of multiple processes operating on the same file
        - Mutexes and Condition Variables - frequently used with threads
    d. Comparing IPC Facilities
        - Table 43-1 - Facility - Name - Handle Used
        - Functionality
            - Data Transfer Facilities - involve read and write operations, data can only be consumed by one reader, flow control and synchronization is managed by kernel
            - Shared Memory - one process makes data visible to any number of other processes sharing the same memory region, synchronization must be handled by user
        - Network Communication - only sockets permit processes to communicate over a network, used for communication between processes and for communication between processes on different hosts connected via a TCP/IP network
        - Portability - System V IPC may be more portable than POSIX
        - Accessibility - Process, Kernel, File System
        - Persistence
            - Process Persistence - IPC object remains in existence only as long as it is held open by at least one process
            - Kernel Persistence - IPC object exists until either it is explicitly deleted or the system is shut down
            - File System Persistence - IPC object lasts until it is explicitly deleted

Chapter 44: Pipes and FIFOs
    a. Overview
        - Pipe - a piece of plumbing that allows data to flow from one process to another
            - Byte Stream - no concept of messages or message boundaries, the process reading can read blocks of data of any size
            - Reading - attempts to read from a pipe that is currently empty block until at least one byte has been written to the pipe
            - Unidirectional - data can only travel in one direction through a pipe
            - Writes of PIPE_BUF bytes are guaranteed to be atomic
            - Limited Capacity
    b. Creating and Using Pipes
        - fn - int pipe(int filedes[2]) - creates a new pipe, returns file descriptor for read end and write end of pipe
        - Important - writer should close read end, and reader should close write end
        - Pipes allow communication between related process
        - Close unused pipe file descriptors to guarantee the reading process sees end of file after reading all data from pipe
        - Close unused pipe file desctipros to guarantee the writing process receives a EPIPE error
    c. Pipes as a Method of Process Synchronization
        - Process
            - Parent builds pipe
            - Child are created and inherit file descriptor for write end of pipe and close decriptor once action is completed
            - After all children have closed, the parent's read from the pipe will complete, returning end of file 
    d. Using Pipes to Connect Filters
        - Two filters i.e. programs that read from stdin and write to stdout are connected using a pipe
    e. Talking to a Shell Command via a Pipe: popen()
        - fn - FILE *popen() - creates a pipe, forks a child process that execs a shell, which in turn creates a child process to execute the string given in command
        - fn - int pclose() - closes pipe and wait for the child shell to terminate
    f. Pipes and stdio Buffering
        - stdio library applies block buffering to the file stream, this means output is sent to the child proecss only when the stio buffer is filled or the pipe is closed
    g. FIFOs
        - FIFO has a name within the file system and is opened the same way as a regular file, this allows FIFO to be used for communication between unrelated processes
        - fn - int mkfifo() - creates a new FIFO with the given pathname
        - Once a FIFO has been created, any process can open it subject to the usual file permission checks
        - You can use FIFOs and tee to create a dual pipeline
    h. Client Server Application Using FIFOs
        - Client Request to Server FIFO, Server FIFO sends to Server, Server Responds on Client Specific FIFO, Client Specific FIFO sends response to Client
    i. Nonblocking I/O
        - Use O_NONBLOCK to stop blocking when a preocess opens one end of a FIFO
            - Allows a single process to open both ends of a FIFO, the proces first opens the FIFO for reading specifying O_NOBLOCK and then opens the FIFO for writing
            - It prevents deadlocks between processes opening two FIFOs
        - Nonblocking read() and write()
    j. Semantics of read() and write() on Pipes and FIFOs

Chapter 45: Introduction to System V IPC
    a. Mechanisms for Interprocess Communication
        - Messsage Queues - used to pass messages between processes
            - Message boundaries are preserved, so that readers and writers communicate in units of messages
            - Each message includes an integer type field, so it is possible to select messages by type rather than in the order in which they were written
        - Sempahores - permit multiple processes to synchronize their actions
        - Shared Memory - enables multiple processes to share the same region of memory
    b. API Overview
        - Message Queues
            - Header File - sys/msg.h
            - Data Structure - msqid_ds
            - Create/Open - msgget()
            - Close - none
            - Control - msgctl()
            - Performing IPC - msgsnd() write, msgrcv() read
        - Sempahores
            - Header File - sys/sem.h
            - Data Structure - semid_ds
            - Create/Open - semget()
            - Close - none
            - Control - semctl()
            - Performing IPC - semop() - test/adjust
        - Shared Memory
            - Header File - sys/shm.h
            - Data Structure - shmid_ds
            - Create/Open - shmget()
            - Close - shmdt()
            - Control - shmctl()
        - Creating and Opening a System V IPC Object
            - Use fn described above for get, analagous to the open() system call used for files
        - IPC Object Deletion and Object Persistence
            - Use fn describe above e.g. msgctl() with IPC_RMID to delete an object
    c. IPC Keys
        - Keys are integer values represented using the data type key_t
        - Generating a Unique Identifier with IPC_PRIVATE
            - Use IPC_PRIVATE with get function
        - Generating a Unique Key with ftok()
            - fn - key_t ftok() - returns a key value suitable for use in a subsequent call to one of the System V IPC get system calls
    d. Associated Data Structure and Object Permissions
        - Kernel maintains an associated data structure for each instance of a System V IPC object
    e. IPC Identifiers and Client-Server Applications
    f. Algorithm Employed by System V IPC get Calls
        - For each mechanism, the kernal maintains an associated ipc_ids structure that records various global information about all instances of that IPC mechanism.
        - Information includes a dynamically sized array of pointers, entries, to the associated data structure for each object instance.
    g. The ipcs and ipcrm Commands
        - ipcs - obtain information about IPC objects on the system
        - ipcrm - deletes an IPC object
    h. Obtaining a List of All IPC Objects
        - /proc/sysvipc/msg - lists all message queues and their attributes
        - /proc/sysvipc/sem - lists all sempahore sets and their attributes
        - /proc/sysvipc/shm - lists all shared memory segments and their attributes
    i. IPC Limits - ipcs -l list limits on each of the IPC mechanisms

Chapter 46: System V Message Queues
    - Difference from Pipes and FIFO
        - Handle used to refer to a message queue is not a file descriptor
        - Communication via queues is message oriented, reader receives whole messages as written by the writer
        - Each message has an integer type, so messages can be retrieved FIFO or by type
    a. Creating or Opening a Message Queue
        - fn - int msgget() - creates a new message queue or obtains the identifier of an existing queue
    b. Exchanging Messages
        - Sending Messages: msgsnd()
            - fn - int msgsnd() - writes a message to the message queu
                - IPC_NOWAIT flag - perform a non blocking send
        - Receiving Messages: msgrcv()
            - fn - ssize_t msgrcv() - reads and removes a message from the message queue and copies it contents into a buffer
                - msgtyp
                    - If equals 0, the first message from the queue is removed and returned to calling process
                    - If > 0, first message in the queue whose mtype equals msgtyp is removed and returned to calling process
                    - If < 0, treat the waiting message as a priority queue, giving priority to lowest mtype
                - Flags
                    - IPC_NOWAIT - perform a non blocking receive
                    - MSG_EXCEPT - if msgtyp greater than 0, first message whose mstype is not equal to mstyp is removed from the queue
                    - MSG_NORROR - removes messager regardless of size, if larger than maxmsgz bytes, truncates and returns
    c. Message Queue Control Operations
        - fn - int msgctl() - performs control operations on a message queue
            - cmd
                - IPC_RMID - remove message queue object and its associated msqid_ds
                - IPC_STAT - place a copy of the msqid_ds data structure associated with message queue
                - IPC_SET - update selected fields of the msqid_ds data structure

    d. Message Queue Associated Data Structure
        - struct msqid_ds {
            msg_perm; /* Ownership and Permission */
            msg_stime; /* Time of last msgsnd() */
            msg_rtime; /* Time of last mssgrcv() */
            msg_ctime; /* Time of last change */
            msg_cbytes; /* Number of bytes in queue */
            msg_qnum; /* Number of messages in queue */
            msg_qbytes; /* Maximum bytes in queue */
            msg_lspid; /* PID of last msgsnd() */
            msg_lrpid; /* PID of last msgrcv() */
        }
    e. Message Queue Limits
        - MSGMNI - system limit on number of message queues
        - MSGMAX - system limit on max number of bytes that can be written in a single message
        - MSGMNB - maximum number of bytes that can be held in queue at one time
        - MSGTQL - system limit on number of messages that can be on all message queues on the system
        - MSGPOOL - system limit on the size of buffer pool that is used to hold data in all message queues on system
    f. Displaying ALl Message Queues on the System
        - Pattern
            - Use MSG_INFO operation to find out maximum index of the entries array for message queues
            - Loop from 0 to maxind, employing a MSG_STAT operation for each value
    g. Client-Server Programming with Message Queues
        - Designs
            - The use of a single message queue for exchanging messages in both directions between server and client
            - The use of a separate message queue for the server and for each client, the server queue is used to receiving client requests, and responses are sent to client via the individual client queues
    h. A File Server Application Using Message Queues
        - Client creates Client Message Queue
        - Client Makes Request to Server Message Queue
        - Server Reads Request from Server Message Queue
        - Server Creates Child to Handle Request
        - Server Child Sends Response to Client Messsage Queue
        - Client Reads Response from Client Message Queue
    i. Disadvantages of System V Message Queues
        - Message queues are referred to be identifiers rather than fds, means tools like select, poll, and epoll can't be used
        - Use of keys adds additional complexity, also requires use of iprc and ipcrm instead of ls and rm
        - Message queues are connectionless, and kernel doesn't maintain a count of number of processes referring to the queue as is done with pipes
        - Limits on total number of message queues

Chapter 47: System V Semaphores
    a. Actions to Perform on Semaphores
        - Setting semaphore to an absolute value
        - Adding a number to the current value of the semaphore
        - Substracting a number from the current value of the semaphore
        - Waiting for the semaphore value to be equal to 0
    b. Overview
        - General Steps for Using a Semaphore
            - Create or open a semaphore using semget()
            - Initialize the semaphores in the set using the semctl() SETVAL or SETALL operation
            - Perform operations on semaphore values using semop()
            - Remove the set using the semctl() IPC_RMID operation
    c. Creating or Opening a Semaphore Set
        - fn - int semget() - creates a new semaphore set or obtain the identifier of an existing set
    d. Semaphore Control Operations
        - fn - int semctl() - performs a variety of control operations on a semaphore set or an individual semaphore wtihin a set
        - Generic Control Operations 
            - IPC_RMID - immediately remove the sempahore set and its associated semid_ds data structure
            - IPC_STAT - place a copy of the semid_ds data structure assocaited with the semaphore set in a buffer
            - IPC_SET - update selected fields of the semid_ds data structure associated with the semaphore
        - Retrieving and Initializing Semaphore Values
            - GETVAL - returns value of a semaphore in the set
            - SETVAL - sets value of a semaphore in the set
            - GETALL - retrieve value of all of the semaphores in a set
            - SETALL - intiailize all semaphores in a set
        - Retreiving Per Semaphore Information
            - GETPID - return process ID of last process to perform a semop() on this semaphore
            - GETNCNT - return number of processes currently waiting for the value of this semaphore to increase
            - GETZCNT - return number of processes currently waiting for the value of this semaphore to become 0
    e. Semaphore Associated Data Structure
        - struct semid_ds {
            sem_perm; /* Ownership and Permissions */
            sem_otime; /* Time of Last semop() */
            sem_ctime; /* Time of Last Change */
            sem_nsems; /* Number of Semaphores in Set */
        }
    f. Semaphore Initialization
    g. Semaphore Operations
        - fn - int semop() - performs one or more operations on the semaphores in a semaphore set
        - fn - int semtimedop() - same as semop() execpt a timeout upper limit can be provided for how long call will block
    h. Handling of Multiple Semaphore Operations
        - if processes are blocked trying to decrease semaphore by same value, it is indeterminate which process will be permitted to perform the operation first
        - if processes are blocked trying to decrease a semaphore value by different amounts, then requests are served in the order in which they become possible
    i. Semaphore Undo Values
        - Use SEM_UNDO flag when changing the value of a semaphore via semop()
    j. Implementing a Binary Semaphores Protocols
        - Values
            - available i.e. free and reserved i.e. in use
        - Actions
            - Reserve - attempt to reserve this semaphore for exclusive use
            - Release - free currently reserved semaphore
            - Reserve Conditionally - make a nonblocking attempt to reserve this semaphore for exclusive use
    k. Semaphore Limits
        - SEMAEM - maximum value that can be recorded in a semadj total
        - SEMMNI - system wide limit on the number of semaphore identifiers that can be created
        - SEMMSL - maximum number of semaphores that can be allocated in a semaphore set
        - SEMNS - system wide limit on the number of semaphores in all semaphore sets
        - SEMOPM - maximum number of operations per semop() call
        - SEMVMX - maximum value for a semaphore
        - SEMMNU - system wide limit on the total number of semaphore undo structures
        - SEMUME - maximum number of undo entries per semaphore undo structure
    l. Disadvantages of System V Semaphores
        - Semaphores are referred to by identifiers rather than file descriptors
        - Use of keys rather than filenames results in additional programming complexity
        - The use of separate system calls for create and initialization means some extra work is needed to avoid race conditions
        - Kernel doesn't maintain a count of the number of processes referring to a semaphore set
        - Programming interface provided by System V semaphores is overly complicated
        - There are various limits on the operation of semaphoress

Chapter 48: System V Shared Memory
    a. Overview
        - Typical Process
            - Call shmget() to create a new shared memory segment or obtain the identifier of an existing segment
            - Use shmat() to attach the shared memory segment, that is make the segment part of the virtual memory of the calling process
            - Shared memory can be treated like any other memory available to the program
            - Call shmdt() to detach the shared memory segment
            - Call shmctl() to delete the shared memory segment
    b. Creating or Opening a Shared Memory Segment
        - fn - int shmget() - creates a new shared memory segment or obtains the identifier of an existing segment
    c. Using Shared Mmeory
        - fn - void *shmat() - attaches the shared memory segment to calling process's virtual address space
    d. Example: Transferring Data via Shared Memory
        - Writer - reads blocks of data from stdin and writes them into a shared memory segment
        - Reader - reads blocks of data from the shared memory segment to standard output
    e. Location of Shared Memory in Virtual Memory
        - If allowing kernel to choose where to attach (recommended) the shared memory will be placed at 0x4000000000, along with memory mappings and shared libraries
    f. Storing Pointers in Shared Memory
        - When storing references inside a shared memory segment that point to other addresses within the segment, we should use relative offsets rather than absolute pointers
    g. Shared Memory Control Operations
        - fn - int shmctl() - performs a range of control operations on the shared memory segment
        - Generic Control Operations
            - IPC_RMID - delete shared memory segment
            - IPC_STAT - get data structure
            - IPC_SET - set fields inside of data structure
        - Locking and Unlocking Shared Memory
            - SHM_LOCK - locks a shared memory segment into memory
            - SHM_UNLOCK - unlocks the shared memory segment
    h. Shared Memory Associated Data Structure
        - struct shmid_ds {
            shm_perm; /* Ownership and Permissions */
            shm_segsz; /* Size of segment in bytes */
            shm_atime; /* Time of Last shmat() */
            shm_dtime; /* Time of Last shmdt() */
            shm_ctime; /* Time of Last Change */
            shm_cpid; /* PID of creator */
            shm_lpid; /* PID of last shmat() */
            shm_nattch; /* Number of currently attached processes */
        }
    i. Shared Memory Limits
        - SHMMNI - system wide limit on number of shared memory identifiers
        - SHMMIN - minimum size in bytes of a shared memory segment
        - SHMMAX - maximum size in bytes of a shared memory segment
        - SHMALL - system wide limit on total number of pages of shared memory
        - SHMSEG - per process limit on number of attached shared memory segments

Chapter 49: Memory Mappings
    a. Overview
        - Types
            - File Mapping - maps a region of a file directly into the calling process's virtual memory, once a file is mapped, its contents can be accessed by operations on the bytes in the corresponding memory regions
            - Anonymous Mapping - no corresponding file, pages of the map are intialized at 0
        - Private or Shared
            - Private Mapping - modifications to the contents of the mapping are not visible to other processes, and for a file mapping, are not carried through to the underlying file
            - Shared Mapping - modifications to the contents of the mapping are visible to other processes that share the same mapping
        - Mixes
            - Private - File - contents of the mapping are init from a file in region, multiple proceses share same physical pages, copy on write is used
                - Use - init a process's text and data segments from the corresponding parts of a binary exec or shared library file
            - Private - Anonymous - new mapping distinct from other anonymous mappings 
                - Use - allocate new memory for a process e.g. malloc
            - Shared - File - all processes mapping the same region of a file share the same physical pages of memory, modifications are carried though\
                - Use - permits memory-mapped I/O
                - Allow unrelated processes to share a region in memory in order to perform fast IPC
            - Shared - Anonymous - pages are not copy on write, changes made are visible to others
                - Use - IPC between similar processes
    b. Creating a Mapping: mmap()
        - fn - void *map() - creates a new mapping in the calling process's virtual space
    c. Unmapping a Mapped Region: munmap()
        - fn - int munmap() - removes a mapping from the calling process's virtual address space
    d. File Mappings
        - Order
            - Obtain a descriptor for the file, typically via a call to open()
            - Pass that file descriptor as the fd argument in a call to mmap()
        - Private File Mappings
            - Allows multiple processes to share same read only text segment
            - Map the initialized data segment of an executable or shared library
        - Shared File Mappings
            - Shared files and modifications
    e. Synchronizing a Mapped Region: msync()
        - fn - int msync() - gives an application explicit control over when a shared mapping is synchronized with the mapped file
        - Why - ensure data integrity
    f. Additional mmap() Flags
        - MAP_ANONYMOUS - create an anonymous mapping
        - MAP_FIXED - interpgret an addr argument exactly
        - MAP_LOCKED - lock mapped pages into memory
        - MAP_HUGELTB - create a mapping that uses huge pages
        - MAP_NORESERVE - control reservation of swap space
        - MAP_PRIVATE - modifications to mapped data are private
        - MAP_POPULATE - populate the pages of a mapping
        - MAP_SHARED - modifications to mapped data are visible
        - MAP_UNINITAILIZED - don't clear an annonymous mapping
    g. Annonymous Mappings
        - Option #1 - specify MAP_ANONMYMOUS in mmap() flags
        - Option #2 - open the /dev/zero device file and pass the resulting file descriptor to mmap()
    h. Remapping a Mapped Region: mremap()
        - fn - void *mremap() - can change a mapping location and size after it has been created
    i. MAP_NORESERVE and Swap Space Overcommitting
        - MAP_NOSERVERE - reserver swap space for the pages of a mapping only as they are actually required
        - The OOM Killer - out of memory killer, selects process to kill when memory becomes exhausted
    j. The MAP_FIXED Flag - forces the kernl to interpret the address in addr exactly, should be omitted for portability
    k. Nonlinear Mappings: remap_file_pages()
        - fn - int remap_file_pages() - rearrange correspondence between the pages of memory and the pages of a file

Chapter 50: Virtual Memory Management
    a. Changing Memory Protection
        - fn - int mprotect() - changes the protection of the virtual memory pages in the range starting at addr and continuing for length bytes
            - int prot = PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC
    b. Memory Locking: mlock() and mlockall()
        - fn - int mlock() - lock region of memory
        - fn - int munlock() - unlock region of memory
        - Resolving Memory Locks
            - on process termination
            - if locked pages are unmapped via munmap()
            - if locked pages are overlaid using the mmap() MAP_FIXED flag
        - Locking and Unlocking All of a Process's Memory
            - fn - int mlockall() - locks all of the currently mapped pages in a process's virtual address space
                - MCL_CURRENT - lock all pages that are currently mapped intro the calling process's virtual address space, including program text, data segments, memory mapping, and the stack
                - MCL_FUTURE - lock all pages subsequently mapped into the calling process's virtual address space
            - fn - int munlockall() - unlocks all of hte pages of the calling process and undoes the effect of any previous mlockall()
    c. Determining Memory Residence
        - fn - int mincore() - reports which pages in a virtual address space range are currently resident in RAM
    d. Advising Future Memory Usage Patterns: madvice()
        - fn - int madvice() - used to improve the performance of an application by informing the kernel about the calling process's likely usage of the pages in the range starting at addr and continuing length bytes
        - Advice
            - MADV_NORMAL - default behavior, pages are transferred in clusters
            - MADV_RANDOM - pages in this region will be accesserd randomly, so read ahead yields no benefit, fetch minimum amount of data on each read
            - MADV_SEQUENTIAL - pages will be accessed once sequentially, thus kernel can aggressively read ahead and pages can be quickly freed
            - MADV_WILLNEED - read pages in this region ahead, in preparation for future access
            - MADV_DONTNEED - calling process no longer requires the pages in this region to be memory resident

Chapter 51: Introduction Posix IPC
    a. Overview
        - Types - Message Queues, Semaphores, Shared Memory
    b. API Overview
        - Message Queues
            - Header File - mqueue.h
            - Create/Open - mq_open()
            - Close - mq_close()
            - Unlink - mq_unlink()
            - Perform IPC - mq_send() and mq_receive()
        - Semaphores
            - Header File - semaphore.h
            - Create/Open - sem_open()
            - Close - sem_close()
            - Unlink - sem_unlink()
            - Perform IPC - sem_post(), sem_wait(), sem_getvalue()
        - Message Queues
            - Header File - sys/mman.h
            - Create/Open - shm_open()
            - Close - munmap()
            - Unlink - shm_unlink()
            - Perform IPC
        - Creating an IPC Object
            - Create a new object with given name, opens that objectm and returns a handle for it
            - Opens an existing object and returns a handle for that object
        - Closing an IPC Object
            - Associated close call(), waits for last process to finish using before deallocating
        - IPC Object Permissions - permissions mask that is the same for files
        - IPC Object Deletion and Object Persistence - kernel persistence
        - Listing and Removing POSIX IPC Objects - virtual filesystems under root
    c. Comparison of System V IPC and POSIX IPC
        - POSIX Benefits
            - Interface is simpler
            - Use of names, and open, close, unlink functions is more consistent with traditional UNIX file model
            - Objects are reference counted, simplifying object deletion
        - System V Benefits
            - Portability i.e. support and standardization

Chapter 52: POSIX Message Queues
    a. Opening, Closing, and Unlinking a Message Queue
            - Opening
                - fn - mqd_t mq_open() - creates a new message queue or open an existing queue
                    - Flags
                        - O_CREATE - create queue if it doesnt exist
                        - O_EXCL - create clue exclusively
                        - O_RDONLY - open for reading only
                        - O_WRONLY - open for writing only
                        - O_NONBLOCK - open in non blocking mode
            - Closing
                - fn - int mq_close() - closes a message queue
            - Removing
                - fn - int mq_unlink() - removes message queue, it is destroyed once all processes cease using it
    b. Relationship between Descriptors and Message Queues
        - A message queue descriptor is a per-process handle thast refers to an entry in the system wide table of open message queue decsriptions, and this entry in turn refers to a message queue object
    c. Message Queue Attributes
        - struct mq_attr {
                mq_flags; /* Message queue description flags */
                mq_maxmsg; /* Maximum number of messages on queue */
                mq_msgsize; /* Maximum message size in bytes */
                mq_curmsgs; /* Number of messages currently in queue */
        }
        - Retrieving Message Queue Attributes
            - fn - int mq_getattrr() - returns an mq_attr structure containing information about a message queue
        - Modifying Messsage Queue Attributes
            - fn - int mq_setattr() - sets attribute in mq_attr structure
    d. Exchanging Messages
        - Sending Messages
            - fn - int mq_send() - adds message to message queue
        - Receiving Messages
            - fn ssize_t mq_receive() - removes the oldests message with the highest priority from the message queue
        - Sending and Receiving with a Timeout
            - fn - int mq_timedsend()
            - fn - ssize_t mq_timedreceived()
    e. Message Notification
        - fn - int mq_notify() - registers the calling process to receive a notififaction when a message arrives on the empty queue
        - Receiving a Notifcation via a Signal
            - Open message queue, allocate buffer for receiving messages
            - Block notification signal SIGUSR1 and establish a handler for it
            - Make initial call to mq_notify() to register process to receie message notification
            - Execute an infinite loop
                - Call sigsuspend(), which unblocks notification signal and waits until signal is caught
            - Call mq_notify() to register thsi process to receive message notifications
            - Execute a while loop that drains the queue by reading as many messages as possible
    f. Linux Specific Features
        - Displaying and deleting message queu objects via the command line
        - Obtain information about a message queue
        - Using message queues with alternative I/O models
    g. Message Queue Limits
        - MQ_PRIO_MAX - defines the maximum priority for a message
        - MQ_OPEN_MAX - indicat maximum number of message queues that a process can hold open

Chapter 53: POSIX Semaphores
    a. Overview
        - Named Semaphores - sempahore with a name, unrelated processes can access the semaphore using the name
        - Unnamed Semaphores - semaphore with no name, processes and threads can share semaphore if semaphore resides in region of shared memory
    b. Named Semaphores
        - Opening a Named Semaphore
            - fn - sem_t *sem_open() - creates and opens a new named semaphore or opens an existing semaphore
        - Closing a Semaphore
            - fn - int sem_close() - terminates association between a process and a semaphore
        - Removing a Named Semaphore
            - fn - int sem_unlink() - removes the semaphore identified by name and marks the semaphore to be destroed once all processes cease using it
    c. Semaphore Operations
        - Waiting on a Semaphore
            - fn - int sem_wait() - decrements the value of the semaphore by one
        - Posting a Semaphore
            - fn - int sem_post() - increments the value of a semaphore by one
        - Retrieivng the Current Value of a Semaphore
            - fn - int sem_getvalue() - returns the current value of a semaphore
    d. Unnamed Semaphores
        - Unnamed vs. Named
            - A semaphore shared between threads doesn't need a name
            - A semaphore that is being shared between related processes doesn't need a name
        - Initializing an Unnamed Semaphore
            - fn - int sem_init() - initializes an unnamed semaphore
        - Destroying an Unnamed Semaphore
            - fn - int sem_destroy() - destroys the semaphore, only safe to do if no process or threads are waiting on it
    e. Comparisons with Other Synchonization Techniques
        - POSIX Semaphores vs. System V Semaphores
            - Advantages
                - POSIX semaphore interface is much simpler than the System V semaphore interface
                - POSIX named semaphores eliminate the initialization problem associated with System V semaphores
                - POSIX semaphores perform considerably better in situations where the semaphore's value is such that operations can normally proceed without blocking
            - Disadvantages
                - POSIX semaphores are somewhat less portable
                - POSIX semaphores don't provide an equivalent to the System V semaphore undo feature
        - POSIX Semaphores vs. Pthreads Mutexes
            - Mutexes usually preferrable when working with threads, ownership property of mutexes enforces good structuring of code
    f. Semaphore Limits
        - SEM_NSEMS_MAX - maximum number of POSIX semaphores that a process may have
        - SEM_VALUE_MAX - maximum value that a POSIX semaphore may reach

Chapter 54: POSIX Shared Memory
    a. Overview
        - Shared Memory - allows us to share a mapped region between unrelated processes without needing to create a corresponding mapped file
        - Procedure
            - Use shm_open() to open an object with a specified name
            - Pass file descriptor obtained in previous step in a call to mmap()
    b. Creating Shared Memory Objects
        - fn - int shm_open() - creates and opens a new shared memory object or opens an existing object
            - Flags - O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC
    c. Using Shared Memory Objects
    d. Removing Shared Memory Objects
        - fn - int shm_unlink() - removes the shared memory object specified by name
    e. Comparisons Between Shared Memory APIs
        - Techniques - System V Shared Memory, Shared File Mappings, POSIX Shared Memory Objects
        - Overall
            - Fast IPC that requires a semaphore or other synchronization technique
            - Shared memory region looks like any other region once mapped
            - Shared memory region is placed within the process's virtual address space
            - Must ensure all references to locations are calculated as offsets
        - Differences
            - Data sored in a shared memory region can persist across system restarts
            - System V and POSIX use different mechanisms to identify and refer to a shared memory object, System V = Keys, POSIX = Names and FDs
            - Size of System V shard memory is fixed at the time of creation

Chapter 55: File Locking
    a. Overview
        - Goal - manage situations where multiple processes are simulataneously updating a file
        - Types
            - Advisory - process can ignore a lock places by fcntl() or flock() by simply performing I/O on a file
            - Mandatory - every file I/O operation is checked to see whether it is compatible with any locks held by other processes
    b. File Locking with flock()
        - fn - int flock() - places a single lock on an entire file
            - LOCK_SH - places a shared lock on the file referred to by fd
            - LOCK_EX - place an exclusive lock on the file referred to by fd
            - LOCK_UN - unlock the file
            - LOCK_NB - make a nonblocking lock request
        - Semantics of Lock Inheritance and Release
            - Locks automatically released when corresponding file descriptor is closed, includes duplicates
        - Limitations of flock()
            - Only whole files can be locked, only advisroy locks, many NFS don't recognize locks granted by flock()
    c. Record Locking with fcntl()]
        - Use - lock byte range corresponding to the applications defined record boundaries within the file
        - flock structure
            - short l_type - lock type
            - l_whence - seek Value
            - l_start - offset where lock begins
            - l_len - number of bytes to lock
            - l_pid - process prventing our lock
        - Library of Locking Functions
            - lockRegion() - place lock on file
            - lockRegionWait() - place lock on file, blocking request
            - regionIsLocked() - tests whether a lock can be placed on a file
        - Lock Limits and Performances
            - System wide uppler limits on number opf record locks
            - No fixed answer to how locks be acquired and released
        - Semantics of Lock Inheritance and Release
            - Record locks are not inherited across a fork() by a child process
            - Record locks are preserved across an exec()
            - All treads in a process share the same set of record locks
            - Record locks are associated with both a process and a i-node
    d. Mandatory Locking
    e. The /proc/locks File
        - View set of locks currently held in the system by examining the contents of the linux specific /proc/locks file
        - Example 1: POSIX ADVISORY WRITE 458 03:07:133880 0 EOF
            - Ordinal number of lock with the set of all locks held for the file
            - Type of lock
            - Mode of the lock
            - Type of lock
            - Process ID of the process
            - Major, Minor Device Numbers and i-node
            - Starting byte of the lock
            - Ending byte of the lock
    f. Running Just One Instance of a Program
        - Daemons - create a file in a standard directory and place a write lock on it, daemon holds the file lock for the duration of its execution and deletes the file just before terminating
    g. Older Locking Techniques
        - open() plus unlink()
        - link() plus unlink()
        - open() plus unlink()

Chapter 56: Sockets - Introduction
    a. Overview
        - Client-Server Scenario
            - Each application creates a socket. A socket is the apparatus that allows communication, and both appliations require one
            - The server binds its socket to a well know address so that clients can locate it
        - Create - a socket is created using the socket() system call, which returns a file descriptor used to refer to the socket in subsequent system calls
        - Communication Domains 
            - Domain determines method of identifying a socket and the range of communication
        - Domains
            - UNIX - communication between applications on the same host
            - IPv4 - communication between applications running on hosts connected via Internet Protocol IPv4
            - IPv6 - communication between applications running on hosts connected via an Internet Protocol IPv6
        - Socket Types
            - Stream - reliable, connection orieted
                - Reliable - guaranteed that either the transmitted data will arrive intact at the receiving application exactly as transmitted, or notification of failure
                - Bidirectional - two ways
                - Bytestream - no concept of message boundaries
            - Datagram - unreliable, message boundaries
        - Socket System Calls
            - socket() - creates a new socket
            - bind() - binds a socket to a an address
            - listen() - allows a stream socket to accept incoming connections from other sockets
            - accept() - accepts a connection from a peer applicaiton on a listening stream socket
            - connect() - establishes a connection with another socket
    b. Creating a Socket: socket()
        - fn - int socket(int domain, int type, int protocol)
    c. Binding a Socket to an Address: bind()
        - fn - int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
    d. Generic Socket Address Structure: struct sockaddr
        - struct sockaddr {
            sa_family_t sa_family; - address family
            char sa_data[4]; - socket address according to socket domain
        }
    e. Stream Sockets
        - socket() -> server bind() -> server listen() -> client connect() -> server accept() -> transmit data
        - Active and Passive Sockets
            - Active - can be used in a connect() call to establish a connection to a passive socket
            - Passive - marked to allow incoming connections by calling listen()
        - Listening for Incoming Connections: listen()
            - fn - int listen(int sockfd, int backlog) - marks stream as passive
        - Accepting a Connection: accept()
            - fn - int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) - accepts connection on listening stream socket
        - Connecting to a Peer Socket: connect()
            - fn - int connect(int sock fd, const struct sockaddr *addr, socklent_t addrlen) - connects the active socket to the listening socket
        - I/O on Stream Sockets
            - read() anmd write(), or send() and recv(), kernel buffers data between socket requests
        - Connection Termination: close()
    f. Datagram Sockets
        - Exchanging Datagrams: recfrom() and sendto()
            - fn - ssize_t recvfrom(int sockfd, void *buffer, size_t length, int flags, struct sockadd *src_addr, socklen_t* addrlen) - receive datagram
            - fn - ssize_t sendto(int sockfd, const void *buffer, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t addrlen) - send datagram

Chapter 57: Sockets - Unix Domain
    a. Overview - communication between processes on the same host
    b. Unix Domain Socket Addresses
        - struct sockaddr_un {
            sa_family_t sun_family; // AF_UNIX
            char sun_path[108]; // Null terminated socket pathname
        }
        - To bind a UNIX domain socket, we initialize a sockaddr_un structure and then pass a pointer to this structure as the addr in argument to bind()
    c. Stream Sockets in the Unix Domain
        - Idea - client-server application that uses stream sockets in the UNIX domain
        - Client connects to the server, and uses the connection to transfer data from its standard input to the server
        - Server accepts client connections and transfers all data sent on the connection by the client to standard output
        - Server is iterative, a server handles one client at a time before proceeding to the next client
        - Server Steps
            - Create a socket
            - Remove any existing file with the same pathname as that to which we want to bind the socket
            - Construct address structure for the server's socket, bind the socket to the address, and mark the sockt as a listening socket
            - Execute an infinite loop to handle incoming client requests
                - Accept a connection, obtaining a new socket fd for the connection
                - Read all of the date from the connected socket and write to stdout
                - Close the connected socket
        - Client Steps
            - Create a socket
            - Construct address structure for the server's socket and connect to the socket at that address
            - Execute a loop that copies its standard input to the socket connection, upon EOF, client terminates
            - Socket closes
    d. Datagram Sockets in the UNIX Domain
        - Important - datagram sockets under the UNIX domain are reliable, all messages are delivered in order and unduplicated
    e. UNIX Domain Socket Permissions
        - Ownership and permissions of the socket file determine which processes are able to communicate with that socket
            - To connect to a UNIX domain stream socket, write permission is required on the socket file
            - To send a datagram to a UNIX domain datagram socket, write permission is required on the socket file
    f. Creating a Connected Socket Pair: socketpair()
        - fn - int socketpair(int domain, int type, int protocol, int sockfd[2]) - does two calls to socket(), a call to bind() and either listen(), connect(), and accept() (for stream) or connect() (for datagrams)
    g. The Linux Abstract Socket Namespace
        - Abstract Namespace - Linux-specific feature that allows us to bind a UNIX domain socket to a name without that name being created in the file system
        - Advantages
            - No need to worry about possible collisions with existing names in the file system
            - Not necessary to unlink the socket pathname when we have finished using the socket, automatically removed when socket is closed
            - Don't need to create a file-system pathname for the socket

Chapter 58: Sockets - Fundamentals of TCP/IP Networks
    a. Internets
        - internet - connects different computer networks, hides the details of different physical networks
        - Internet - TCP/IP internet that connects millions of computers globally
    b. Networking Protocols and Layers
        - Networking protocol - set of rules defining how information is to be transmitted across a network, organized as a series of layers
        - TCP/IP Protocol Suite
            - Application Layer
            - Transport Layer - TCP or UDP
            - Network Layer - Internet Protocol
            - Data Link Layer
    c. The Data-Link Layer
        - Data-link layer - consists of the device driver and hardware interface network card to the underlying physical medium
        - Transfer data - data link layer encapsulates datagrams from the network layer into units called frames
        - MTU - Maximum Transmission Unit
    d. The Network Layer: IP
        - Tasks
            - Breakiung data into fragments small enough for transmission via the data-link layer
            - Routing data across the internet
            - Providing services to the transport layer
        - IP Transmits Datagrams - each datagram sent between two hosts travels independently across the network, possible taking a different route
        - IP is connectionless and unreliable
        - IP may fragment datagrams
    e. IP Addresses
        - IPv4 Address - 32 bits network address and 32 bit network mask
            - Network Mask - 1 tells which part of the address contains the assigned network ID, while Os tells which part of the address is available to the organization to assign unique host IDs on its network
        - IPv6 Address - 128 bits
    f. Transport Layer
        - Protocols
            - User Datagram Protocol - datagram sockets
            - Transmission Control Protocol - stream sockets
        - Port Numbers - differentiation of applications on host
            - Well-Known, Registered, and Privileged Ports - 22 ssh, 80 HTTO
                - 0-1023 are privileged
            - Ephemeral Ports - assigned port if no port selected
        - User Datagram Protocol - connectionless, unreliable, select size of datagram that is less than IPv4 minimum reassembly buffer size
        - Transmission Control Protocol - reliable, connection oriented, bidirectional, byte stream communication channel between two endpoints
            - Connection Establishment - sender and receiver can exchange options to advertise parameters for the connection
            - Packaging Data in Segments - each segment has a checksum that allows detection of end-to-end transmission errors
            - Acknowledgment, Retransmissions, and Timeouts - pos ack when segment arrives, retransmission possible
            - Sequencing - needed to ensure correct order of segments are sent
            - Flow Control - prevents a fast sender from overwhelming a slow receiver, TCP includes a buffers, sliding window algorithm allows unacknowledged segments containing a total of up to N bytes to be in transit between the sender and receiver
            - Congestion Control
                - Slow Start - causes the sednding TCP to initially transmit segments at a slow rate, but allows it to exponentially increase the send rate
                - Congestion Avoidance - congestion window limits the amount of unacknowledged data that it can transmit, window can grow exponentially
    g. Request for Comments RFCs

Chapter 59: Sockets - Internet Domain
    a. Internet Domain Sockets
        - Internet Stream Sockets - TCP
        - Internet Datagram Sockets - UDP
    b. Network Byte Order
        - Big Endian - Most significant byte i.e. lowest memory address first
        - Little Endian - Least significant byte i.e. highest memory address first
        - uint16_t htons() - converts int to network byte order
        - unit32_t htonl() - converts int to network byte order
        - unit15_t ntohs() - converts int to host byte order
        - unit32_t ntohl() - converts int to host byte order
    c. Data Representation
        - fn - ssize_t rfeadLine() - reads bytes from the file referred to by the file descriptor argument fd until a newline is encountered
    d. Internet Socket Addresses
        - IPv4 - struct sockaddr_in
        - IPv6 - struct sockaddr_in6
    e. Overview of Host and Service Conversion Functions
        - Converting IPv4 and IPv6 Addesses Between Binary and Human-Readable Forms
            - inet_pton() - convert IP address presentation to binary
            - inet_ntop() - convert IP address fron binary to presentation
        - Converting Host and Service Names to and From Binary Form
            - getaddrinfo() - given hostname and service name return a set of structures containing the corresponding binary IP Addresses and port number
            - getnameinfo() - converts an IP address and port number into the corresponding hostname and service name
    f. Client-Server Example Datagram Sockets
    g. Domain Name System
        - Objective - resolves human readable hostnames to IP addresses
        - Hierarchical Structure
            - Root
                - Top Level Domain - Generic Domains
                    - com
                        - google
                            - www
                    - edu
                    - net
                    - org
                        - kernel
                            - ftp
                            - www
                - Top Level Domain - Country Domains
                    - du
                    - eu
                    - us
                    - nz
                        - ac
                            - canterbury
                                - www
        - Recursive and Iterative Solution Requests
            - Recursive - requester asks the server to handle the entire task of resolution
            - Iterative - requester continuously makes requests down DNS hiearchy till resolution
    h. The /etc/services File
        - List of well known port numbers, services, and protocol
    i. Protocol Independent Host and Service Conversion
        - fn - int getaddrinfo() - given a hostname and service name, returns list of socket address structures that each contains an IP address and port number
        - fn - void freeaddrinfo() - perform deallocation of memory allocated by getaddrinfo()
        - Diagnosing Errors - List
        - fn - int getnameinfo() - given a socket address structure, returns string containing the corresponding host and service name
    j. Client Server Example Stream Sockets
    k. An Internet Domain Sockets Library
        - fn - int inetConnect() - creates a socket of a specific type and connects it to an address specified by host and service
        - fn - int inetListen() - creates a listening stream socket bound to an ip address on a TCP port
        - fn - int inetBind() - creates a socket of a specific type, bound to ip address on port specified by service and type
        - fn - char *inetAddressStr() - converts an internet socket address to printable form
    l. UNIX vs. Domain
        - Writing an application using Internet Domain Sockets is often the simplest approach, since it will work on both a single hsot and across a network
        - May want to choose UNIX for speed, use of directory access, file descriptors, credentials, etc for UNIX domain sockets

Chapter 60: Sockets - Server Design
    a. Iterative and Concurrent Servers
        - Iterative - server handles one client at a time, processing the client's request completely, before proceeding to the next client
        - Concurrent - server is designed to handle multiple clients simulataneously
    b. An Iterative UDP echo Server
    c. A Concurrent TCP echo Server
    d. Other Concurrent Server Designs
        - Preforked and Prethreaded Servers - server creates a pre-fixerd number of child processes or threads immediately on start up
        - Handling Multiple Clients from a Single Process - employ I/O models to simulataneously monitor multiple file descriptors for I/O events
        - Using Server Farms - use of multiple servers
    e. The inetd Internet Superserver Daemon
        - Goal - eliminate the need to run large numbers of infrequently used servers
        - Benefits
            - Single process, inetd daemon, monitors a specific set of socket ports and starts other servers as required
            - Programming of servers started by inetd is simplified
        - The /etc/inetd.conf file
            - Configuration file where each line describes one of the services to be handled by inetd

Chapter 61: Sockets - Advanced Topics
    a. Partial Reads and Writes on Stream Sockets
        - Partial - read() and write() transfer fewer bytes than requested
        - fn - ssize_t readn() - used to restart read system calls
        - fn - ssize_t writen() - used to restart write system calls
    b. The shutdown() System Call
        - fn - int shutdown() - closes one or both channels of the socket sockfd, depending on the value of how
    c. Socket-Specific I/O System Calls: recv() and send()
        - fn - ssize_t recv() - returns bytes received
        - fn - ssize_t send() - sends bytes
    d. The sendfile() System Call
        - fn - ssize_t sendfile() - file contents are transferred directly to the socket, without passing through user space, zero-copy transfer
        - TCP_CORK socket option - output is buffered into a single TCP segment until either the upper limit on the size of a segment is reached, the option is disable, the socket is closed, or 200ms pass
    e. Retrieving Socket Addresses
        - fn - int getsockname() - return local address to which a socket is bound
        - fn - int getpeername() - return address of the peer socket to which the local socket is connected
    f. A Closer Look at TCP
        - Format of a TCP Segment
            - Source Port Number - port number of sending TCP
            - Destination Port Number - port number of destination TCP
            - Sequence Number
            - Acknowledgment Number
            - Header Length
            - Reserved
            - Control Bits
                - CWR - congestion window reduced flag
                - ECE - explicit congestion notification echo flag
                - URG - urgent pointer field flag
                - ACK - acknowledger number field flag
                - PSH - push all received data to receiving process
                - RST - reset connection
                - SYN - synchornize sequence numbers
                - FIN - indicates sender has finished sending data
            - Window Size
            - Checksum
            - Urgent Pointer
            - Option
            - Data
        - TCP Sequence Numbers and Acknowledgements
        - TCP State Machine and State Transition Diagram
            - LISTEN - TCP is waiting for connection
            - SYN_SENT - TCP has sent a SYN for active open
            - SYN_RECV - TCP, in LISTEN statek, has received a SYN and responded with SYN/ACK
            - ESTABLISHED - Connection to peer TCP has been completed
            - FIN_WAIT1 - application has closed the connection
            - FIN_WAIT2 - TCP formerly in FIN_WAIT1 has received ACK from TCP
            - CLOSING - TCP formerly awaiting ACK in FIN_WAIT1 has received a FIN
            - TIME_WAIT - TCP has recieved a FIN, indicating the peer TCP has performed a passive close
            - CLOSE_WAIT - TCP has received a FIN from the peer TCP
            - LAST_ACK - application performed a passive close, and the TCP, formerly in CLOSE_WAIT, sent a FIN to peer TCP and is waiting for acknowledgement
        - TCP Connection Establishment
            - Server calls listen() to perform a passive open of a socket
            - Server calls accept(), which blocks until a connection is established
            - Client calls connect() to perform an active opens of a socket ijn order to establish a connection to the server's passive socket
        - TCP Three-Way Handshake
            - Client calls connect(), sends a SYN segment to server TCP
            - Server sends SYN and piggybacked ACK
            - Client sends an ACK
        - TCP Connection Termination
            - Client sends a FIN to server
            - Server responds with an ACK
            - Server sends a FIN to client
            - Client responds with an ACK
        - Calling shutdown() on a TCP Socket
            - shutdown() - closes one channel of the connection
    g. Monitoring Sockets: netstat
        - netstat - displays the state of Internet and UNIX domain sockets on a system
        - flags
            - a - display information about all sockets includign listening
            - e - display extended information
            - c - redisplay socket information continuously
            - l - display information about listening sockets
            - n - display IP addresses, port numbers, usernames in numerical format
            - p - show process ID and name of program to which socket belongs
            - inet - display information about Internet domain sockets
            - tcp - display information about Internet domain TCP stream sockets
            - udp - diaply information about Internet domain UDP datagram sockets
            - unix - display information about UNIX domain sockets
    h. Using tcpdump to Monitor TCP Traffic
        - tcpdump - debugging tool that allows superusers to monitor the internet traffic on a live network, generating real time textual output
    i. Socket Options
        - fn - int getsockopt() - retrieve socket options
        - fn - int setsockopt() - sets socket options
    j. The SO_REUSEADDR Socket Option
        - Purpose - to avoid the EADDRINUSE error when a TCP server is restarted and tries to bind a socket to a port that curently has an associated TCP
    k. Inheritance of Flags and Options Across accept()\
        - Attributes Not Inherited
            - status flags assocaited with an open file descriptor
            - file descriptor flags
            - owner process ID and generated signal file descriptors associated with signal driven I/O
    l. TCP vs. UDP
        - Why use UDP?
            - A UDP server can receive and reply to datagrams from multiple clients, without needing to create and terminate a connection for each client
            - UDP can be faster for simple request-response communications
            - UDP sockets permit broadcasting and multicasting
                - Broadcasting - allows a sender to transmit a datagram to the same destination port on all of the hsots connected to a network
                - Multicasting - allows a datagram to be sent to a specified set of hosts
            - Streaming video and audio can function acceptably without the reliability provided by TCP
    m. Advanced Features
        - Out-of-Band Data - feature of stream sockets that allows a sender to mark transmitted data as high priority
        - The sendmsg() and recvmsg() System Calls - general purpose of the socket I/O Calls
        - Passing File Descriptors - possible with sendmsg() and recvmsg()
        - Receiving Sender Credentials - user ID, groupd ID, and process ID
        - Sequenced-Packet Sockets - combine features of both stream and datagram sockets
        - SCTP and DCCP Transport-Layer Protocols
            - Stream Control Transmission Protocol - support telphony signaling in particular, multistream support, multiple logical datastreams to be employed over a single connection
            - Datagram Congestion Control Protocol - congestion control to prevent a fast transmitter from overwhelming the network