Title: Practical Malware Analysis
Authors: Michael Sikorski and Andrew Honig

Summarization of Content

Malware Analysis Primer
    - What is malware analysis?
        - Act of dissecting malware to understand how it works, how to identify it, and how to defeat or eliminate it
    - The Goals of Malware Analysis
        - Purpose - provide the information you need to respond to a network intrusion
    - Malware Analysis Techniques
        - Basic Static Analysis - examining the executable file without viewing the actual instructions
        - Basic Dynamic Analysis - running the malware and observing its behavior on the system in order to remove the infection, produce effective signatures, or both
        - Advanced Static Analysis - reverse-enginerring the malware's internals by loading the executable into a disassembler and looking at the program instructions in order to discover what the program does
        - Advanced Dynamic Analysis - uses a debugger to examine the internal state of a running malicious executable
    - Types of Malware
        - Backdoor - code that installs itself onto a computer to allow the attacker access
        - Botnet - allows the attacker access to teh system, but all computers infected receive the same instruction from a single command and control server
        - Downloader - malicious code that downloads other malicion code
        - Information-Stealing Malware - collects information from victim's computer and usually sends it to the attacker
        - Launcher - launches other malicious prorgams
        - Rootkit - code designed to conceal the existence of other code
        - Scareware - designed to frighten an infected user into buying something
        - Spam-sending Malware - malware that infects a user's machine and then uses that machine to send spam
        - Worm or Virus - malicious code that can copy itself and infect additional computers
        - Note - malware often spans multiple categories, complex, collaborative
    - General Rules for Malware Analysis
        - Don't get caught up in the details, focus on the key features
        - Remember that different tools and approaches are available for different jobs, there is no one approach
        - Malware analysis is a pendulum, back and forth

Chapter 1: Basic Static Analysis
    - Antivirus Scanning: A Useful First Step
        - Run the malware through various antivirus programs
        - This relies on a database of identifiable pieces of known suspicious code (file signatures), as well as behavior and pattern matching analysis (heurisitcs)
    - Hashing: A Fingerprint for Malware
        - Use Message Digest Algorithm to produce a unique hash that identifies the malware
        - Use Hash
            - Use the hash as a label
            - Share that hash with other analysts to help them to identify malware
            - Search for that hash online to see if the file has already been identified
    - Finding Strings
        - Searching through strings can be a simple way to get hints about the functionality of a program
    - Packed and Obfuscated Malware
        - Obfuscated programs are ones whose execution the malware author has attempted to hide
        - Packed programs are a subset of obfuscated programs in which the malicious programs is compressed and cannot be analyzed
        - Packing Files
            - When a packed program is run, a small wrapper program also runs to decompresse the packed file and then run it, when analyzed statically, only the small wrapper program can be dissected
            - Detecting Packers with PEiD - Use PEiD to detect the type of packer or compiler employed to build an application which makes analyzing the packed file much easier
    - Portable Executable File Format
        - PE format is used by Windows executables, object code, and DLLs, contains information necessary for the Windows OS loader to manage the wrapped executable code
    - Linked Libraries and Functions
        - Static, Runtime, and Dynamic Linking
            - Static - all code from that library is copied into the executable
            - Runtime - connect to libraries only when that function is needed
                - Common Functions - LoadLibrary, GetProcAddress - allow programmers to import linked functions not listed in a program's file header
            - Dynamic - most common, host OS searches for the necessary libraries when the program is loaded
        - Exploring Dynamically Linked Functions with Dependency Walker
            - Dependency Walker - lists dynamically linked functions in an executable
    - Static Analysis in Practice
        - PotentialKeylogger.exe: An Unpacked Executable
            - Dependency Walker -> Imported Functions
            - Key Imports
                - Kernel32.dll
                    - OpenProcess, GetCurrentProcess, GetProcessHeap, ReadFile, CreateFile, WriteFile, FindFirstFile, FindNextFile - can open and manipulate processes
                - User32.dll
                    - RegisterClassEx, SetWindowText, ShowWindow, RegsiterHotKey - high likelihood that this program has a GUI that may be used by hacker, triggered open using custom hotkey
                - GDI32.dll - confirm program probably has a GUI
                - Shell32.dll - program can launch other programs
                - Advapi32.dll - program uses registry which in turn tells us that we should search for strings that look like registry keys
                - Exports - LowLevelKeyboardProc and LowLevelMouseProc - used with SetWindowsHookEx to specify which function will be called when a specific event occurs
            - Packed Program.exe: A Dead End - with basic static analysis that is
    - The PE File Headers and Sections
        - Can provide a considerably larger amount of information than just imports
            - .text - contains the instructions that the CPU executes
            - .rdata - contains the import and export information
            - .data - contains programs global data
            - .rsrc - includes the resources used by the executable that are not considered part of the executable
        - Examining PE Files with PEview
            - Allows browsing through above described information
        - Viewing the Resource Section with Resource Hacker
        - Other PE Tool 
            - PEBrowse Professional and PE Explorer

Chapter 2: Malware Analysis in Virtual Machines
    - The Structure of a Virtual Machine
        - Guest OS w/ Virtual Applications and Virtual Memory
    - Creating Your Malware Analysis Machine
        - Install VMware Tools
        - Configuring VMwre
            - Disconnect the Network
            - Set Up Host Only Network
            - Use Multiple Virtual Machines
    - Using Your Malware Analysis Machine
        - Connect Malware to Internet - bridged network adapter
        - Connecting and Disconnecting Peripheral Devices - prevent USB devices from being connected
        - Taking Snapshots
            - Snapshot -> Launch Malware -> Malware Executing -> Revert to Snapshot
        - Transferring Files from a Virtual Machine - shared folders or drag and drop
    - The Risk of Using VMware for Malware Analysis
        - Some malware use techniques to recognize running in a virtual machine
    - Recrod/Replay: Running Your Computer in Reverse
        - VMware records everything that happens so you can replay the recording at a later time

Chapter 3 - Basic Dynamic Analysis
    - Dynamic Analysis
        - Goal - examination performed after executing malware
    - Sandboxes - The Quick and Dirty Approach
        - Using a Malware Sandbox
            - Norman Sandbox, GFI Sandbox, Anubis, Joe Sandbox, ThreatExpert, BitBlaze, Comdo Instant Malware Analysis
        - Example Sections
            - Analysis Summary, File Activity, Created Mutexes, Registry Activity, Network Activity, VirusTotal Results
        - Sandbox Drawbacks
            - Executable run without command line options
            - Sandbox may not record all events
            - Some malware requires the presence of certain registry keys or files
            - Some exported functions will not be invoked
            - Sandbox OS may not be correct for the malware
            - Sanbox cannot tell you what the malware does
    - Running Malware
        - Use rundll32.exe - launches DLLs associated with malware
    - Monitoring with Process Monitor
        - Process Monitor (procmon) - advanced monitoring tool for Windows that provides a way to monitor certain registry, file systems, network, process, and thread activity
        - The Procmon Display - configurable columns e.g. sequence number, timestamp, name of process, event operation, path used, and result of event
    - Viewing Processes with Process Explorer
        - The Process Explorer Display
            - Process Explorer monitors the processes running on a system and shows them in a tree structure that displays child and parent relationships
            - Columns - proceess name, process identifier (PID), CPU usage, description, and company name
        - Using the Verify Option
            - Verifies that the image on disk is in fact the microsoft signed binary, malware often replaces authentic Windows files with its own in an attempt to hide
        - Comparing Strings - compare strings contained in the executable
        - Using Dependency Walker - can launch from PE
        - Analyzing Malicious Documents - open document in PE and see if document launches any process
    - Comparing Registry Snapshots with Regshot
        - RegShot - open source registry  comparison tool that allows you to take and compare two registry snapshots
        - Shot -> Run Malware -> Shot - Repeat
    - Faking a Network
        - Using ApateDNS - quickest way to see DNS requests made by malware by spoofing DNS responses to a user specified IP address by listening on UDP port 53
        - Monitoring with Netcat - TCP/IP Swiss Army Knife - use netcat to listen to connections, then run malware
        - Packet Sniffing with Wireshark - open source sniffer, a packet capture tool that intercepts and logs network traffic\
        - Using INetSim -  suite for simulating common Internet Service e.g. HTTP, HTTPS, FTP, IRC, DNS, SMTP
    - Basic Dynamic Tools in Practice
        - Running procmon and set a filter on the malware executable name and clearing out all events before running
        - Start PE
        - Gather a first snapshot of the registery using RegShot
        - Set up virtual network using INetSim and ApateDNS
        - Set up network traffic logging using WireShark

Chapter 4: A Crash Course in x86 Disassembly
    - Levels of Abstraction
        - Hardware - physical level, circuits, digital logic
        - Microcode - firmware, operates on exact circuitry for which it was designed
        - Machine Code - opcodes, hexadecimal digits that tell the processor what you want it to do
        - Low-Level Languages - assembly language, human readable verson of a computer architectures instruction set
        - High-Level Languages - where most computer programmers operate
        - Interpreted Languages - languages translated to bytecode, which is executed within an interpreter and then translated into executable machine code on the fly
    - Reverse Engineering
        - Goal - convert binary data at the machine level into assembly language using a disassembler
    - The x86 Architecture
        - Von Neumann Architecture - CPU, RAM, I/O
        - Main Memory
            - Stack, Heap, Code, Data
        - Instructions - building blocks of assembly programs, includes a mnemonic and zero or more operands
        - Opcodes and Endianess
            - Big-Endian - most significat bit is ordered first i.e. at smallest address
            - Little-Endian - least significant bit is ordered first i.e. at smallest address
        - Operands
            - Immediate - fixed values
            - Register - refer to registers
            - Memory Address - refer to a memory address
        - Registers
            - General Registers - used by CPU during execution, typically sstore data or memory addresses and are often used interchangeably
            - Segment Registers - used to track sections of memory
            - Status Flags - used to make decisions
                - ZF - zero flag is set when result of an operation is equal to zero
                - CF - carry flag is set when result of an opertation is too large or too small for destination operand
                - SF - sign flag is set when the result of an operation is negative or cleared when the result is positive
                - TF - trap flag is used for debugging, only one instruction will be executed at a time
            - Instruction Pointers - used to keep track of the next instruction to execute
                - EIP - contains memory address of the next instruction to be executed for a program
        - Simple Instructions
            - mov destination, source
            - sub destination, value
            - add destination, value
            - mul value - always acts on EAX
            - div value - always acts across EDX and EAX
            - xor destination, value
            - or destination, value
            - nop - does nothing, sometimes used by malware as a sled for buffer overflow attacks
        - The Stack - ADT structure where elements are pushed onto the top, and pops i.e. removed from the to LIFO
        - Conditionals
            - test - identical to and, however operands are not modified, flag is just set
            - cmp - identical to sub, however operands are not affected, flags are just set
        - Branching
            - Branch - a sequence of code that is conditionally executed depending on the flow of the program
            - Jump Instructions - causes the next instruction to be executed to be the one specified by jmp
            - Jmp examples pg. 81
        - Rep Instructions
            - Set of instructions for manipulating data buffers
